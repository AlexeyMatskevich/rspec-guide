# Навигация
- [Что можно изучить по тестам](#что-можно-изучить-по-тестам)
- [Про RSpec](#про-rspec)
- [Пирамида тестирования и выбор уровня](#пирамида-тестирования-и-выбор-уровня)
- [Глоссарий](#глоссарий)
- [RSpec style guide](#rspec-style-guide)
- [Тестирование API-контрактов: границы применимости RSpec](#тестирование-api-контрактов-границы-применимости-rspec)
- [Внешние сервисы](#внешние-сервисы)
- [Нюансы времени между Ruby и PostgreSQL](#нюансы-времени-между-ruby-и-postgresql)

# Что можно изучить по тестам

- **Better Specs** — стиль и формулировки: научитесь писать читаемые `describe/context/it`, выбирать матчеры и избегать анти-паттернов. <https://www.betterspecs.org>
- **Testing for Beginners** — вводная книга: поймёте, что тестировать, как мыслить сценариями и разбирать красные тесты. <http://testing-for-beginners.rubymonstas.org/index.html>
- **Pluralsight: RSpec Ruby Application Testing** — hands-on курс: шаг за шагом построите BDD-цикл, закрепите структуру `describe/context/it` и три фазы теста. <https://www.pluralsight.com/courses/rspec-ruby-application-testing>
- **Everyday Rails Testing with RSpec** — практики и инструменты: от factory_bot до VCR/WebMock, плюс ежедневные паттерны поддержки базового покрытия. <https://leanpub.com/everydayrailsrspec>

Эти материалы дадут базу. Ниже — философия RSpec/BDD, на которой держатся правила из следующего раздела.

# Про RSpec

RSpec — тестовая библиотека для Ruby с DSL, заточенным под описание поведения, а не внутренней реализации.

```ruby
describe "my app" do
  it "works" do
    expect(MyApp.working).to eq(true)
  end
end
```

Официальный слоган на https://rspec.info/:

```
Behaviour Driven Development for Ruby.
Making TDD Productive and Fun.
```

Ключевая мысль: RSpec — инструмент BDD для Ruby. Он делает практику TDD продуктивной и более "человечной" за счет языка, близкого к бизнес-формулировкам.

## Как связаны RSpec, BDD и TDD

TDD (test-driven development) — короткий цикл Red -> Green -> Refactor:
- пишем тест, фиксирующий желаемое поведение;
- пишем минимальный код, чтобы тест прошел;
- рефакторим, сохраняя зеленое состояние.

BDD (behaviour-driven development) вырос из TDD и смещает фокус на поведение домена и язык разговора с бизнесом. Тесты становятся читаемой спецификацией, а не просто проверкой кода.

RSpec воплощает BDD в экосистеме Ruby: `describe/context/it` помогают формулировать поведение единообразно и понятно.

## Зачем нам BDD на практике

- Единый язык с бизнесом: формулируем правила домена "человеческими" фразами, не зная реализации.
- Исполняемая документация: тесты — проверяемая спецификация поведения.
- Быстрая локализация проблем: упавший тест явно показывает, какое правило нарушено.
- Свободный рефакторинг: фокус на том, что делает система, а не как она устроена.

**Предметная область** — набор правил и понятий, которые бизнес хочет видеть в системе (например, биллинг). В коде мы реализуем именно эти правила поведения.

## От естественного языка к формальному синтаксису Gherkin

BDD часто опирается на Gherkin — формальный, но читаемый синтаксис для описания историй и сценариев. Он фиксирует три ключевые фазы: Given (исходный контекст), When (действие), Then (результат).

Пример истории и сценариев:

```
As a store owner
In order to keep track of stock
I want to add items back to stock when they're returned.

Scenario 1: Refunded items should be returned to stock
  Given that a customer previously bought a black sweater from me
  And I have three black sweaters in stock
  When they return the black sweater for a refund
  Then I should have four black sweaters in stock

Scenario 2: Replaced items should be returned to stock
  Given that a customer previously bought a blue garment from me
  And I have two blue garments in stock
  And three black garments in stock
  When they return the blue garment for a replacement in black
  Then I should have three blue garments in stock
  And two black garments in stock
```

И адаптация на русском:

```
Как владелец магазина
Чтобы следить за запасами на складе
Я хочу возвращать товары на склад, когда их возвращают покупатели.

Сценарий 1: Возвращенные товары должны вернуться на склад
  Дано, что клиент ранее купил у меня черный свитер
  И на складе есть три таких свитера
  Когда клиент возвращает свитер
  Тогда на складе должно быть четыре черных свитера

Сценарий 2: Обмененные товары должны вернуться на склад
  Дано, что клиент покупал у меня одежду синего цвета
  И на складе есть два таких наименования синего цвета
  И три наименования черного цвета
  Когда клиент возвращает синюю вещь, чтобы обменять на черную
  Тогда на складе должно быть три синих наименования
  И два черных наименования
```

### Язык Gherkin — памятка

| Ключевое слово (EN) | Русский | Короткое описание |
| --- | --- | --- |
| Story / Feature | История | Заголовок спецификации, формулирует ценность. |
| As a | Как (в роли) | Роль заинтересованного лица. |
| In order to | Чтобы достичь | Цель роли. |
| I want to | Я хочу | Краткий желаемый результат. |
| Scenario | Сценарий | Конкретный сценарий истории. |
| Given | Дано | Исходный контекст (повторяется через And). |
| When | Когда | Действие, запускающее сценарий. |
| Then | Тогда | Наблюдаемый результат (можно добавлять And/But). |
| And / But | И / Но | Уточнение контекста или исключения. |

### Как это соотносится с RSpec

RSpec не требует Gherkin и не исполняет `.feature`-файлы, но следует тем же смысловым фазам:

- **Given** -> подготовка контекста (`let`, `before`, вспомогательные методы).
- **When** -> действие, которое проверяем (вызов метода, HTTP-запрос, команда).
- **Then** -> ожидаемый результат (`expect`-утверждения).
- **Feature / Story** -> верхний уровень `describe`, задающий область поведения.
- **Scenario** -> `it`, конкретный пример поведения.
- **And / But** -> уточнение контекста через вложенные `context`.

Это не механическое соответствие один-к-одному, но такая оптика помогает писать тесты как читабельные спецификации домена. На этой базе построены правила из следующего раздела.

## Пирамида тестирования и выбор уровня

BDD ставит во главу угла поведение, но сами проверки живут на разных уровнях. Держите в голове пирамиду: быстрые модульные тесты в основании, сервисные/интеграционные — посредине, end-to-end и контрактные — на вершине. Правильный выбор уровня помогает не скатываться к проверкам реализации.

| Уровень | Вопрос | Наблюдение | Типичные инструменты |
| --- | --- | --- | --- |
| Юнит (модель, сервис, объект) | Как ведёт себя маленький кусок логики? | Возвращаемое значение, вызовы зависимостей (через doubles) | `expect`, doubles, pure Ruby |
| Интеграционный / сервисный | Как взаимодействуют несколько компонентов? | Ответ сервиса, изменение доменной модели, побочные эффекты | Request/feature specs, ActiveJob, mailers |
| Request / API-контракты | Что видит клиент (frontend, внешний сервис)? | HTTP-статус, тело ответа, заголовки | Request (API-контракт) specs, pact/contract tests |
| Системный (E2E) | Работает ли пользовательская история целиком? | UI-реакции, end-to-end поток | Capybara, Cypress, etc. |

Железных правил нет, но есть ориентиры:

- Проверяйте на том уровне, где поведение естественно наблюдать. Request (API-контракт) spec проверяет статус/ответ, а не содержимое базы — иначе вы тестируете реализацию контроллера, а не API-контракт (см. правило 2).
- Если одна проверка требует сложной подготовки контекста или медленных зависимостей, подумайте, не лучше ли перенести часть логики в более низкий уровень пирамиды.
- Единичный побочный эффект (создана запись, отправлено письмо) лучше выносить в отдельный юнит/сервисный тест. В BDD-контрактах фиксируйте лишь то, что важно потребителю.
- `:aggregate_failures` (правило 19) применяем, только если говорим об одном поведении и хотим увидеть все нарушения сразу — это не способ проверить половину пирамиды в одном `it`.

С пирамидой в голове легче решать, что считать happy path, что — corner case, и какой уровень тестов ответственен за подтверждение каждого правила.

## Глоссарий

### Основные понятия

- **Поведение** — наблюдаемое изменение состояния системы или её реакция на внешнее воздействие, которое можно описать одним предложением на естественном языке.

  Поведение в контексте BDD и RSpec — это не каждый атрибут или метод объекта, а бизнес-правило или результат действия, который имеет значение для заинтересованных лиц.

  **Примеры поведений:**
  - "Создаёт заказ в базе данных"
  - "Отправляет подтверждение на email"
  - "Предоставляет полный профиль пользователя из сессии"
  - "Блокирует доступ для неавторизованного пользователя"
  - "Вычисляет итоговую стоимость с учётом скидки"
  **НЕ являются отдельными поведениями:**
  - Каждый отдельный атрибут конфигурационного объекта (например, `name`, `email`, `phone` — это части интерфейса объекта User)
  - Каждое поле в структуре API-ответа (все поля вместе составляют контракт ответа)
  - Каждый геттер value object (геттеры вместе формируют публичный интерфейс)

  **Правило:** Если вы не можете описать проверку как самостоятельное действие или результат на естественном языке, скорее всего это часть более крупного поведения.

### Виды тестирования

В зависимости от того, что именно мы проверяем, тесты делятся на два основных типа:

- **Поведенческое тестирование (Behavioral testing)** — проверка бизнес-логики через наблюдаемые побочные эффекты или реакции системы. Каждое действие вызывает независимый эффект, который важен для бизнеса.

  **Примеры:**
  - Проверка, что метод создаёт запись в базе данных
  - Проверка, что сервис отправляет email
  - Проверка, что статус заказа изменился после оплаты
  - Проверка, что система логирует событие

  **Характерные признаки:**
  - Каждый эффект — отдельное правило бизнес-логики
  - Эффекты независимы друг от друга
  - Можно описать каждый эффект отдельным предложением: "система делает X"

- **Интерфейсное тестирование (Interface testing)** — проверка набора атрибутов объекта в определённом состоянии. Все проверяемые атрибуты выводятся из одного источника/состояния и представляют единое поведение: "объект предоставляет корректный интерфейс".

  **Примеры применения:**
  - Value objects с множественными атрибутами (Money, Address, Coordinate)
  - Конфигурационные объекты (Settings, Config, Preferences)
  - Read-only интерфейсы, построенные из единого источника
  - Presenter/Decorator объекты, предоставляющие производные атрибуты

  **Характерные признаки:**
  - Атрибуты связаны общим источником данных
  - Изменение источника влияет на все атрибуты сразу
  - Атрибуты формируют целостный контракт объекта
  - Описывается как "объект предоставляет интерфейс X"

  **Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, это интерфейсное тестирование — объедините проверки в один `it` с `:aggregate_failures`.

  **Важно:** Интерфейсное тестирование применимо к доменным объектам. Для HTTP API-интерфейсов используйте специализированные инструменты фиксации контрактов (см. раздел "Тестирование API-контрактов: границы применимости RSpec").

### Характеристики и состояния

- **Характеристика** — доменный аспект, влияющий на исход поведения (роль пользователя, способ оплаты, статус заказа).
  - *Как найти:* спросите «если изменить этот аспект, изменится ли ожидаемый результат?», и убедитесь, что речь идёт о бизнес-факте, а не о технической детали.

- **Состояние характеристики** — конкретный вариант значения характеристики, важный для правила (подписка активна, баланс ниже лимита).
  - *Как выделить:* сгруппируйте возможные значения в доменные диапазоны и сформулируйте их короткими утверждениями.
  - *Типы состояний:*
    - бинарные (да/нет: карта привязана ↔ не привязана);
    - множественные (enum: роль = admin / manager / guest);
    - диапазоны (число/дата: баланс ≥ стоимость / баланс < стоимость).

- **Контекст (`context`)** — блок, фиксирующий одно или несколько состояний характеристик. Контекст отвечает за «Given»-часть спецификации.
  - **Положительный контекст** — состояние выполняется (обычно часть happy path).
  - **Отрицательный контекст** — состояние нарушено или отрицается (часто часть corner case).
  - **Вложенный контекст** — уточняет внешний, добавляя состояние новой характеристики или уточняя текущую.

- **Кейс / пример (`it`)** — минимальный сценарий, проверяющий конкретное поведение на выбранном наборе состояний.
  - **Happy path case** — основной поток: ожидаемый успех без исключений.
  - **Corner case** — отклонение от основного потока: крайние значения, ошибки, исключительные ситуации.
  - **Положительный тест** — пример подтверждает поведение (чаще совпадает с happy path).
  - **Отрицательный тест** — пример показывает отказ или защиту от некорректного поведения (часто совпадает с corner case).
  - *Важно:* happy/corner описывают тип кейса, а положительный/отрицательный — результат проверки. При множественных состояниях возможно несколько happy path кейсов без отрицательных тестов на этой характеристике.

- **Задание состояния (`let`/`before`)** — объявление, которое делает формулировку контекста истинной. Его размещают сразу под соответствующим `context`, чтобы связь между описанием и подготовкой контекста читалась без поиска по файлу (см. пункт 9).

| Тип кейса       | Тип контекстов внутри                  | Результат теста             |
| --------------- | -------------------------------------- | --------------------------- |
| Happy path case | Положительные контексты                | Положительный тест          |
| Corner case     | Отрицательные или уточняющие контексты | Отрицательный тест / защита |

Таблица отражает типичную связь, но возможны исключения — например, enum-характеристика может включать несколько happy path кейсов без отрицательных тестов, или corner case может завершаться положительным результатом (например, graceful degradation).

- **Flaky test** — тест, который ведёт себя непредсказуемо: иногда зелёный, иногда красный при неизменном коде. Чаще всего связан с нестабильным временем, глобальным состоянием, случайным порядком или зависимостями от внешних сервисов.

# RSpec style guide

## Поведение и структура тестов

### 1. Тестируйте поведение, а не реализацию.

Если в вашем тесте нет описания поведения, то это не тест. Почему? При отсутствии описания поведения возникает привязка
к реализации, когда после вас кто-то будет смотреть тесты - он ничего не поймет и тесты окажутся бесполезными.
###### далее `some_action` в примерах - это псевдокод, который мы тестируем и поведение которого мы описываем
```ruby
# отвратительно
describe "#some_action" do
  # ... создаем пользователя, но не связываем подготовку контекста с описанием
  it "true" do          # из этого описания не понятно, что означает факт того, что мы ожидаем `true`
    expect(some_action).to be(true)
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... создаем пользователя и явно задаём характеристику, о которой говорим в `it`
  it "allows unlocking the user" do         # это описание рассказывает нам о том, что означает наше ожидание от кода
    expect(some_action).to be(true)
  end
end
```

Что не так в плохом примере:

- Описание `it` не рассказывает о поведении; непонятно, что означает ожидаемый `true`.
- Контекст в комментарии не связывается с формулировкой примера, поэтому спецификация не читается как правило поведения.

Или, например, используйте `match_array` или `contain_exactly`, когда пишите ожидание для массива, порядок значений в котором вам не важен.
```ruby
# плохо
expect(some_action).to eq [1, 2, 3] # pass
```

```ruby
# хорошо
expect(some_action).to match_array [2, 3, 1] # pass
expect(some_action).to contain_exactly(1, 2, 3) # pass
```

Что не так в плохом примере:

- Сравнение `eq` привязывает тест к порядку элементов и ведёт к ложным падениям при изменении последовательности.
- Поведение (состав коллекции) не выражено напрямую, поэтому спецификация описывает реализацию, а не правило.

Представим что `some_action` возвращал всегда `[1, 2, 3]` и ваши тесты проходили,
потом вы внесли какие-то изменения в код, обновили базу данных и т.д. То есть по какой-то причине порядок в массиве изменился,
например, он стал `[2, 1, 3]`,
и у вас начала падать дюжина тестов. И все это произошло из-за вашей привязки к реализации!
Не делайте так, тестируйте конкретное поведение.
Если это выборка данных, то проверяйте факт правильной выборки данных.

В целом, каждый раз как вы работаете с любой коллекцией (массивы, хеши, ActiveRecord::Relation ...)
и используете `eq`, то это звоночек, что вы делаете что-то не так. Возможно существует хелпер из библиотеки `RSpec Expectations`, подходящий
для определения вашего ожидания, а возможно вы в принципе не то тестируете (не поведение вашего кода) или даже не то реализуете.

### 2. Каждый example (`it`) описывает одно наблюдаемое поведение

Описание в `it` должно быть уникальным и рассказывать об одной бизнес-истине. Если два примера называют одно и то же, значит мы проверяем реализацию разными путями. Это запах: либо нужно выделить отдельное поведение, либо перераспределить проверки по пирамиде тестирования.

- Один `it` = одна ситуация из спецификации = одно ключевое наблюдение.
- Наблюдение выбираем на уровне контракта (HTTP-статус, тело ответа, возвращаемое значение), а не внутренних побочных эффектов, если только команда не договорилась иначе.
- Когда нужно проверить несколько следствий одного правила, разделяйте их на разные `it`. `:aggregate_failures` используйте лишь когда действительно говорите об одном поведении (см. пункт 19).

Тест — это короткое утверждение о поведении, а не мини-программа. Чем точнее формулировка `it`, тем легче читать спецификацию как документацию.

```ruby
# плохо
it "creates a user" do
  expect { post_signup }.to change(User, :count)
  expect(response).to redirect_to dashboard_path
end
```

```ruby
# хорошо
it "redirects user to dashboard after signup" do
  post_signup
  expect(response).to redirect_to dashboard_path
end

it "persists the user after signup" do
  expect { post_signup }.to change(User, :count)
end
```

Что не так в плохом примере:

- Два разных поведения спрятаны в одном `it`, поэтому при падении непонятно, какое правило нарушено.
- Информация в отчёте RSpec теряет связь с описанием поведения, и тест перестаёт быть спецификацией.
- Информацию в отчёте RSpec приходится анализировать, а так же обращаться к тесту, чтобы разобраться, какое поведение было ожидаемым, из-за отсутствия описания в отчете.

Request (API-контракт) spec пример. Мы хотим убедиться, что авторизация успешна, и выбираем наблюдение на уровне API, а не БД:

```ruby
# плохо
it "creates a session" do
  post "/sessions", params: creds
  expect(Session.count).to eq 1
end
```

```ruby
# хорошо
it "returns an access token" do
  post "/sessions", params: creds
  expect(response).to have_http_status(:created)
  expect(response.parsed_body.fetch("token")).to be_present
end
```

Что не так в плохом примере:

- Проверка обращается к базе напрямую и фиксирует реализацию контроллера вместо публичного API-контракта.
- Падение такого теста подсказывает только «запись не создана», а не то, что клиенту пришёл неверный ответ.

> Не сравнивайте JSON целиком строкой: смотрите раздел 22 («Делайте вывод падения теста читаемым») — там показано, как структурный дифф помогает увидеть расхождение сразу.

Если в `it` появляется много `expect`, это обычно сигнал: мы пытаемся зафиксировать побочные эффекты вместо поведения. Типичный пример — регистрация пользователя и отправка welcome-письма. В request-spec мы проверяем статус/ответ API, а факт отправки письма опускаем на уровень юнит/сервисного теста (или возвращаемся к пирамиде и пишем отдельный сценарий, если письмо — самостоятельное правило). Не превращайте спецификацию поведения в маленькую программу: циклы, условные операторы и вычисления в тестах — прямой признак, что мы перестали описывать правила и начали переписывать реализацию.
Кто-то может сказать, что это накладно по ресурсам и лучше совмещать многие тесты в один `it`.

Да, действительно, это ускорит тесты по нескольким причинам:

1. Ожидания в одном `it` не изолированы друг от друга, из-за чего тестовые данные создаются для них один раз, что быстрее,
   чем создавать их много раз для каждого ожидания;
2. При падении первого ожидания, следующие не проверяются, что тоже экономит время.

Но смотрите к каким недостаткам это приводит:
1. Это делает менее читаемыми результаты тестов (вывод в консоли);
2. Это делает менее читаемым сам тест, его ожидания;
3. Будет не вполне понятно, какое именно ожидание соответствует описанию поведения в `it`;
4. Отсутствие изоляции делает менее надежными ожидания, они могут начать друг на друга влиять (но такое очень редко бывает);
5. Самое важное, что это может быть запахом плохого дизайна кода, который покрывается данными тестами.

   Если вы делаете ожидания на несколько разных вещей, то получается что ваш код делает тоже несколько разных вещей,
   а это нарушает данное правило:
    ```markdown
    Do One Thing
    
    FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL.
    THEY SHOULD DO IT ONLY.
    
    * Clean Code Robert Martin
    ```
   Как видите, тестирование поведения отражает поведение самого кода и его изъяны. Если ваши тесты стали "слишком умными",
   то наверняка из-за того, что таковым является тестируемый код. Попробуйте разделить код на более простые части и
   тестировать их поведение отдельно, напишите сначала модульные тесты на каждую маленькую часть, покрывая их отдельное поведение.
   Потом напишите код, который будет использовать эти маленькие части, и уже для него напишие один простой интеграционный тест,
   а в нем проверяйте ожидаемое поведение, не привязываясь к деталям и поведению маленьких частей кода, которыми он пользуется.

#### 2.1. Исключение для интерфейсного тестирования

При тестировании объектов, предоставляющих набор связанных атрибутов (см. "Интерфейсное тестирование" в глоссарии), несколько ожиданий в одном `it` с `:aggregate_failures` допустимы и предпочтительны, так как они представляют единое поведение: "объект предоставляет корректный интерфейс в заданном состоянии".

**Когда применимо интерфейсное тестирование:**
- Value objects с множественными атрибутами (Money, Address, Coordinate)
- Конфигурационные объекты (Settings, Config, Preferences)
- Read-only интерфейсы, построенные из единого источника данных
- Presenter/Decorator объекты, предоставляющие производные атрибуты

**Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, объедините их в один `it` с `:aggregate_failures`.

**Примеры хороших названий для интерфейсных тестов:**
- ✅ `'exposes product catalog interface'` — явно указывает на проверку интерфейса
- ✅ `'returns complete order summary'` — показывает, что проверяется полный набор данных
- ✅ `'builds user profile from session data'` — описывает источник и что строится
- ✅ `'provides shipping address details'` — чёткое описание предоставляемого интерфейса

**Избегайте:**
- ❌ `'works correctly'` — слишком общее, не описывает что проверяется
- ❌ `'returns correct values'` — не ясно, какие именно значения
- ❌ `'has valid attributes'` — расплывчато, не указывает на интерфейс

```ruby
# плохо: over-splitting интерфейса на отдельные тесты
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }

  it 'returns product name' do
    expect(presenter.display_name).to eq('Laptop')
  end

  it 'returns formatted price' do
    expect(presenter.formatted_price).to eq('$999.99')
  end

  it 'returns availability status' do
    expect(presenter.availability).to eq('In Stock')
  end

  it 'returns product identifier' do
    expect(presenter.sku).to eq('LPT-001')
  end
end
```

```ruby
# хорошо: интерфейсное тестирование с aggregate_failures
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }

  it 'exposes product display interface', :aggregate_failures do
    expect(presenter.display_name).to eq('Laptop')
    expect(presenter.formatted_price).to eq('$999.99')
    expect(presenter.availability).to eq('In Stock')
    expect(presenter.sku).to eq('LPT-001')
  end

  # Отдельные тесты для независимого поведения
  context 'when product is out of stock' do
    let(:product) { create(:product, stock: 0) }

    it 'indicates unavailability' do
      expect(presenter.availability).to eq('Out of Stock')
    end
  end
end
```

Что не так в плохом примере:
- Четыре отдельных теста проверяют части одного интерфейса, который presenter предоставляет на основе одного объекта `product`.
- При изменении источника данных (product) придётся обновлять все четыре теста, хотя они описывают единое поведение.
- Название каждого теста не передаёт, что все атрибуты связаны и формируют целостный интерфейс презентера.

Что даёт хороший пример:
- Один тест с `:aggregate_failures` явно показывает: "presenter предоставляет полный интерфейс отображения".
- Все атрибуты проверяются вместе, потому что они выводятся из одного источника и представляют единое поведение.
- Отдельный контекст для `out of stock` проверяет независимое поведение (изменение логики availability), а не просто другой атрибут.

**Важно:** Не путайте интерфейсное тестирование с проверкой независимых побочных эффектов. Если каждое ожидание описывает самостоятельное бизнес-правило (создание записи + отправка email), разделяйте их на отдельные `it` по основному правилу 2.

#### 2.2. Работа с большими интерфейсами

Когда объект предоставляет 10+ атрибутов, тест с множественными `expect` становится громоздким и сложным для поддержки. Используйте подходящие инструменты в зависимости от типа объекта.

**Для доменных объектов (value objects, presenters, config):**

Используйте `have_attributes` — это компактнее и читаемее, чем список отдельных `expect`.

```ruby
# плохо: длинный список expect
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile', :aggregate_failures do
    expect(profile.first_name).to eq('John')
    expect(profile.last_name).to eq('Doe')
    expect(profile.full_name).to eq('John Doe')
    expect(profile.email).to eq('john@example.com')
    expect(profile.phone).to eq('+1234567890')
    expect(profile.city).to eq('Springfield')
    expect(profile.country).to eq('USA')
    expect(profile.account_type).to eq('premium')
    expect(profile.verified).to be(true)
    expect(profile.created_at).to be_present
  end
end

# хорошо: компактно через have_attributes
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile' do
    expect(profile).to have_attributes(
      first_name: 'John',
      last_name: 'Doe',
      full_name: 'John Doe',
      email: 'john@example.com',
      phone: '+1234567890',
      city: 'Springfield',
      country: 'USA',
      account_type: 'premium',
      verified: true
    )
  end
end
```

**Преимущества `have_attributes`:**
- Компактная запись — вся проверка в одном месте
- Автоматический `:aggregate_failures` — показывает все несоответствия сразу
- Читаемый вывод при падении теста

**Для JSON API с большими вложенными структурами:**

Когда ответ API содержит десятки полей и вложенных объектов, проверка всей структуры inline становится нечитаемой. Используйте **декомпозицию через `let`** для управления сложностью.

```ruby
# плохо: вся структура в одном месте — сложно читать
describe 'GET /api/orders/:id' do
  it 'returns order with items and customer' do
    get "/api/orders/#{order.id}"
    
    expect(response.parsed_body).to eq({
      'id' => order.id,
      'status' => 'pending',
      'total' => 150.0,
      'customer' => {
        'id' => customer.id,
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'shipping_address' => {
          'street' => '123 Main St',
          'city' => 'Springfield',
          'postal_code' => '12345',
          'country' => 'USA'
        },
        'billing_address' => { ... }
      },
      'items' => [
        { 'id' => item1.id, 'product_name' => 'Laptop', ... },
        { 'id' => item2.id, 'product_name' => 'Mouse', ... }
      ],
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601
    })
  end
end
```

```ruby
# хорошо: декомпозиция через let — структура плоская и читаемая
describe 'GET /api/orders/:id' do
  let(:order) { create(:order, customer: customer) }
  let(:customer) { create(:customer) }
  let(:item1) { create(:order_item, order: order, product_name: 'Laptop', price: 999.99, quantity: 1) }
  let(:item2) { create(:order_item, order: order, product_name: 'Mouse', price: 25.0, quantity: 2) }

  # Вложенные структуры разнесены по отдельным let
  let(:expected_address) do
    {
      'street' => '123 Main St',
      'city' => 'Springfield',
      'postal_code' => '12345',
      'country' => 'USA'
    }
  end

  let(:expected_customer) do
    {
      'id' => customer.id,
      'name' => 'John Doe',
      'email' => 'john@example.com',
      'shipping_address' => expected_address,
      'billing_address' => expected_address
    }
  end

  let(:expected_items) do
    [
      {
        'id' => item1.id,
        'product_name' => 'Laptop',
        'quantity' => 1,
        'price' => 999.99,
        'subtotal' => 999.99
      },
      {
        'id' => item2.id,
        'product_name' => 'Mouse',
        'quantity' => 2,
        'price' => 25.0,
        'subtotal' => 50.0
      }
    ]
  end

  let(:expected_response) do
    {
      'id' => order.id,
      'status' => 'pending',
      'total' => 150.0,
      'customer' => expected_customer,
      'items' => expected_items,
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601
    }
  end

  it 'returns complete order details' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body).to match(expected_response)
  end
end
```

**Преимущества декомпозиции:**
- Вложенная структура становится плоской и читаемой
- Легко переиспользовать части (например, `expected_address`)
- При изменении структуры ясно, какой блок обновлять
- Сохраняется иерархия: `expected_response` → `expected_customer` → `expected_address`

**Когда использовать декомпозицию через `let`:**
- Проверяете **поведение** — ключевые поля, которые важны для бизнес-логики
- Структура средней сложности (5-20 полей с 2-3 уровнями вложенности)
- Нужна гибкость для динамических значений (`order.id`, `customer.email`)

**Когда НЕ использовать:**
- Проверяете **контракт API** — все поля, типы, обязательность, вложенность
- Структура огромная (50+ полей, глубокая вложенность)
- Важна полная фиксация схемы для внешних потребителей

**Для фиксации полной структуры API используйте специализированные инструменты:**
- **JSON Schema validation** (thoughtbot/json_matchers) — валидация структуры и типов
- **rspec-openapi** — автоматическая генерация OpenAPI из request specs
- **Snapshot testing** — фиксация эталонного ответа

Подробнее см. раздел ["Тестирование API-контрактов: границы применимости RSpec"](#тестирование-api-контрактов-границы-применимости-rspec).

### 3. Выделяйте характеристики поведения и их состояния

**Характеристика** — доменный аспект, который влияет на исход проверяемого поведения (роль пользователя, способ оплаты, статус заказа).

**Состояние характеристики** — конкретный вариант этой характеристики, который важен для правила (подписка активна, баланс меньше лимита, статус = shipped).

Как понять, что вы нашли характеристику:

- задайте вопрос: «если изменить этот аспект, ожидание примера изменится?»;
- характеристика описывает бизнес-факт, а не реализацию (`user has subscription`, а не `premium_flag`);
- характеристика формулируется как сущность с уточнением (`user role`, `card balance`).

Как подобрать состояния:

- перечислите все варианты, которые различает бизнес (роль = admin / customer; статус = draft / paid / cancelled);
- числовые величины группируйте в диапазоны, которые влияют на решение (баланс ≥ стоимость, баланс < стоимость);
- каждое состояние выражайте отдельным `context` с ясной формулировкой.

### 4. Стройте иерархию `context` по зависимостям характеристик (happy path → corner cases)

Характеристики могут быть:

- **базовыми** — без них остальные не имеют смысла (нет карты → нет баланса);
- **уточняющими** — уточняют базовую характеристику (баланс карты при наличии карты);
- **независимыми** — не влияют друг на друга (роль пользователя и флаг beta-теста).

Алгоритм:

1. Выпишите характеристики и состояния.
2. Отметьте зависимости: характеристика B зависит от A, если её состояние осмысленно только при конкретном состоянии A.
3. Постройте таблицу иерархии.
4. Для каждой ветки создайте вложенные `context` от базовой к уточняющей, упорядочив состояния: сначала happy path (нормальный сценарий), затем corner cases (отклонения).

#### Зависимые характеристики (бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Привязка карты | has card / has NO card | — |
| Баланс карты | balance ≥ price / balance < price | Привязка карты (has card) |

```ruby
describe '#purchase' do
  context 'when user has a payment card' do               # happy path: карта привязана
    context 'and card balance covers the price' do        # happy path: баланс достаточен
      it 'charges the card'
    end

    context 'but card balance does NOT cover the price' do # corner case: денег не хватило
      it 'rejects the purchase'
    end
  end

  context 'when user has NO payment card' do              # corner case: карты нет
    it 'rejects the purchase'
  end
end
```

> ```ruby
> # плохо
> describe '#purchase' do
>   context 'but card balance does NOT cover the price' do
>     it 'rejects the purchase'
>   end
>
>   context 'when user has a payment card' do
>     context 'and card balance covers the price' do
>       it 'charges the card'
>     end
>   end
> end
> ```
>
> Что не так:
>
> - Ветка `but ...` оторвана от базового `when user has a payment card`, поэтому happy path и corner case меняются местами.
> - Читателю приходится держать в голове зависимость, которую раньше показывала вложенность: спецификацию становится трудно читать.

#### Независимые характеристики (enum + бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Роль пользователя | admin / customer | — |
| Флаг beta-доступа | enabled / disabled | — |

```ruby
describe '#feature_access' do
  context 'when user role is admin' do        # happy path: полный доступ
    it 'grants access to admin tools'

    context 'and beta feature is enabled' do  # happy path: бонусный доступ
      it 'grants access to beta tools'
    end

    context 'but beta feature is disabled' do # corner case для admin
      it 'falls back to standard tools'
    end
  end

  context 'when user role is customer' do     # corner case: ограниченные права
    it 'denies access to admin tools'

    context 'and beta feature is enabled' do  # corner case: частичное смягчение
      it 'grants access to beta tools'
    end

    context 'but beta feature is disabled' do # самый строгий corner case
      it 'denies access to beta tools'
    end
  end
end
```

Порядок независимых характеристик можно менять (сначала флаг, потом роль), но happy path должен оставаться выше, а отклонения — группироваться ниже на соответствующем уровне вложенности.

### 5. Финальный аудит контекстов: дубликаты `let`/`before` выдают пропущенные состояния

Каждый раз, как вы закончили работу над тестами, убедитесь, что структура `describe/context` реально соответствует характеристикам и их состояниям из [глоссария](#глоссарий) (см. пункт 4). Повторяющиеся `let` или `before` на одном уровне — тревожный сигнал: какое-то состояние не вынесено в явный контекст, и тест для него легко потерять.

Чек-лист после написания:

- Пройдитесь по каждому уровню вложенности и выпишите все `let`/`before`. Если в соседних ветках повторяются одинаковые значения, характеристику нужно поднять выше или вынести в отдельный контекст.
- Попробуйте поднять общий `let` на уровень выше. Если тесты после этого рушатся, значит, вы обнаружили скрытое состояние — добавьте для него контекст и пример.
- Сверьте структуру с первоначальным списком характеристик и их состояний. Если какое-то состояние нигде не проявилось, сценарий для него пропущен.
- Посмотрите на `before`-блоки. Повторяющаяся подготовка данных — частый признак того, что вы оставили только happy path и забыли про ветку с альтернативным контекстом.

```ruby
# плохо
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :usd }

      it 'returns 0.15' do
        expect(discount).to eq(0.15)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :usd }

      it 'returns 0.10' do
        expect(discount).to eq(0.10)
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :eur }

      it 'returns 0.12' do
        expect(discount).to eq(0.12)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :eur }

      it 'returns 0.05' do
        expect(discount).to eq(0.05)
      end
    end
  end
end
```

```ruby
# хорошо
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }

        it 'returns 0.15' do
          expect(discount).to eq(0.15)
        end
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }

        it 'returns 0.10' do
          expect(discount).to eq(0.10)
        end
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }

        it 'returns 0.11' do
          expect(discount).to eq(0.11)
        end
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }

        it 'returns 0.06' do
          expect(discount).to eq(0.06)
        end
      end
    end

    context 'with EUR currency' do
      let(:currency) { :eur }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }

        it 'returns 0.12' do
          expect(discount).to eq(0.12)
        end
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }

        it 'returns 0.05' do
          expect(discount).to eq(0.05)
        end
      end
    end
  end
end
```

`Что` не так в плохом примере:

- По описанию всё похоже на правильную иерархию из пункта 4, но `currency` в каждой ветке задаётся вручную, значит, характеристика фактически «живёт» не там, где описана.
- Для состояния `currency: :usd` в сегменте `:b2b` пример отсутствует — дефект пройдёт мимо, потому что тесты читаются как полная спецификация.

Теперь:

- Валюта занимает своё место в иерархии, дубликаты `let` исчезли, и структура повторяет реальные зависимости характеристик (см. пункт 4).
- Каждая комбинация `segment → currency → loyalty_status` из предметной модели имеет пример, а отдельный corner case фиксирует негативное поведение.
- Формулировки контекстов складываются в читаемые предложения, и happy path стоит выше corner case (см. пункт 6), поэтому сценарии считываются быстро.
- При появлении нового состояния чек-лист сработает автоматически: вы либо добавите контекст, либо заметите, что возврат к общему `let` ломает тест.

Такой финальный проход заставляет держать тесты на уровне поведенческого контракта, а не набора случайных happy path.

### 6. Располагайте happy path перед corner cases

Внутри каждого `describe` читающий ожидает увидеть нормальное поведение первым, а уже затем — исключения. Такой порядок снижает когнитивную нагрузку: мы быстро убеждаемся, что система делает «как надо», и только потом разбираем, что происходит, когда что-то идет не так.

```ruby
# плохо
describe '#enroll' do
  context 'when enrollment is rejected because email is invalid' do
    it 'shows a validation error'
  end

  context 'when enrollment is rejected because plan is sold out' do
    it 'puts the user on the waitlist'
  end

  context 'when enrollment is accepted' do # happy path затерян внизу
    it 'activates the membership'
  end
end
```

```ruby
# хорошо
describe '#enroll' do
  context 'when enrollment is accepted' do
    it 'activates the membership'
  end

  context 'when enrollment is rejected because email is invalid' do
    it 'shows a validation error'
  end

  context 'when enrollment is rejected because plan is sold out' do
    it 'puts the user on the waitlist'
  end
end
```

Что не так в плохом примере:

- Happy path спрятан внизу ветки, из-за чего читатель тратит больше времени, чтобы понять нормальное поведение.
- При появлении новых corner cases порядок ещё сильнее смешается, и отчет RSpec перестанет читаться сверху вниз.

Инструкция: добавляя новые примеры, проверьте, что блоки happy path остаются первыми на своем уровне вложенности. Corner cases должны находиться ниже и либо начинаться с `but`/`without`, либо явно описывать отклонение.

### 7. Пишите положительный и отрицательный тест

Каждая ветка контекстов описывает конкретное сочетание состояний характеристик. Для этих сочетаний нужен минимум один пример, подтверждающий поведение, и один пример, показывающий отказ — так мы защищаемся от регрессий в обе стороны.

```ruby
# плохо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }

  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния `blocked = true`
    let(:blocked) { true }

    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... настройка уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to be(true) # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  
  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { true }

    # Контекст 2 уровня для состояния характеристики `blocked_at`
    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to be(true) # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end

    context "but blocking duration is under a month" do # отрицательный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 1.month.ago }

      it "does NOT allow unlocking the user" do
        expect(some_action).to be(false) # отрицательный тест для состояния характеристики `blocked_at`
      end
    end
  end

  context "when user is NOT blocked by admin" do # отрицательный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { false }

    it "does NOT allow unlocking the user" do
      expect(some_action).to be(false) # отрицательный тест для состояния характеристики `blocked_at`
    end
  end
end
```

Что не так в плохом примере:

- Характеристика `blocked` проверяется только на положительном состоянии — защита от обратного сценария отсутствует.
- Уточняющий контекст не показывает альтернативное состояние `blocked_at`, поэтому пропущен отрицательный тест для сочетания состояний.
Если присутствуют только положительные тесты, то в дальнейшем на такие тесты нельзя полагаться,
ввиду того, что они не отразят факта регрессии поведения при дальнейших изменениях в коде,
так как они не будут проверять обратный случай.

### 8. Каждый контекст должен отражать различие вложенной части от внешней

Можно ещё сказать так: если у вас есть контекст, внутри которого между `context "..." do` и `it` пусто, это чисто
синтаксический контекст. Он либо не нужен вовсе, либо не содержит настройки, соответствующей описанию контекста.

Правило можно сформулировать иначе: настройка, которая делает контекст истинным, должна находиться сразу после строки `context "..." do`.
Не заставляйте читателя искать по всему тесту, где именно готовится контекст под описанное состояние.

```ruby
# Есть пользователи и метод some_action, позволяющий определить, можно ли пользователя разблокировать.
# У пользователей есть состояния `blocked`, `blocked_at`.
```

```ruby
# очень плохо
describe "#some_action" do
  let(:user) { build :user }
  let(:blocked_user) { build :user, blocked: true }
  let(:old_blocked_user) { build :user, blocked: true, blocked_at: 2.month.ago }

  it "does NOT allow unlocking the user" do
    expect(user.some_action).to be(false)
  end
  
  context "when user is blocked by admin" do # есть контекст
    # нет никакой настройки, которая делает его отличным от внешнего блока
    it "allows unlocking the user" do
      expect(blocked_user.some_action).to be(true)
    end
    
    context "and blocking duration is over a month" do 
      # Что отличает этот контекст от внешнего? В большом тесте искать настройку будет невозможно.
      # Экономьте свой и чужой труд — размещайте блок, который готовит контекст, сразу под объявлением: там его и ожидают увидеть.
      it "allows unlocking the user" do
        expect(old_blocked_user.some_action).to be(true)
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  let(:blocked) { false } # базовое состояние характеристики `blocked`
  let(:blocked_at) { nil } # базовое состояние характеристики `blocked_at`
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  subject(:result) { user.some_action }

  it "does NOT allow unlocking the user" do
    expect(result).to be(false)
  end

  context "when user is blocked by admin" do
    let(:blocked) { true } # настройка этого контекста — на своём месте, сразу заметна

    context "and blocking duration is over a month" do
      let(:blocked_at) { 2.month.ago } # настройка вложенного контекста — здесь же, под объявлением

      it "allows unlocking the user" do
        expect(result).to be(true)
      end
    end

    context "but blocking duration is under a month" do
      let(:blocked_at) { 1.month.ago } # отрицательное состояние характеристики `blocked_at`

      it "does NOT allow unlocking the user" do
        expect(result).to be(false)
      end
    end
  end
end
```

Что не так в плохом примере:

- Контекст `when user is blocked by admin` не задаёт отличающих условий — настройка `let` находится далеко и не читается вместе с описанием.
- Внутренний `context` не подготавливает `blocked_at`, поэтому сложно понять, какое состояние характеристики проверяется.

Кроме того, требуемое состояние может задаваться вычислением — например, располагаться внутри `before`.

### 9. Каждый тест должен быть разделен на 3 этапа в строгой последовательности
`let` и `let!` подготавливают данные, которые делают контекст истинным (Given), `before` доводит систему до нужного состояния или вызывает действие (When), а ожидания внутри `it` фиксируют результат (Then). Не смешивайте эти роли.

1. Подготовка данных для контекста (обычно через `let` или фабрики)
2. Перевод данных в нужное состояние/вызов действия (чаще `before`, иногда прямо в `it`)
3. Ожидание результата (Then)

```ruby
# очень плохо
describe "#block" do
  before do
    user = create :user # тестовые данные
    admin = create :admin # тестовые данные
    admin.block(user) # действие
  end

  it "true" do
    expect(User.find(1).bloсked).to be(true) # ожидание
  end
end
```

```ruby
# хорошо
describe "#block" do
  # 1 этап
  let(:user) { create :user } # создание тестовых данных
  let(:admin) { create :admin }

  # 2 этап
  before { admin.block(user) } # действие/операция

  # 3 этап
  it "marks the user as blocked" do
    expect(user.blocked).to be(true) # ожидание
  end
end
```

Вариант с действием внутри примера:

```ruby
# нормально
describe "#block" do
  # 1 этап
  let(:user) { create :user }
  let(:admin) { create :admin }

  it "marks the user as blocked" do
    # 2 этап
    admin.block(user)

    # 3 этап
    expect(user.blocked).to be(true)
  end
end
```

Что не так в плохом примере:

- Этапы Given/When/Then смешаны внутри `before`, из-за чего непонятно, где заканчивается подготовка и начинается проверка.
- Тест обращается к `User.find(1)` вместо подготовки контекста через `let`, поэтому пример зависит от глобального состояния.

Даже если действие выполняется прямо в `it`, держите структуру явной и возвращайте вычисления в `before`, когда это возможно.

- `let` ленивый: значение вычисляется при первом обращении. Если состояние контекста должно появиться до выполнения `it`, используйте `before` или `let!`, чтобы явно зафиксировать порядок и не нарушать этапы правила 8.

### 10. Используйте возможности FactoryBot для скрытия деталей исходных данных

Если в проекте есть FactoryBot, используйте его, чтобы тесты оставались читабельными и фиксировали только характеристики и их состояния (см. глоссарий).

- Дефолтная фабрика должна создавать «средний» объект, который подходит для happy path. Всё, что не участвует в описании контекста, прячьте внутрь фабрики.
- В повторяющихся сценариях оформляйте состояния через трейты: `:blocked`, `:with_verified_email`, `:expired`. Трейты можно свободно комбинировать (`create(:user, :blocked, :verified)`), получая нужные состояния без копипаста. Контексту не нужно перечислять вспомогательные поля, достаточно упомянуть характеристику.
- Избегайте ручной передачи десятков атрибутов в `create`. Если требуется много явных значений, возможно, фабрику стоит уточнить или выделить новую характеристику.

```ruby
# плохо
describe '#unlock' do
  let(:user) do
    create(:user,
           blocked: true,
           blocked_at: 2.months.ago,
           email_confirmed: true,
           last_sign_in_at: 1.day.ago,
           otp_required: false)
  end

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

```ruby
# хорошо
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { 'secret123' }

    trait :blocked do
      blocked { true }
      blocked_at { 2.months.ago }
    end

    trait :verified do
      email_confirmed { true }
    end
  end
end

describe '#unlock' do
  let(:user) { create(:user, :blocked, :verified) }

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

- Трейты документируют состояния характеристик и избавляют от громоздких setup-блоков.
- Читатель видит только важные аспекты (`:blocked`, `:verified`) и быстро соотносит их с описанием контекста.
- Изменения дефолтных атрибутов происходят в фабрике, поэтому тесты не «захламляются» техническими деталями данных.
- Что не так в плохом примере: фабрика используется как `create` со всеми атрибутами, поэтому тест не показывает, какие состояния важны; любое изменение вспомогательных полей требует менять тест, а не фабрику.

Такая дисциплина делает тесты чище, легче для поддержки и лучше подчёркивает бизнес-поведение.

Дополнительно: хороший обзор приёмов работы с трейтами есть у Thoughtbot — [Remove duplication with FactoryBot’s traits](https://thoughtbot.com/blog/remove-duplication-with-factorybots-traits).

### 11. В юнит-тестах (кроме моделей) используйте `build_stubbed`

Юнит-спеки сервисов, политик, presenter'ов и form-объектов не должны зависеть от базы данных. `build_stubbed` создаёт объект ActiveRecord без `INSERT`/`UPDATE`, но с заполненными `id`, `created_at`, `updated_at` и запретом на `save`. Это делает тесты быстрее и подчёркивает, что код работает с готовым контекстом, а не строит интеграцию с БД.

- `build_stubbed` избавляет от лишних раунд-трипов к БД и ускоряет пакет модульных тестов.
- Объект невозможно случайно сохранить: если код пытается вызвать `save`/`reload`, тест упадёт и покажет, что вы пересекаете границу уровня (значит, нужен интеграционный тест).
- Stubbed-экземпляры удобнее подменять в doubles: у них есть `id`, предзаполненные атрибуты и отключены callbacks, поэтому тест остаётся предсказуемым.

Когда `build_stubbed` использовать не стоит:

- тест модели или скоупа, где нужно проверить реальное взаимодействие с БД;
- код, который опирается на callbacks/триггеры или читает изменения после `save`;
- фича, где валидация/уникальность/foreign key проверяются именно БД (тогда используйте `create`).

```ruby
# плохо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { create(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  it 'schedules confirmation email' do
    allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer)

    expect { call }.not_to change(Order, :count)
    expect(mailer).to have_received(:deliver_later)
  end
end
```

```ruby
# хорошо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { build_stubbed(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  before do
    allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer)
  end

  it 'schedules confirmation email' do
    call

    expect(mailer).to have_received(:deliver_later)
  end
end
```

Что не так в плохом примере:

- `create` выполняет запись в базу ради данных, которыми сервис только пользуется; тесты замедляются без необходимости.
- Если реализация вызовет `save`/`reload`, тест этого не увидит, потому что объект уже живёт в БД — мы незаметно проверяем интеграционный сценарий.

Что даёт хороший пример:

- `build_stubbed` создаёт полноценный объект без обращения к БД, поэтому юнит-спеки бегут быстрее и остаются изолированными.
- Попытка сохранить объект из тестируемого кода завершится ошибкой, сигнализируя, что сценарий перешёл границу уровня и нужен интеграционный тест.

Если тест неожиданно требует `save` или чтения из базы, значит, вы тестируете поведение более высокого уровня — перенесите пример в интеграционный слой или поменяйте стратегию подготовки данных.

### 12. Не программируйте в тестах

Тест — это спецификация поведения, а не место для написания мини-фреймворков. Когда вместо декларативных `let`, фабрик и helper-методов появляются приватные утилиты с прямой работой с БД, тест перестаёт быть читаемым и надёжным.

```ruby
# ужасно
describe SomeService do
  it 'stores report' do
    result = described_class.call(raw_payload)

    expect(result).to be_success
    expect(find_report(result.id)).to have_attributes(status: 'done', rows: 3)
  end

  private

  def raw_payload
    DB[:reports].insert(name: 'daily', data: '{"rows":[1,2,3]}')
    DB[:reports].where(name: 'daily').first
  end

  def find_report(id)
    DB[:reports].where(id: id).first
  end
end
```

```ruby
# хорошо
describe SomeService do
  let(:report) { create(:report, :daily, :with_rows) }
  subject(:result) { described_class.call(report.payload) }

  it 'stores report' do
    expect(result).to be_success
    expect(report.reload).to have_attributes(status: 'done', rows_count: 3)
  end
end
```

Что не так в плохом примере:

- Приватные методы скрывают, как задаются состояния: читателю нужно «выполнить» код в голове, чтобы понять характеристики.
- Прямая работа с БД минует фабрики/фикстуры и создаёт жёсткую привязку к схеме.
- При изменении структуры таблиц тесты ломаются молча или дают нечитаемые ошибки.
- Если подобный стиль кажется удобным, это тревожный сигнал: такая запись тяготеет к assert-style-DSL вроде minitest. В RSpec же мы описываем поведение, а не переписываем код тестового фреймворка.

Что даёт хороший пример:

- `let` с фабрикой явно описывает характеристику (`report` со статусом и данными), а не SQL-обходные пути.
- При смене схемы адаптируем фабрику — тесты остаются декларативными и следуют глоссарию характеристик.

Это правило тесно связано с пунктами 1, 7 и 8: мы описываем поведение, проверяем обе стороны правила и держим подготовку контекста рядом с его описанием.

## Язык описания спецификаций

### 13. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны составлять валидное предложение на английском языке.


Описание спецификаций (`describe`/`context`/`it`) пишите по-английски: так отчёты RSpec остаются читаемыми в CI, а команда использует единый язык описания поведения.
Для примера оставим только описание тестов, без примера создания тестовых данных и изменений в контекстах.

```ruby
# отвратительно
describe "#some_action" do
  context "blocked" do # что заблокировано, когда, кем? что это вообще значит?
    context "month ago" do # месяц назад что? заблокирован? точно?
      it("true") { test } # что значит true? как оно оценивается?
    end
  end
end
# когда вы запустите тест он вернет вот такое непонятное описание
# #some_action user blocked month ago /it/ true

# идеально
describe "#some_action" do
  context "when user is blocked by admin" do # здесь понятно, кто, что и с кем сделал
    context "and blocking duration is over a month" do # а здесь уже понятно что это продолжение предложения, начатого в прошлом контексте
      it("allows unlocking the user") { test } # ага, теперь вообще понятно, зачем этот метод нужен, в чем его ценность
      # он определяет "можно ли разблокировать пользователя?"
    end
  end
end
# #some_action when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user 
```

Что не так в плохом примере:

- Контексты не складываются в цельное предложение: непонятно, кто заблокирован и что означает `month ago`.
- Описание `it("true")` не рассказывает о поведении, поэтому отчёт RSpec не несёт смысла.

### 14. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны быть написаны так, чтобы их понимал любой человек

Здесь имеется ввиду, что описание поведения должно быть абсолютно однозначно понятным и не требующим познания чего-то специфичного из программирования.
Вы должны быть в состоянии просто дать все описания тестов любому человеку, для того чтобы он в свою очередь прочитав их мог понять бизнес.

```
when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user
when user is blocked by admin but blocking duration is under a month /it/ does NOT allow unlocking the user
```
вполне понятное описание, по которому однозначно понятно, что разблокировать пользователя заблокированного менее месяца назад нельзя.

### 15. Грамматика формулировок в describe/context/it

Мы описываем устойчивое поведение системы, поэтому формулировки должны звучать как правила предметной области, а не как инструкции тестировщику.

1. **Present Simple.** Поведение считается верным всегда, поэтому говорим о нем в настоящем времени: `it 'returns the summary'`. Настоящее простое время делает фразу универсальной и убирает ощущение временности.
2. **Активный залог в `it`, третье лицо.** Субъектом предложения выступает объект системы: `order generates invoice`, `service authenticates user`. Так читающий понимает, кто выполняет действие, и предложение остается коротким.
3. **Пассивный залог и глаголы-состояния для контекстов.** Контекст задает состояние характеристики, поэтому используем форму `is/are + V3` или короткие конструкции со статичным глаголом: `when user is blocked`, `when account has balance`. Так мы фиксируем факт состояния, а не действие, которое к нему привело.
4. **Zero conditional для связки контекста и результата.** В паре `context/it` обе части остаются в Present Simple: `when payment is confirmed, it issues receipt`. Такая структура читается как бизнес-правило «если … то …» без временных сдвигов.
5. **Без модальных глаголов и лишних слов.** Избегаем `should`, `can`, `must` и вводных конструкций (`it should`, `it is expected that`). Остается декларация поведения — она короче и лучше ложится в отчеты.
6. **Явное отрицание `NOT`.** Негативные сценарии выделяем капсом: в контекстах — `when user is NOT verified`, в примерах — `it 'does NOT unlock user'`. Так в отчете сразу видно, что падает отрицательный кейс.

Минимальный шаблон: объект и характеристику описываем в `describe`, контекст — через `context` в пассивном залоге, ожидаемую реакцию — через `it` в активном Present Simple.

```ruby
describe OrderMailer do
  context 'when invoice is generated' do
    it 'sends the invoice email'
  end
end
```

### 16. Язык контекстов: when / with / and / without / but / NOT

Следуем логике Gherkin, чтобы ветка читалась как последовательность уточнений контекста. Каждая связка отвечает типу состояния и уровню вложенности.

- **`when …`** — открывает ветку и описывает состояние базовой характеристики. На этом уровне часто нет `it`, потому что дальше ветка уточняется. Пример: `context 'when user has a payment card' do … end`.
- **`with …`** — вводит первое уточняющее положительное состояние и продолжает happy path: `context 'with verified email'`.
- **`and …`** — добавляет ещё одно положительное состояние в том же направлении. Можно использовать несколько подряд, пока ветка остаётся частью happy path: `context 'and balance covers the price'`.
- **`without …`** — используем для бинарных характеристик, когда явно показываем обе полярности. Happy path описан положительным состоянием, поэтому ветка `without …` сразу содержит тест, демонстрирующий альтернативный исход: `context 'without verified email' do … end`.
- **`but …`** — подчёркивает противопоставление happy path. Часто применяется, когда happy path основан на состоянии по умолчанию (отдельный `with`-контекст не нужен). Контекст `but …` обязан содержать тест, показывающий, как меняется поведение, когда базовый контекст перестаёт выполняться: `context 'but balance does NOT cover the price'`.
- **`NOT`** — используем капсом внутри названия контекста или `it`, чтобы подчеркнуть отрицательное состояние бинарной характеристики либо выделить отрицательный тест: `context 'when user does NOT have a payment card'`, `it 'does NOT charge the card'`.
- Если в описании `it` появляется `when`/`with`/`and`/`without`/`but`, значит, вы потеряли соответствующий контекст. Вынесите это состояние в `context`, иначе пример будет смешивать Given и Then и нарушит правила 1–7. Исключение — отрицательные формулировки с `does NOT`, где `NOT` подчёркивает результат, а не контекст.

Рекомендуемая последовательность внутри ветки: `when` → `with` → `and` (по необходимости) → `but`/`without` → `it`. Как только контекст полностью подготовлен, добавляем пример: happy path или corner case.

```ruby
describe '#charge' do
  context 'when user has a payment card' do                      # базовая характеристика
    context 'with verified email' do                            # happy path уточнение
      context 'and balance covers the price' do                 # ещё одно happy path состояние
        it 'charges the card'                                   # happy path case
      end

      context 'but balance does NOT cover the price' do         # corner case: противопоставление
        it 'does NOT charge the card'                           # отрицательный тест
      end
    end

    context 'without verified email' do                         # corner case: отсутствие обязательного состояния
      it 'does NOT charge the card'
    end
  end

  context 'when user does NOT have a payment card' do           # другая ветка для бинарной характеристики
    it 'does NOT charge the card'
  end
end
```

Следите, чтобы happy path ветка шла первой на своём уровне, а контексты с `without`/`but` логически ссылались на неё: «когда всё хорошо → что происходит; но если базовый контекст ломается → как меняется результат».

Иногда happy path строится на значении по умолчанию, и дополнительный `with`-контекст не нужен — пример можно разместить сразу под `when`. Corner case всё так же раскрывается через `but` или `without` на том же уровне.

```ruby
describe '#authenticate' do
  context 'when account exists' do                        # базовая ветка
    it 'signs the user in'                                # happy path сразу под when

    context 'but account is blocked' do                   # corner case на том же уровне
      it 'denies the sign-in'
    end
  end

  context 'when account does NOT exist' do                # противопоставление на уровне контекста
    it 'denies the sign-in'
  end
end
```

### 17. Изучите подробно правила из rubocop по части наименования https://rspec.rubystyle.guide/#naming

## Инструменты и поддержка тестов

### 18. Не используйте [any_instance](https://rspec.info/features/3-13/rspec-mocks/old-syntax/any-instance/), allow_any_instance_of, expect_any_instance_of

В большинстве случаев это "запах" к тому, что вы не следуете `dependency inversion principle`,
или, что ваш класс не следует `single responsibility` и объединяет в себе код для двух акторов,
которые в свою очередь зависят друг от друга в одностороннем порядке.
Таким образом, ваш класс можно разбить на два класса поменьше, для которых в свою очередь можно покрыть тестами их поведение в отдельных тестах.
Справедливости ради, следовать этому правилу не очень просто тогда, когда у вас накопился гигантский технический долг, поэтому это правило может иметь исключения.

Подробнее о том, почему его не стоит использовать, читайте здесь https://rspec.info/features/3-13/rspec-mocks/working-with-legacy-code/any-instance/.

```ruby
# плохо
class HighLevelClass
   def some_method
      data = LowLevelClass.foo

      data.uniq.select { some code }.map { some code }
   end
end

describe HighLevelClass do
   let(:some_data) { build :some_data }

   before do
      allow_any_instance_of(LowLevelClass).to receive(:foo).and_return({some_key: :some_value})
   end

   it "returns the processed value" do
      expect(HighLevelClass.new.some_method).to eq(:some_expected_value)
   end
end

# хорошо
class HighLevelClass
   def initialize(low_level_dependency = LowLevelClass)
      @low_level_dependency = low_level_dependency # Произвели инверсию зависимости
   end

   def some_method
      data = low_level_dependency.foo

      data.uniq.select { some code }.map { some code }
   end
end

describe HighLevelClass do
   let(:some_data) { build :some_data }
   let(:low_level_dependency) { instance_double(LowLevelClass) }
   let(:instanse) { HighLevelClass.new(low_level_dependency) } # теперь зависимость можно просто подставить через new

   before do
      allow(low_level_dependency).to receive(:foo).and_return({some_key: :some_value})
      # теперь мы просто разрешаем вернуть нужное нам значение одному instance double,
      # причем будет проверка что такой метод действительно есть у данного класса.
      # таким образом при рефакторинге интерфейса класса, данный тест может предупредить сломанную зависимость других классов
   end

   it "returns the processed value" do
      expect(instanse.some_method).to eq(:some_expected_value)
   end
end
```

Что не так в плохом примере:

- `allow_any_instance_of` глобально подменяет метод `foo` и затрагивает все экземпляры класса, из-за чего тест перестает быть изолированным.
- Класс не принимает зависимость явно, поэтому приходится пробивать мок через глобальную настройку, вместо того чтобы внедрить ее через конструктор.

### 19. Используйте `:aggregate_failures` только когда описываете одно правило

По умолчанию один `it` содержит одну проверку. `:aggregate_failures` полезен, когда мы говорим об одном поведении и хотим увидеть все нарушения сразу, вместо того чтобы фиксировать только первое упавшее ожидание.

**Ключевой принцип:** Используйте `:aggregate_failures` только если все ожидания описывают один и тот же бизнес-исход и зависят от одного набора подготовленных состояний контекста. Не применяйте флаг, чтобы спрятать разные поведения в одном `it` — так вы нарушаете правило 2.

#### Когда использовать `:aggregate_failures`

✅ **ИСПОЛЬЗУЙТЕ когда:**

1. **Проверяете атрибуты одного созданного/полученного объекта** — атрибуты выводятся из одного источника и формируют целостный интерфейс (см. правило 2.1 "Интерфейсное тестирование"):
   ```ruby
   it 'exposes user profile attributes', :aggregate_failures do
     expect(profile.full_name).to eq('John Doe')
     expect(profile.email).to eq('john@example.com')
     expect(profile.account_type).to eq('premium')
   end
   ```

2. **Тестируете интерфейс/контракт объекта в заданном состоянии** — все проверки относятся к единому представлению:
   ```ruby
   it 'provides shipping address details', :aggregate_failures do
     expect(address.street).to eq('123 Main St')
     expect(address.city).to eq('Springfield')
     expect(address.postal_code).to eq('12345')
     expect(address.country).to eq('USA')
   end
   ```

3. **Проверяете структуру HTTP-ответа** — статус, заголовки и основные поля тела ответа как единый контракт:
   ```ruby
   it 'returns successful response with order data', :aggregate_failures do
     post '/orders', params: order_params
     expect(response).to have_http_status(:created)
     expect(response.content_type).to match(/json/)
     expect(response.parsed_body).to include('id', 'status', 'total')
   end
   ```

4. **Проверяете связанные значения, выведенные из одного источника** — вычисляемые или производные атрибуты:
   ```ruby
   it 'calculates order totals correctly', :aggregate_failures do
     expect(order.subtotal).to eq(100.0)
     expect(order.tax).to eq(8.0)
     expect(order.total).to eq(108.0)
   end
   ```

❌ **НЕ ИСПОЛЬЗУЙТЕ когда:**

1. **Тестируете разные поведения** — каждое действие вызывает независимый бизнес-эффект:
   ```ruby
   # плохо: два независимых поведения
   it 'creates order and sends confirmation', :aggregate_failures do
     expect { place_order }.to change(Order, :count).by(1)
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   
   # хорошо: разделены на отдельные тесты
   it 'creates an order' do
     expect { place_order }.to change(Order, :count).by(1)
   end
   
   it 'enqueues confirmation email' do
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   ```

2. **Проверяете независимые побочные эффекты** — эффекты не связаны общим источником:
   ```ruby
   # плохо: независимые эффекты
   it 'processes payment and updates inventory', :aggregate_failures do
     expect { process }.to change(Payment, :count)
     expect { process }.to change { product.reload.stock }.by(-1)
   end
   ```

3. **Тестируете разных акторов** — каждый актор представляет отдельное правило:
   ```ruby
   # плохо: два актора с разной логикой
   it 'hides notifications', :aggregate_failures do
     expect(admin_notifications).to be_hidden
     expect(user_notifications).not_to be_hidden
   end
   
   # хорошо: отдельные контексты для каждого актора
   context 'for admin' do
     it 'hides admin notifications' do
       expect(admin_notifications).to be_hidden
     end
   end
   
   context 'for regular user' do
     it 'does NOT hide user notifications' do
       expect(user_notifications).not_to be_hidden
     end
   end
   ```

4. **Можете описать ожидания как отдельные поведения на простом языке** — если каждая проверка звучит как самостоятельное правило, разделяйте их:
   ```ruby
   # плохо: каждое ожидание — отдельное правило
   it 'handles checkout', :aggregate_failures do
     expect(cart).to be_empty           # "очищает корзину"
     expect(order).to be_paid           # "помечает заказ оплаченным"
     expect(customer.balance).to eq(0)  # "списывает баланс"
   end
   ```

#### Дополнительные рекомендации

- **Держите описание конкретным:** Даже с флагом название `it` должно чётко указывать, что проверяется. Избегайте общих формулировок (`'works correctly'`, `'returns data'`).
- **Ограничивайте количество ожиданий:** Если в тесте больше 10-15 ожиданий, возможно вы проверяете слишком много — подумайте о разбиении на несколько тестов или вынесении части логики.
- **Подготовка контекста не оправдывает смешивание поведений:** Даже если setup дорогой, правильнее оптимизировать фабрики или вынести общий контекст в `before`, чем прятать независимые правила в одном `it`.

### Руководство по принятию решения: один `it` или несколько?

Когда непонятно, объединять проверки в один тест или разделять на несколько, используйте эти контрольные вопросы:

#### 1. "Можно ли описать эти проверки одним предложением для нетехнического человека?"

**Если НЕТ** (требуются разные предложения) → Разделяйте на отдельные `it`.

Пример: "Система создаёт заказ" и "система отправляет подтверждение" — нужны два предложения, это два разных действия с точки зрения бизнеса.

**Если ДА** (одно предложение описывает всё) → Рассмотрите один `it` с `:aggregate_failures`.

Пример: "Профиль пользователя содержит имя, email и тип аккаунта" — одно предложение описывает единое представление данных профиля.

#### 2. "Тестирует ли каждое ожидание независимый путь выполнения кода?"

**Если ДА** → Разделяйте на отдельные `it`.

Пример: Проверка создания записи (`expect { ... }.to change(Order, :count)`) и проверка отправки email (`expect { ... }.to have_enqueued_job`) выполняют разные ветки логики.

**Если НЕТ** → Один `it` с `:aggregate_failures`.

Пример: Все атрибуты презентера вычисляются из одного объекта `product` — нет ветвления, только трансформация данных.

#### 3. "Проверяю ли я разные части публичного интерфейса?"

**Если ДА, разные части** → Разделяйте на отдельные `it`.

Пример: `#create_order` и `#send_confirmation` — это разные методы, каждый из которых представляет отдельное поведение.

**Если НЕТ, один интерфейс** → Один `it` с `:aggregate_failures`.

Пример: Все проверки относятся к атрибутам одного метода `#summary` — это единый интерфейс объекта в заданном состоянии.

#### Примеры применения

```ruby
# Вопрос 1: Можно ли описать это одним предложением?
# "Создаёт заказ" + "Отправляет email"
# → НЕТ, нужны два разных предложения → Разделяем

# ❌ Не делайте так:
it 'processes order', :aggregate_failures do
  expect { place_order }.to change(Order, :count).by(1)
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end

# ✅ Разделяем на отдельные поведения:
it 'creates an order' do
  expect { place_order }.to change(Order, :count).by(1)
end

it 'enqueues confirmation email' do
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end

# ✅ Но если это интерфейс:
# "Продукт предоставляет свой каталожный интерфейс (имя + цена + наличие)"
# → ДА, одно предложение описывает всё → Объединяем
it 'exposes catalog interface', :aggregate_failures do
  expect(product.name).to eq('Laptop')
  expect(product.price).to eq(999.99)
  expect(product.availability).to eq('In Stock')
end
```

```ruby
# Вопрос 2: Независимые пути выполнения?
# Создание Order и отправка Email — разные пути
# → ДА → Разделяем

it 'creates an order' do
  expect { checkout }.to change(Order, :count).by(1)
end

it 'sends confirmation email' do
  expect { checkout }.to have_enqueued_job(OrderConfirmationJob)
end
```

```ruby
# Вопрос 3: Один интерфейс или разные?
# AddressPresenter#formatted_address предоставляет несколько строк адреса
# → Один интерфейс → Объединяем

it 'formats address with all components', :aggregate_failures do
  expect(presenter.street_line).to eq('123 Main St')
  expect(presenter.city_line).to eq('Springfield, IL')
  expect(presenter.country_line).to eq('USA 12345')
end
```

#### Быстрый чек-лист

| Критерий | Разделять | Объединять |
|----------|-----------|------------|
| Можно описать каждую проверку отдельным предложением для бизнеса | ✅ | ❌ |
| Проверки затрагивают независимые пути кода | ✅ | ❌ |
| Тестируются разные методы/поведения | ✅ | ❌ |
| Все атрибуты из одного источника/состояния | ❌ | ✅ |
| Проверяется интерфейс объекта (value object, presenter, config) | ❌ | ✅ |
| Проверки описывают единое представление данных | ❌ | ✅ |

**Золотое правило:** Если сомневаетесь — разделяйте. Лучше иметь больше точных тестов, чем один неопределённый.

### Паттерны тестирования: до/после

Этот раздел показывает типичные антипаттерны и их правильные версии.

#### Пример 1: Тестирование конфигурационного объекта

❌ **Over-splitting (излишнее разделение):**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  let(:env_vars) do
    {
      'APP_NAME' => 'MyStore',
      'APP_URL' => 'https://mystore.com',
      'SUPPORT_EMAIL' => 'support@mystore.com',
      'NOREPLY_EMAIL' => 'noreply@mystore.com',
      'MAX_UPLOAD_SIZE' => '10485760',
      'SESSION_TIMEOUT' => '3600'
    }
  end

  it 'returns application name from ENV' do
    expect(config.app_name).to eq('MyStore')
  end

  it 'returns application URL from ENV' do
    expect(config.app_url).to eq('https://mystore.com')
  end

  it 'returns support email from ENV' do
    expect(config.support_email).to eq('support@mystore.com')
  end

  it 'returns noreply email from ENV' do
    expect(config.noreply_email).to eq('noreply@mystore.com')
  end

  it 'returns max upload size from ENV' do
    expect(config.max_upload_size).to eq(10485760)
  end

  it 'returns session timeout from ENV' do
    expect(config.session_timeout).to eq(3600)
  end
end
```

**Проблемы:**
- 6 отдельных тестов проверяют одно поведение: "конфигурация корректно инициализируется из ENV"
- При добавлении нового параметра придётся создавать ещё один тест
- Все тесты зависят от одного источника (`env_vars`), но это не отражено в структуре
- Если источник изменится, все 6 тестов упадут, хотя проблема одна

✅ **Правильное интерфейсное тестирование:**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  context 'when initialized from environment variables' do
    let(:env_vars) do
      {
        'APP_NAME' => 'MyStore',
        'APP_URL' => 'https://mystore.com',
        'SUPPORT_EMAIL' => 'support@mystore.com',
        'NOREPLY_EMAIL' => 'noreply@mystore.com',
        'MAX_UPLOAD_SIZE' => '10485760',
        'SESSION_TIMEOUT' => '3600'
      }
    end

    it 'exposes configuration interface from ENV', :aggregate_failures do
      # Application identity
      expect(config.app_name).to eq('MyStore')
      expect(config.app_url).to eq('https://mystore.com')
      
      # Email addresses
      expect(config.support_email).to eq('support@mystore.com')
      expect(config.noreply_email).to eq('noreply@mystore.com')
      
      # Limits (converted to integers)
      expect(config.max_upload_size).to eq(10485760)
      expect(config.session_timeout).to eq(3600)
    end
  end

  context 'when required ENV variables are missing' do
    let(:env_vars) { {} }

    it 'raises configuration error' do
      expect { config.app_name }.to raise_error(AppConfig::MissingConfigError)
    end
  end
end
```

**Преимущества:**
- Один тест ясно выражает поведение: "объект предоставляет полный интерфейс из ENV"
- Группировка комментариями показывает структуру конфигурации
- Отдельный контекст для error case проверяет другое поведение (валидацию)
- Быстрее выполняется (один setup вместо шести)
- Легче читается и поддерживается

#### Пример 2: Тестирование API-ответа

❌ **Излишняя детализация (проверка всего хэша):**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001', stock: 5) }

  it 'returns product details' do
    get "/api/products/#{product.id}"
    
    expect(response.parsed_body).to eq({
      'id' => product.id,
      'name' => 'Laptop',
      'price' => 999.99,
      'sku' => 'LPT-001',
      'stock' => 5,
      'category' => 'Electronics',
      'created_at' => product.created_at.iso8601(3),
      'updated_at' => product.updated_at.iso8601(3),
      'description' => nil,
      'weight' => nil,
      'dimensions' => nil
    })
  end
end
```

**Проблемы:**
- Тест сломается при добавлении любого нового поля в сериализатор
- Проверяются технические детали (`created_at`, `updated_at`), не важные для бизнеса
- Не понятно, какие поля критичны для клиента API
- Тест фиксирует реализацию, а не контракт

✅ **Правильный подход: проверка ключевых полей + специализированные инструменты:**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001') }

  it 'returns product with essential attributes', :aggregate_failures do
    get "/api/products/#{product.id}"
    
    expect(response).to have_http_status(:ok)
    expect(response.parsed_body).to include(
      'id' => product.id,
      'name' => 'Laptop',
      'price' => a_value_within(0.01).of(999.99),
      'sku' => 'LPT-001'
    )
  end

  # Полная структура ответа фиксируется через rspec-openapi или RSwag
  # (см. раздел "Тестирование API-контрактов")
end
```

**Преимущества:**
- Тест проверяет только критичные для бизнеса поля
- Использование `include` позволяет добавлять новые поля без поломки теста
- `a_value_within` учитывает особенности Float-арифметики
- Полная структура API фиксируется отдельными инструментами (OpenAPI, JSON Schema)

### 20. Предпочитайте verifying doubles (`instance_double`, `class_double`, `object_double`)

`double` создаёт «анонимный» двойник без проверки интерфейса. Он позволяет замокать несуществующие методы и пропустить регрессию, когда контракт меняется. `instance_double`, `class_double` и `object_double` проверяют интерфейс реальных объектов и защищают от ложных зелёных тестов.

```ruby
# плохо
let(:gateway) { double('PaymentGateway', charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end

# хорошо
let(:gateway) { instance_double(PaymentGateway, charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end
```

Что не так в плохом примере:

- `double` принимает любые методы, поэтому опечатка или изменение интерфейса пройдут незамеченными.
- Тест остаётся зелёным даже при несовпадении контракта с реальным `PaymentGateway`, и регрессия попадёт в продакшен.

- `instance_double(SomeClass)` проверяет методы экземпляра `SomeClass`.
- `class_double(SomeClass)` — методы самого класса (например, `.find`, `.call`).
- `object_double(existing_object)` — фиксирует интерфейс конкретного объекта (удобно для зависимостей, построенных в тесте).

**Когда verifying double использовать нельзя:**

- Класс или модуль создаётся динамически и ещё не загружен в момент выполнения теста (`require` отсутствует).
- Интерфейс формируется через `method_missing`/`respond_to_missing?`, и в спецификации нет сигнатур, которые можно проверить (например, `OpenStruct`, `Hashie::Mash`).
- Вы мокаете внешний сервис, у которого нет Ruby-класса (SOAP/XML API), и эмуляция происходит через `Struct.new` или обёртку на лету.

В этих редких ситуациях:

- Документируйте причину (`let(:gateway) { double('LegacyGateway') } # нет реального класса, метод задаётся в runtime`).
- Ограничьте контракт явными `allow(...).to receive(:method)` и добавьте интеграционный тест, который проверит реальное взаимодействие.

Во всех остальных случаях выбирайте verifying doubles — это дешёвый способ поймать опечатку ещё до запуска приложения.

### 21. Используйте shared examples для проверки разделяемого поведения

`shared_examples` служат для проверки общего поведения разных объектов. Они не про DRY ради снижения строк кода — тесты мы не «программируем» (см. пункт 12), они описывают правила. Если поведение повторяется, выносите именно его описание и ожидаемые наблюдения.

- Название `shared_examples` формулируйте через поведение: `'an enumerable resource'`, `'a pageable API'`, `'a collection of orders'`. Так в выводе RSpec видно, какое правило описывается.
- Применяйте `it_behaves_like`/`it_should_behave_like` там, где объект реально реализует контракт: например, класс включает модуль с общими методами (`Enumerable`, ваш `Paginatable` mixin).
- Внутри shared examples работайте только с публичным интерфейсом, ожидая то же поведение, которое проверял бы отдельный тест.

```ruby
# shared_examples: spec/support/shared_examples/paginatable.rb
RSpec.shared_examples 'a pageable API' do
  it 'returns the second page' do
    expect(resource.paginate(page: 2).current_page).to eq 2
  end

  it 'limits page size' do
    expect(resource.paginate(page: 1, per_page: 5).items.count).to eq 5
  end
end

# использование
describe OrdersQuery do
  subject(:resource) { described_class.new(scope: Order.all) }

  it_behaves_like 'a pageable API'
end

describe UsersQuery do
  subject(:resource) { described_class.new(scope: User.active) }

  it_behaves_like 'a pageable API'
end
```

- Shared example формулирует «что значит быть pageable», без нелепых «general behaviour».
- Каждый класс, включающий модуль `Paginatable`, подключает shared example и доказывает, что контракт выполняется.
- Если нужно добавить новую характеристику (например, сортировку), расширяете shared example — все клиенты автоматически проверяют обновлённый контракт.

Использование shared examples не отменяет требования писать осмысленные контексты и `it`. Они помогают избежать дублирования поведения, но не подменяют понятные спецификации.

### 22. Предпочитайте Request (API-контракт) specs вместо controller specs

Controller specs считаются устаревшими: Rails core и RSpec core команды официально рекомендуют писать Request (API-контракт) specs, начиная с релиза RSpec 3.5 и Rails 5.0 ([подробнее](https://rspec.info/blog/2016/07/rspec-3-5-has-been-released/#rails-support-for-rails-5)). Request (API-контракт) specs проверяют HTTP-контракт, а значит остаются ближе к наблюдаемому поведению и не зависят от внутренних контроллерных фильтров.

- Для новых тестов выбирайте Request (API-контракт) specs; только они покрывают стек Rack → контроллер → middleware целиком и показывают, что увидит клиент.
- Если приходится поддерживать legacy controller specs, помечайте их как наследие (например, `describe SomeController, :legacy`) и планируйте миграцию. При доработках расширяйте по пирамиде: поведение — в request spec, мелкую логику выносите в сервис/модель и покрывайте юнитами.
- Не дублируйте проверки: если действие уже описано на уровне request spec, controller spec лишь повторит реализацию и будет ломаться при рефакторинге маршрутов или фильтров.

## Тестирование API-контрактов: границы применимости RSpec

RSpec создан для описания и проверки **поведения** — бизнес-правил, которые выражаются через действия и их наблюдаемые последствия. Когда речь идёт о фиксации **контракта API** (структура ответа, типы полей, обязательные атрибуты), RSpec становится неподходящим инструментом: попытка описать контракт через множество `expect` превращает спецификацию в хрупкий набор проверок реализации.

### Философия: используйте подходящий инструмент для подходящей цели

- **RSpec для поведения:** Проверяйте бизнес-логику (создание заказа, авторизация), HTTP-статусы, ключевые поля ответа.
- **Специализированные инструменты для контрактов:** Фиксируйте полную структуру API, типы полей, вложенность, обязательность.

Такое разделение даёт:
- Читаемые RSpec-тесты, сосредоточенные на бизнес-правилах
- Автоматическую актуальную документацию API
- Защиту от breaking changes в контракте
- Независимую эволюцию поведения и контракта

### Антипаттерны тестирования JSON API в RSpec

#### Антипаттерн 1: Over-splitting (излишнее разделение)

Проверка каждого поля отдельным тестом создаёт избыточность и скрывает, что все поля — части единого контракта.

```ruby
# плохо: каждое поле — отдельный тест
describe 'GET /api/orders/:id' do
  let(:order) { create(:order, total: 150.0, status: 'pending') }

  it 'returns order ID' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body['id']).to eq(order.id)
  end

  it 'returns order total' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body['total']).to eq(150.0)
  end

  it 'returns order status' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body['status']).to eq('pending')
  end

  it 'returns customer email' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body['customer_email']).to be_present
  end
  # ... ещё 10 тестов для остальных полей
end
```

**Проблемы:**
- 10+ тестов описывают одну вещь: "API возвращает заказ"
- При каждом изменении контракта ломается множество тестов
- Непонятно, какие поля критичны для бизнеса, а какие — технические детали
- Повторные HTTP-запросы замедляют тесты

#### Антипаттерн 2: Излишняя детализация (проверка всего хэша целиком)

Сравнение полного ответа через `eq` фиксирует реализацию и делает тесты хрупкими.

```ruby
# плохо: проверка всей структуры побайтово
describe 'GET /api/orders/:id' do
  it 'returns order details' do
    get "/api/orders/#{order.id}"
    
    expect(response.parsed_body).to eq({
      'id' => order.id,
      'total' => 150.0,
      'status' => 'pending',
      'customer_email' => 'user@example.com',
      'items_count' => 3,
      'shipping_address' => {
        'street' => '123 Main St',
        'city' => 'Springfield',
        'postal_code' => '12345'
      },
      'created_at' => order.created_at.iso8601(3),
      'updated_at' => order.updated_at.iso8601(3),
      'discount_amount' => nil,
      'tax_amount' => 12.0,
      'notes' => nil
    })
  end
end
```

**Проблемы:**
- Тест падает при добавлении любого нового поля в сериализатор
- Проверяются технические timestamp-поля, не важные для бизнес-логики
- Не ясно, что именно критично: `total`, `status` или все поля равнозначны
- Порядок ключей в хэше может вызывать ложные падения

### Когда RSpec подходит для API-тестов

✅ **Используйте RSpec request specs когда:**

1. **Проверяете бизнес-поведение через API:**
   ```ruby
   it 'creates order with valid payment' do
     post '/orders', params: { product_id: 1, quantity: 2 }
     expect(response).to have_http_status(:created)
     expect(Order.last).to have_attributes(status: 'pending', total: 200.0)
   end
   ```

2. **Тестируете HTTP-статусы и базовую структуру:**
   ```ruby
   it 'returns successful response with order data', :aggregate_failures do
     get "/orders/#{order.id}"
     expect(response).to have_http_status(:ok)
     expect(response.content_type).to match(/json/)
     expect(response.parsed_body).to include('id', 'status', 'total')
   end
   ```

3. **Проверяете ключевые поля, важные для бизнес-логики:**
   ```ruby
   it 'includes essential order fields', :aggregate_failures do
     get "/orders/#{order.id}"
     expect(response.parsed_body).to include(
       'id' => order.id,
       'status' => 'pending',
       'total' => a_kind_of(Numeric)
     )
   end
   ```

❌ **Избегайте RSpec для:**

- Полной фиксации структуры ответа (схемы полей, типы, вложенность)
- Сравнения огромных JSON через `eq` или string comparison
- Документирования API-контракта для внешних потребителей
- Проверки всех возможных полей ответа "на всякий случай"

### Инструменты для тестирования API-контрактов

#### 1. JSON Schema validation (thoughtbot/json_matchers)

**Что это:** Gem для валидации JSON-ответов против JSON Schema прямо в RSpec-тестах.

**Когда использовать:** Промежуточное решение между ручными проверками и полноценными контрактными тестами. Подходит для проектов, где нужна валидация структуры без генерации документации.

**Установка:**
```ruby
# Gemfile
group :test do
  gem 'json_matchers'
end
```

**Использование:**
```ruby
# spec/support/api/schemas/order.json
{
  "type": "object",
  "required": ["id", "status", "total"],
  "properties": {
    "id": { "type": "integer" },
    "status": { "type": "string", "enum": ["pending", "paid", "shipped"] },
    "total": { "type": "number", "minimum": 0 },
    "customer_email": { "type": "string", "format": "email" }
  },
  "additionalProperties": false
}
```

```ruby
# spec/requests/orders_spec.rb
RSpec.describe 'Orders API', type: :request do
  it 'matches order schema' do
    get "/api/orders/#{order.id}"
    expect(response).to match_response_schema('order')
  end
end
```

**Преимущества:**
- Работает с существующими request specs
- Схема в отдельном файле — её можно переиспользовать
- `additionalProperties: false` ловит добавление полей без обновления схемы

**Недостатки:**
- Не генерирует документацию автоматически
- Схемы нужно поддерживать вручную

#### 2. rspec-openapi — автоматическая генерация OpenAPI спецификаций

**Что это:** Gem, который генерирует OpenAPI 3.0 спецификацию из обычных RSpec request specs во время выполнения тестов.

**Когда использовать:** Вы хотите использовать RSpec по прямому назначению (тестирование поведения) и при этом автоматически получать актуальную OpenAPI-документацию.

**Установка:**
```ruby
# Gemfile
group :development, :test do
  gem 'rspec-openapi'
end
```

**Конфигурация:**
```ruby
# spec/rails_helper.rb
RSpec.configure do |config|
  config.openapi_root = Rails.root.join('doc', 'openapi.yaml')
  config.openapi_specs = {
    'api/v1/openapi.yaml' => {
      info: {
        title: 'My API',
        version: 'v1'
      },
      servers: [{ url: 'https://api.example.com' }]
    }
  }
end
```

**Использование:**
```ruby
# spec/requests/orders_spec.rb
RSpec.describe 'Orders API', type: :request do
  # Обычный RSpec-тест, сфокусированный на поведении
  it 'creates order with valid payment' do
    post '/api/orders', params: { product_id: 1, quantity: 2 }
    expect(response).to have_http_status(:created)
    expect(Order.last.status).to eq('pending')
  end
  
  # rspec-openapi автоматически зафиксирует:
  # - путь POST /api/orders
  # - структуру request body
  # - структуру response с кодом 201
end
```

Запуск с генерацией OpenAPI:
```bash
OPENAPI=1 rspec spec/requests
```

**Добавление метаданных для лучшей документации:**
```ruby
describe 'GET /api/orders/:id', openapi: {
  summary: 'Get order details',
  tags: ['Orders'],
  security: [{ bearer_auth: [] }]
} do
  it 'returns order with items' do
    get "/api/orders/#{order.id}", headers: auth_headers
    expect(response).to have_http_status(:ok)
  end
end
```

**Преимущества:**
- Минимальное вторжение в существующие тесты
- Автоматическое обновление документации при изменении API
- Сохраняет ручные правки в OpenAPI-файле при слиянии
- RSpec-тесты остаются простыми и читаемыми

**Недостатки:**
- Ограниченный контроль над генерируемой схемой
- Не валидирует ответы против схемы во время тестов (только генерирует)

#### 3. RSwag — DSL для описания и тестирования OpenAPI

**Что это:** Gem, который предоставляет DSL поверх RSpec для явного описания API и генерации Swagger/OpenAPI документации + встроенный Swagger UI.

**Когда использовать:** Вы хотите явно описать API-контракт в тестах и получить валидацию ответов против схемы + живую документацию.

**Установка:**
```ruby
# Gemfile
gem 'rswag-api'
gem 'rswag-ui'

group :development, :test do
  gem 'rswag-specs'
end
```

```bash
rails g rswag:api:install
rails g rswag:ui:install
RAILS_ENV=test rails g rswag:specs:install
```

**Использование:**
```ruby
# spec/requests/orders_spec.rb
require 'swagger_helper'

RSpec.describe 'Orders API' do
  path '/api/orders' do
    post 'Creates an order' do
      tags 'Orders'
      consumes 'application/json'
      produces 'application/json'
      
      parameter name: :order, in: :body, schema: {
        type: :object,
        properties: {
          product_id: { type: :integer },
          quantity: { type: :integer, minimum: 1 }
        },
        required: ['product_id', 'quantity']
      }

      response '201', 'order created' do
        let(:order) { { product_id: 1, quantity: 2 } }
        
        schema type: :object,
          properties: {
            id: { type: :integer },
            status: { type: :string },
            total: { type: :number }
          },
          required: ['id', 'status', 'total']
        
        run_test!
      end

      response '422', 'invalid request' do
        let(:order) { { product_id: 1 } }
        run_test!
      end
    end
  end
end
```

Генерация документации:
```bash
rails rswag:specs:swaggerize
```

Документация доступна по адресу: `http://localhost:3000/api-docs`

**Преимущества:**
- Явное описание контракта в тестах
- Валидация ответов против схемы во время выполнения тестов
- Автоматическая генерация Swagger UI
- Полный контроль над схемой

**Недостатки:**
- Более verbose синтаксис по сравнению с обычными request specs
- Требует миграции существующих тестов на DSL
- Смешивает описание контракта и тестирование поведения

#### 4. Snapshot testing — фиксация эталонных ответов

**Что это:** Подход, пришедший из фронтенд-мира (Jest), где тест фиксирует "снимок" вывода при первом запуске и сравнивает с ним при последующих запусках.

**Откуда это:** В мире фронтенда (React, Vue) snapshot testing используется для фиксации рендеринга компонентов. Разработчик запускает тесты, они создают snapshot (HTML-вывод), и при последующих запусках любое изменение в рендере вызывает падение теста. Если изменение ожидаемое — разработчик обновляет snapshot, если нет — ловит регрессию.

**Как это работает с API:** Тот же принцип применим к OpenAPI-спецификациям или JSON-ответам:
1. Первый запуск теста генерирует эталон (OpenAPI spec или JSON snapshot)
2. Последующие запуски сравнивают текущий вывод с эталоном
3. При изменении API тест падает, показывая diff
4. Разработчик либо фиксирует регрессию, либо обновляет эталон

**Преимущества в связке с rspec-openapi:**

Когда вы используете `rspec-openapi`, вы:
- Пишете обычные RSpec request specs, сфокусированные на **поведении** (правильно ли создаётся заказ, приходит ли нужный статус)
- Автоматически получаете OpenAPI-спецификацию, фиксирующую **контракт** (структура ответа, типы полей)
- Можете организовать snapshot-тестирование этой OpenAPI-спеки

**Ловим двух зайцев:**
1. RSpec используется по прямому назначению — тестирование поведения
2. OpenAPI-спека как snapshot ловит неожиданные изменения контракта

**Инструменты для snapshot testing в Ruby:**

```ruby
# Gemfile
group :test do
  gem 'rspec-snapshot'  # Общий snapshot testing
  # или
  gem 'rspec-request_snapshot'  # Специализирован для request specs
end
```

**Пример использования:**
```ruby
RSpec.describe 'Orders API', type: :request do
  it 'returns order details' do
    get "/api/orders/#{order.id}"
    expect(response.body).to match_snapshot('order_details')
  end
end
```

При первом запуске создаётся файл `spec/__snapshots__/orders_api_spec.rb/order_details.json`. При последующих запусках текущий ответ сравнивается с этим файлом.

**Snapshot testing OpenAPI с rspec-openapi:**

После генерации OpenAPI через `OPENAPI=1 rspec`, файл `doc/openapi.yaml` можно версионировать в git. При изменении API:
- CI проверяет, изменился ли файл
- Если да — требует явного коммита обновления (= acknowledge breaking change)
- Если изменение неожиданное — ловится регрессия

**Когда использовать snapshot testing:**
- Для стабильных API с редкими изменениями
- Когда важно ловить неожиданные изменения контракта
- В связке с rspec-openapi для автоматического контроля контракта

**Когда не использовать:**
- Для API, которые часто меняются (постоянное обновление snapshots)
- Вместо осмысленных проверок поведения
- Для критичных бизнес-правил (лучше явные expectations)

### Рекомендованный подход: комбинация инструментов

✅ **Лучшая практика:**

1. **RSpec request specs** — для тестирования поведения:
   ```ruby
   it 'creates order and charges customer' do
     post '/orders', params: order_params
     expect(response).to have_http_status(:created)
     expect(Order.last.status).to eq('pending')
     expect(customer.reload.balance).to eq(0)
   end
   ```

2. **rspec-openapi** — для автоматической фиксации контракта:
   ```ruby
   # Тот же тест выше, запущенный с OPENAPI=1,
   # автоматически обновляет doc/openapi.yaml
   ```

3. **JSON Schema / thoughtbot/json_matchers** — для критичных эндпоинтов:
   ```ruby
   it 'returns valid payment confirmation' do
     post '/payments', params: payment_params
     expect(response).to match_response_schema('payment_confirmation')
   end
   ```

4. **RSwag** — если нужна живая документация и явный контроль:
   ```ruby
   # Для публичных API, где документация = контракт с клиентами
   path '/api/v2/orders' do
     post 'Creates order' do
       # ... подробное описание схемы
     end
   end
   ```

5. **Snapshot testing** — для ловли регрессий в контракте:
   ```bash
   # CI проверяет, что doc/openapi.yaml не изменился без явного коммита
   git diff --exit-code doc/openapi.yaml
   ```

### Золотое правило

**Не смешивайте проверку поведения и контракта в одном тесте.**

- RSpec = поведение (что система делает)
- OpenAPI/JSON Schema/Snapshots = контракт (как выглядит интерфейс)

Если тест читается как "проверяет, что система создаёт заказ" — это RSpec.  
Если тест читается как "проверяет, что ответ содержит все поля из схемы" — это контрактный тест.

### 23. Стабилизируйте время через `ActiveSupport::Testing::TimeHelpers`

Rails даёт модуль [`ActiveSupport::Testing::TimeHelpers`](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/Testing/TimeHelpers.html), который нужно подключать в тестах вместо ручного управления временем. Его ключевые методы (`freeze_time`, `travel_to`, `travel`, `travel_back`) замораживают `Time.zone` и очищают отложенные задачи, помогая избежать flaky тестов.

- Если вызываете `freeze_time` или `travel_to` без блока (например, в `before`), обязательно добавляйте `after { travel_back }`. Эти методы автоматически откатывают время только в блочной форме (`freeze_time { example.run }`, `travel_to(time) { ... }`), где модуль вызовет `travel_back` в `ensure`. Ручное изменение `Time.now` без обратного вызова оставит глобальное состояние и приведёт к плавающим падениям.
- В Rails-тестах опирайтесь на `Time.zone.now`/`Time.current` и методы `5.minutes`/`2.days`, чтобы расчёты учитывали часовой пояс приложения. `Time.now` и `Date.today` игнорируют зону — с ними легче получить несогласованность с `created_at`.
- При работе с ActiveJob/ActionMailer не забывайте, что `freeze_time` фиксирует таймеры. Если в примере запускается джоб с `wait_until`, возвращайте время в `after`, иначе последующие тесты будут ждать «прошлого».

В сумме: «заморозили — откатили». Любое отклонение ведёт к случайным, трудно воспроизводимым багам.

### 24. Делайте вывод падения теста читаемым

Перед тем как зафиксировать пример, представьте, что он упал: текст, который увидит команда, должен мгновенно объяснить ожидаемое и фактическое поведение. Если приходится вычитывать десятки строк разрозненного вывода, тест требует переработки.

```ruby
# плохо
it 'returns response payload' do
  expect(response.body).to eq(
    "{\"meta\":{\"status\":\"ok\",\"total\":3},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":2,\"name\":\"Bob\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[]}"
  )
end

# предполагаемый вывод при падении:
# expected: "{\"meta\":{\"status\":\"ok\",\"total\":3},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":2,\"name\":\"Bob\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[]}"
#      got: "{\"meta\":{\"status\":\"ok\",\"total\":2},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[\"missing Bob\"]}"
# (Compared using ==)
#
# Здесь две многострочные строки без форматирования; чтобы заметить расхождение, нужно вручную искать отличия в кавычках.
```

```ruby
# хорошо
describe 'GET /users' do
  subject(:payload) { JSON.parse(response.body, symbolize_names: true) }

  it 'returns metadata and users' do
    expect(payload.fetch(:meta)).to include(status: 'ok', total: 3)
    expect(payload.fetch(:data)).to match_array([
      include(id: 1, name: 'Alice'),
      include(id: 2, name: 'Bob'),
      include(id: 3, name: 'Carol')
    ])
    expect(payload.fetch(:errors)).to be_empty
  end
end

# Падение покажет структурный дифф, например:
# expected collection contained: [{:id=>1, :name=>"Alice"}, {:id=>2, :name=>"Bob"}, {:id=>3, :name=>"Carol"}]
# actual collection contained:   [{:id=>1, :name=>"Alice"}, {:id=>3, :name=>"Carol"}]
# the missing elements were:     [{:id=>2, :name=>"Bob"}]
# the extra elements were:       []
# => видно, что отсутствует пользователь Bob и нарушена мета-информация.
```

Что не так в плохом примере:

- Сравнение строкой прячет структуру ответа, и поиск отличий превращается в ручной дифф на глаз.
- Сообщение об ошибке никак не объясняет смысл расхождения — нужно самому разбирать JSON.

- Используйте структурные ожидания (`match_array`, `include`, `have_attributes`), чтобы RSpec показывал предметный дифф.
- Форматируйте сложные данные перед сравнением (`JSON.parse`, `hash.deep_symbolize_keys`). Сырые строки или SQL-дампы в падении почти бесполезны.
- Если matcher не даёт достаточной ясности, напишите helper, который вернёт компактное описание расхождения (но не превращайтесь в mini-программу — см. пункт 12).
- В конечных request-тестах не сравнивайте огромные JSON через дифф-матчеры «побайтно»: такая привязка к деталям приводит к постоянным падениям при малейших изменениях и в 95% случаев рождает flaky тесты. Для проверки интерфейса используйте специализированные инструменты генерации спецификаций — например, `rspec-openapi` для автоматического слепка и сравнения OpenAPI или RSwag, если нужно поддерживать Swagger-документацию. Эти решения точнее и эффективнее фиксируют контракт, чем ручные diff-ожидания, а при необходимости можно подключать и другие подходы (Pact, contract-тесты на уровне инфраструктуры).
## Внешние сервисы

- **HTTP-запросы.** Реальные вызовы в тестах запрещены: включайте WebMock (или аналог) и явно разрешайте только те хосты, которые эмулируете. Любая попытка обратиться во внешний интернет должна завершаться понятной ошибкой.
- **Фиксация контрактов.** Если протокол стабилен, используйте VCR — он фиксирует ответы и предотвращает флейки. Когда важнее документировать формат и семантику, подключайте контрактные тесты: Pact для сценариев потребитель ↔ поставщик, `rspec-openapi` или RSwag для актуальной OpenAPI-спецификации. В контракте фиксируйте только публичные поля, иначе получится тест реализации.
- **Очереди и фоновые джобы.** В спецификациях проверяйте факт постановки (`expect { ... }.to have_enqueued_job`) и корректность аргументов. Бизнес-логику самой джобы выносите в отдельный юнит-тест: там запускаем `perform`/`perform_now` и убеждаемся, что поведение соответствует правилам домена.


## Нюансы времени между Ruby и PostgreSQL

- `Date#wday` возвращает 0 для воскресенья, в то время как `EXTRACT(DOW FROM ...)` в PostgreSQL даёт 0 по воскресеньям и 1 по понедельникам. Совмещая Ruby- и SQL-проверки в тестах, явно фиксируйте ожидаемый день недели и не сравнивайте цифры «как есть».
- `Date.current.beginning_of_week` подчиняется `Rails.application.config.beginning_of_week`, а `date_trunc('week', ...)` в PostgreSQL по ISO всегда стартует с понедельника. Если приложение работает с календарём, добавляйте тесты, которые проверяют корректный «первый день недели» через публичный интерфейс, иначе легко получить flaky тест при смене настройки.
- `Date.parse` и `Time.parse` игнорируют `Time.zone`, тогда как ActiveRecord сохраняет `timestamp` в UTC. В тестах, где важна зона, используйте `Time.zone.parse`, `Time.zone.local` и `in_time_zone`, а ожидания выносите в `Time.zone.at`/`change`.
- Переходы через полночь и DST: PostgreSQL вычисляет интервалы UTC-значениями, а Ruby при `travel_to` может попасть в «не существующий» час. Чтобы не ловить плавающие падения, фиксируйте время в середине дня (`travel_to(Time.zone.parse('2024-03-25 12:00'))`) и пишите отдельные примеры на переходы, если бизнес-процесс затрагивает крайние точки.