# Навигация

- [Что можно изучить по тестам](#что-можно-изучить-по-тестам)
- [Про RSpec](#про-rspec)
- [Пирамида тестирования и выбор уровня](#пирамида-тестирования-и-выбор-уровня)
- [Глоссарий](#глоссарий)
- [RSpec style guide](#rspec-style-guide)
  - [Поведение и структура тестов](#поведение-и-структура-тестов)
  - [Синтаксис и читаемость](#синтаксис-и-читаемость)
  - [Подготовка контекста и данных](#подготовка-контекста-и-данных)
- [Тестирование API-контрактов: границы применимости RSpec](#тестирование-api-контрактов-границы-применимости-rspec)
  - [Полный гайд по API-контрактам](guide.api.ru.md)
- [Внешние сервисы](#внешние-сервисы)
- [Нюансы времени между Ruby и PostgreSQL](#нюансы-времени-между-ruby-и-postgresql)

# Что можно изучить по тестам

- **Better Specs** — стиль и формулировки: научитесь писать читаемые `describe/context/it`, выбирать матчеры и избегать анти-паттернов. <https://www.betterspecs.org>
- **Testing for Beginners** — вводная книга: поймёте, что тестировать, как мыслить сценариями и разбирать красные тесты. <http://testing-for-beginners.rubymonstas.org/index.html>
- **Pluralsight: RSpec Ruby Application Testing** — hands-on курс: шаг за шагом построите BDD-цикл, закрепите структуру `describe/context/it` и три фазы теста. <https://www.pluralsight.com/courses/rspec-ruby-application-testing>
- **Everyday Rails Testing with RSpec** — практики и инструменты: от factory_bot до VCR/WebMock, плюс ежедневные паттерны поддержки базового покрытия. <https://leanpub.com/everydayrailsrspec>

Эти материалы дадут базу. Ниже — философия RSpec/BDD, на которой держатся правила из следующего раздела.

# Про RSpec

RSpec — тестовая библиотека для Ruby с DSL, заточенным под описание поведения, а не внутренней реализации.

```ruby
describe "my app" do
  it "works" do
    expect(MyApp.working).to eq(true)
  end
end
```

Официальный слоган на <https://rspec.info/>:

```
Behaviour Driven Development for Ruby.
Making TDD Productive and Fun.
```

Ключевая мысль: RSpec — инструмент BDD для Ruby. Он делает практику TDD продуктивной и более "человечной" за счет языка, близкого к бизнес-формулировкам.

## Как связаны RSpec, BDD и TDD

TDD (test-driven development) — короткий цикл Red -> Green -> Refactor:

- пишем тест, фиксирующий желаемое поведение;
- пишем минимальный код, чтобы тест прошел;
- рефакторим, сохраняя зеленое состояние.

BDD (behaviour-driven development) вырос из TDD и смещает фокус на поведение домена и язык разговора с бизнесом. Тесты становятся читаемой спецификацией, а не просто проверкой кода.

RSpec воплощает BDD в экосистеме Ruby: `describe/context/it` помогают формулировать поведение единообразно и понятно.

## Зачем нам BDD на практике

- Единый язык с бизнесом: формулируем правила домена "человеческими" фразами, не зная реализации.
- Исполняемая документация: тесты — проверяемая спецификация поведения.
- Быстрая локализация проблем: упавший тест явно показывает, какое правило нарушено.
- Свободный рефакторинг: фокус на том, что делает система, а не как она устроена.

**Предметная область** — набор правил и понятий, которые бизнес хочет видеть в системе (например, биллинг). В коде мы реализуем именно эти правила поведения.

## От естественного языка к формальному синтаксису Gherkin

BDD часто опирается на Gherkin — формальный, но читаемый синтаксис для описания историй и сценариев. Он фиксирует три ключевые фазы: Given (исходный контекст), When (действие), Then (результат).

Пример истории и сценариев:

```
As a store owner
In order to keep track of stock
I want to add items back to stock when they're returned.

Scenario 1: Refunded items should be returned to stock
  Given that a customer previously bought a black sweater from me
  And I have three black sweaters in stock
  When they return the black sweater for a refund
  Then I should have four black sweaters in stock

Scenario 2: Replaced items should be returned to stock
  Given that a customer previously bought a blue garment from me
  And I have two blue garments in stock
  And three black garments in stock
  When they return the blue garment for a replacement in black
  Then I should have three blue garments in stock
  And two black garments in stock
```

И адаптация на русском:

```
Как владелец магазина
Чтобы следить за запасами на складе
Я хочу возвращать товары на склад, когда их возвращают покупатели.

Сценарий 1: Возвращенные товары должны вернуться на склад
  Дано, что клиент ранее купил у меня черный свитер
  И на складе есть три таких свитера
  Когда клиент возвращает свитер
  Тогда на складе должно быть четыре черных свитера

Сценарий 2: Обмененные товары должны вернуться на склад
  Дано, что клиент покупал у меня одежду синего цвета
  И на складе есть два таких наименования синего цвета
  И три наименования черного цвета
  Когда клиент возвращает синюю вещь, чтобы обменять на черную
  Тогда на складе должно быть три синих наименования
  И два черных наименования
```

### Язык Gherkin — памятка

| Ключевое слово (EN) | Русский | Короткое описание |
| --- | --- | --- |
| Story / Feature | История | Заголовок спецификации, формулирует ценность. |
| As a | Как (в роли) | Роль заинтересованного лица. |
| In order to | Чтобы достичь | Цель роли. |
| I want to | Я хочу | Краткий желаемый результат. |
| Scenario | Сценарий | Конкретный сценарий истории. |
| Given | Дано | Исходный контекст (повторяется через And). |
| When | Когда | Действие, запускающее сценарий. |
| Then | Тогда | Наблюдаемый результат (можно добавлять And/But). |
| And / But | И / Но | Уточнение контекста или исключения. |

### Как это соотносится с RSpec

RSpec не требует Gherkin и не исполняет `.feature`-файлы, но следует тем же смысловым фазам:

- **Given** -> подготовка контекста (`let`, `before`, вспомогательные методы).
- **When** -> действие, которое проверяем (вызов метода, HTTP-запрос, команда).
- **Then** -> ожидаемый результат (`expect`-утверждения).
- **Feature / Story** -> верхний уровень `describe`, задающий область поведения.
- **Scenario** -> `it`, конкретный пример поведения.
- **And / But** -> уточнение контекста через вложенные `context`.

Это не механическое соответствие один-к-одному, но такая оптика помогает писать тесты как читабельные спецификации домена. На этой базе построены правила из следующего раздела.

## Пирамида тестирования и выбор уровня

BDD ставит во главу угла поведение, но сами проверки живут на разных уровнях. Держите в голове пирамиду: быстрые модульные тесты в основании, сервисные/интеграционные — посредине, end-to-end и контрактные — на вершине. Правильный выбор уровня помогает не скатываться к проверкам реализации.

| Уровень | Вопрос | Наблюдение | Типичные инструменты |
| --- | --- | --- | --- |
| Юнит (модель, сервис, объект) | Как ведёт себя маленький кусок логики? | Возвращаемое значение, вызовы зависимостей (через doubles) | `expect`, doubles, pure Ruby |
| Интеграционный / сервисный | Как взаимодействуют несколько компонентов? | Ответ сервиса, изменение доменной модели, побочные эффекты | Request/feature specs, ActiveJob, mailers |
| Request / API-контракты | Что видит клиент (frontend, внешний сервис)? | HTTP-статус, тело ответа, заголовки | Request specs, pact/contract tests |
| Системный (E2E) | Работает ли пользовательская история целиком? | UI-реакции, end-to-end поток | Capybara, Cypress, etc. |

Железных правил нет, но есть ориентиры:

- Проверяйте на том уровне, где поведение естественно наблюдать. Request spec проверяет статус/ответ, а не содержимое базы — иначе вы тестируете реализацию контроллера, а не API-контракт (см. правило 1).
- Если одна проверка требует сложной подготовки контекста или медленных зависимостей, подумайте, не лучше ли перенести часть логики в более низкий уровень пирамиды.
- Единичный побочный эффект (создана запись, отправлено письмо) лучше выносить в отдельный юнит/сервисный тест. В BDD-контрактах фиксируйте лишь то, что важно потребителю.
- `:aggregate_failures` (правило 23) применяем, только если говорим об одном поведении и хотим увидеть все нарушения сразу — это не способ проверить половину пирамиды в одном `it`.

С пирамидой в голове легче решать, что считать happy path, что — corner case, и какой уровень тестов ответственен за подтверждение каждого правила.

## Глоссарий

### Основные понятия

- **Поведение** — наблюдаемое изменение состояния системы или её реакция на внешнее воздействие, которое можно описать одним предложением на естественном языке.

  Поведение в контексте BDD и RSpec — это не каждый атрибут или метод объекта, а бизнес-правило или результат действия, который имеет значение для заинтересованных лиц.

  **Примеры поведений:**
  - "Создаёт заказ в базе данных"
  - "Отправляет подтверждение на email"
  - "Предоставляет полный профиль пользователя из сессии"
  - "Блокирует доступ для неавторизованного пользователя"
  - "Вычисляет итоговую стоимость с учётом скидки"
  **НЕ являются отдельными поведениями:**
  - Каждый отдельный атрибут конфигурационного объекта (например, `name`, `email`, `phone` — это части интерфейса объекта User)
  - Каждое поле в структуре API-ответа (все поля вместе составляют контракт ответа)
  - Каждый геттер value object (геттеры вместе формируют публичный интерфейс)

  **Правило:** Если вы не можете описать проверку как самостоятельное действие или результат на естественном языке, скорее всего это часть более крупного поведения.

### Виды тестирования

В зависимости от того, что именно мы проверяем, тесты делятся на два основных типа:

- **Поведенческое тестирование (Behavioral testing)** — проверка бизнес-логики через наблюдаемые побочные эффекты или реакции системы. Каждое действие вызывает независимый эффект, который важен для бизнеса.

  **Примеры:**
  - Проверка, что метод создаёт запись в базе данных
  - Проверка, что сервис отправляет email
  - Проверка, что статус заказа изменился после оплаты
  - Проверка, что система логирует событие

  **Характерные признаки:**
  - Каждый эффект — отдельное правило бизнес-логики
  - Эффекты независимы друг от друга
  - Можно описать каждый эффект отдельным предложением: "система делает X"

- **Интерфейсное тестирование (Interface testing)** — проверка набора атрибутов объекта в определённом состоянии. Все проверяемые атрибуты выводятся из одного источника/состояния и представляют единое поведение: "объект предоставляет корректный интерфейс".

  **Примеры применения:**
  - Value objects с множественными атрибутами (Money, Address, Coordinate)
  - Конфигурационные объекты (Settings, Config, Preferences)
  - Read-only интерфейсы, построенные из единого источника
  - Presenter/Decorator объекты, предоставляющие производные атрибуты

  **Характерные признаки:**
  - Атрибуты связаны общим источником данных
  - Изменение источника влияет на все атрибуты сразу
  - Атрибуты формируют целостный контракт объекта
  - Описывается как "объект предоставляет интерфейс X"

  **Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, это интерфейсное тестирование — объедините проверки в один `it` с `:aggregate_failures`.

  **Важно:** Интерфейсное тестирование применимо к доменным объектам. Для HTTP API-интерфейсов используйте специализированные инструменты фиксации контрактов (см. раздел "Тестирование API-контрактов: границы применимости RSpec").

### Характеристики и состояния

- **Характеристика** — доменный аспект, влияющий на исход поведения (роль пользователя, способ оплаты, статус заказа).
  - *Как найти:* спросите «если изменить этот аспект, изменится ли ожидаемый результат?», и убедитесь, что речь идёт о бизнес-факте, а не о технической детали.

- **Состояние характеристики** — конкретный вариант значения характеристики, важный для правила (подписка активна, баланс ниже лимита).
  - *Как выделить:* сгруппируйте возможные значения в доменные диапазоны и сформулируйте их короткими утверждениями.
  - *Типы состояний:*
    - бинарные (да/нет: карта привязана ↔ не привязана);
    - множественные (enum: роль = admin / manager / guest);
    - диапазоны (число/дата: баланс ≥ стоимость / баланс < стоимость).

- **Контекст (`context`)** — блок, фиксирующий одно или несколько состояний характеристик. Контекст отвечает за «Given»-часть спецификации.
  - **Положительный контекст** — состояние выполняется (обычно часть happy path).
  - **Отрицательный контекст** — состояние нарушено или отрицается (часто часть corner case).
  - **Вложенный контекст** — уточняет внешний, добавляя состояние новой характеристики или уточняя текущую.

- **Кейс / пример (`it`)** — минимальный сценарий, проверяющий конкретное поведение на выбранном наборе состояний.
  - **Happy path case** — основной поток: ожидаемый успех без исключений.
  - **Corner case** — отклонение от основного потока: крайние значения, ошибки, исключительные ситуации.
  - **Положительный тест** — пример подтверждает поведение (чаще совпадает с happy path).
  - **Отрицательный тест** — пример показывает отказ или защиту от некорректного поведения (часто совпадает с corner case).
  - *Важно:* happy/corner описывают тип кейса, а положительный/отрицательный — результат проверки. При множественных состояниях возможно несколько happy path кейсов без отрицательных тестов на этой характеристике.

- **Задание состояния (`let`/`before`)** — объявление, которое делает формулировку контекста истинной. Его размещают сразу под соответствующим `context`, чтобы связь между описанием и подготовкой контекста читалась без поиска по файлу (см. пункт 11).

| Тип кейса       | Тип контекстов внутри                  | Результат теста             |
| --------------- | -------------------------------------- | --------------------------- |
| Happy path case | Положительные контексты                | Положительный тест          |
| Corner case     | Отрицательные или уточняющие контексты | Отрицательный тест / защита |

Таблица отражает типичную связь, но возможны исключения — например, enum-характеристика может включать несколько happy path кейсов без отрицательных тестов, или corner case может завершаться положительным результатом (например, graceful degradation).

- **Flaky test** — тест, который ведёт себя непредсказуемо: иногда зелёный, иногда красный при неизменном коде. Чаще всего связан с нестабильным временем, глобальным состоянием, случайным порядком или зависимостями от внешних сервисов.

# RSpec style guide

## Почему мы пишем тесты именно так: когнитивная нагрузка

Все правила в этом руководстве объединяет одна цель: **снизить когнитивную нагрузку при чтении, понимании и изменении тестов**.

**Когнитивная нагрузка** — это объем умственных усилий, необходимых для выполнения задачи. В контексте тестов это означает:
- Сколько информации нужно удерживать в памяти, чтобы понять, что проверяет тест?
- Сколько времени требуется, чтобы найти нужный тест при падении?
- Насколько легко изменить тест при изменении требований?

### Три типа когнитивной нагрузки в тестах

1. **Внутренняя нагрузка** — сложность самой предметной области. Это неизбежно: если бизнес-правило сложное, тест будет отражать эту сложность.

2. **Посторонняя нагрузка** — искусственная сложность из-за плохой организации кода. Примеры:
   - Тест проверяет реализацию вместо поведения → читателю нужно "выполнить код в голове"
   - Состояния характеристик скрыты в приватных методах → нужно искать определения
   - Несколько поведений в одном `it` → непонятно, какое правило нарушено при падении

3. **Релевантная нагрузка** — усилия на построение ментальной модели. Хорошие тесты помогают строить эту модель быстро:
   - Явная структура `context` показывает зависимости характеристик
   - Описание `it` формулирует бизнес-правило на естественном языке
   - Трёхэтапная структура (Given-When-Then) упрощает чтение

### Как правила снижают когнитивную нагрузку

Каждое правило в этом руководстве атакует постороннюю нагрузку и усиливает релевантную:

- **Правило 1** (поведение, не реализация) — устраняет необходимость понимать внутреннее устройство кода
- **Правило 5** (иерархия контекстов) — делает зависимости характеристик видимыми сразу
- **Правило 10** (subject) — явно показывает, что тестируется, не нужно искать объект в ожиданиях
- **Правило 11** (трёхэтапная структура) — создаёт предсказуемый паттерн чтения
- **Правила 12-13** (фабрики) — скрывают технические детали, оставляют только бизнес-характеристики
- **Правило 16** (явность важнее DRY) — тесты остаются документацией, а не головоломкой из абстракций
- **Правило 23** (aggregate_failures) — показывает все нарушения сразу, экономя циклы отладки

Когда вы следуете этим правилам, ваши тесты становятся **исполняемой документацией**: коллеги могут быстро понять бизнес-правила, новые разработчики легко вникают в домен, а изменения требований не превращаются в переписывание половины test suite.

**Золотое правило:** Если при чтении теста возникает вопрос "а что это значит?" или "откуда это берётся?", значит посторонняя когнитивная нагрузка слишком высока. Упростите.

## Поведение и структура тестов

### 1. Тестируйте поведение, а не реализацию

Если в вашем тесте нет описания [поведения](#основные-понятия), то это не тест. Почему? При отсутствии описания поведения возникает привязка
к реализации, когда после вас кто-то будет смотреть тесты - он ничего не поймет и тесты окажутся бесполезными.

###### далее `some_action` в примерах - это псевдокод, который мы тестируем и поведение которого мы описываем

```ruby
# отвратительно
describe "#some_action" do
  # ... создаем пользователя, но не связываем подготовку контекста с описанием
  it "true" do          # из этого описания не понятно, что означает факт того, что мы ожидаем `true`
    expect(some_action).to be(true)
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... создаем пользователя и явно задаём характеристику, о которой говорим в `it`
  it "allows unlocking the user" do         # это описание рассказывает нам о том, что означает наше ожидание от кода
    expect(some_action).to be(true)
  end
end
```

Что не так в плохом примере:

- Описание `it` не рассказывает о поведении; непонятно, что означает ожидаемый `true`.
- Контекст в комментарии не связывается с формулировкой примера, поэтому спецификация не читается как правило поведения.

Или, например, используйте `match_array` или `contain_exactly`, когда пишите ожидание для массива, порядок значений в котором вам не важен.

```ruby
# плохо
expect(some_action).to eq [1, 2, 3] # pass
```

```ruby
# хорошо
expect(some_action).to match_array [2, 3, 1] # pass
expect(some_action).to contain_exactly(1, 2, 3) # pass
```

Что не так в плохом примере:

- Сравнение `eq` привязывает тест к порядку элементов и ведёт к ложным падениям.
- Спецификация описывает реализацию, а не правило.

Представим что `some_action` возвращал всегда `[1, 2, 3]` и ваши тесты проходили,
потом вы внесли какие-то изменения в код, обновили базу данных и т.д. То есть по какой-то причине порядок в массиве изменился,
например, он стал `[2, 1, 3]`,
и у вас начала падать дюжина тестов. И все это произошло из-за вашей привязки к реализации!
Не делайте так, тестируйте конкретное поведение.
Если это выборка данных, то проверяйте факт правильной выборки данных.

В целом, каждый раз как вы работаете с любой коллекцией (массивы, хеши, ActiveRecord::Relation ...)
и используете `eq`, то это звоночек, что вы делаете что-то не так. Возможно существует хелпер из библиотеки `RSpec Expectations`, подходящий
для определения вашего ожидания, а возможно вы в принципе не то тестируете (не поведение вашего кода) или даже не то реализуете.

**Как это снижает когнитивную нагрузку:**
- Описание поведения на естественном языке (`"allows unlocking the user"`) создаёт ментальную модель без необходимости читать код
- Правильный матчер (`match_array` вместо `eq`) сразу показывает намерение: "проверяем состав, а не порядок"
- При падении теста с ясным описанием сразу понятно, какое бизнес-правило нарушено — не нужно анализировать реализацию

### 2. Проверяйте, что тест тестирует

После написания теста убедитесь, что он действительно ловит баги — сломайте код и проверьте, что тест падает. Это второе по важности правило после "тестируй поведение": без проверки работоспособности теста вы рискуете получить ложно-зелёный тест, который всегда проходит независимо от корректности кода.

#### Проблема: code-first вместо test-first

В идеальном мире TDD (test-driven development) цикл "Red → Green → Refactor" гарантирует, что тест сначала падает (Red), а затем проходит после реализации (Green). Но в реальной коммерческой разработке большинство команд не следует строгому TDD — сначала пишется код, потом тесты. Это приводит к риску "подгонки теста под реализацию": тест написан так, что он проверяет текущую реализацию, но не ловит ошибки.

**Типичный сценарий:**

1. Вы написали код
2. Написали тест, который проходит
3. Закоммитили
4. Через неделю кто-то ломает код
5. Тест всё равно зелёный — потому что он никогда не проверял правильное поведение

#### Надуманный пример

**Примечание:** Опытному читателю будет очевидна проблема в этом примере, но автору гайда сложно придумать по-настоящему практичный пример. Такие ситуации очень коварны и легко возникают повсеместно в реальном коде, часто в более сложном контексте, где ошибка не так заметна.

```ruby
# код
class NotificationService
  def notify_user(user, message)
    UserMailer.notification(user.email, message).deliver_later
  end
end
```

```ruby
# плохо
describe NotificationService do
  let(:user) { double(email: 'user@example.com') }
  let(:mailer) { double(deliver_later: true) }

  before do
    allow(UserMailer).to receive(:notification).and_return(mailer)
  end

  it 'sends notification to user' do
    service.notify_user(user, 'Hello')
    expect(UserMailer).to have_received(:notification)
  end
end
```

**Что не так:**

- Тест проверяет только факт вызова `notification`, но не проверяет аргументы
- Если код сломается и начнёт передавать `nil` вместо email или неправильное сообщение — тест останется зелёным
- Кажется, что всё покрыто, но по факту критичная часть (передача правильных данных) не проверяется

#### Практический чек-лист

После написания каждого теста выполните "ручной Red":

1. ✅ Тест проходит (Green)
2. 🔨 Сломайте код одним из способов:
   - Верните неправильное значение (`return 0`, `return nil`, `return "wrong"`)
   - Закомментируйте ключевую строку логики
   - Измените условие (`if` → `unless`, `>` → `<`)
   - Передайте неправильные аргументы в вызовы методов
3. ❌ Тест должен упасть (Red)
4. 🔄 Верните код в исходное состояние
5. ✅ Тест снова проходит (Green)

Если на шаге 3 тест остался зелёным — переписывайте тест, он не проверяет реальное поведение.

**Золотое правило:** Тест, который никогда не падал, не доказывает ничего. Сломайте код и убедитесь, что тест ловит поломку — только тогда у вас есть гарантия, что он работает.

**Как это снижает когнитивную нагрузку:**
- Ложно-зелёные тесты создают иллюзию покрытия и заставляют команду постоянно сомневаться: "а точно этот тест что-то проверяет?"
- Проверка теста через "ручной Red" даёт уверенность — не нужно держать в голове вопрос "а работает ли этот тест вообще?"
- Команда может доверять test suite и не тратить ментальные усилия на недоверие к тестам

### 3. Каждый example (`it`) описывает одно наблюдаемое поведение

Описание в `it` должно быть уникальным и рассказывать об одной бизнес-истине. Если два примера называют одно и то же, значит мы проверяем реализацию разными путями. Это запах: либо нужно выделить отдельное [поведение](#основные-понятия), либо перераспределить проверки по пирамиде тестирования.

- Один `it` = одна ситуация из спецификации = одно ключевое наблюдение.
- Наблюдение выбираем на уровне контракта (HTTP-статус, тело ответа, возвращаемое значение), а не внутренних побочных эффектов, если только команда не договорилась иначе.
- Когда нужно проверить несколько следствий одного правила, разделяйте их на разные `it`. `:aggregate_failures` используйте лишь когда действительно говорите об одном поведении (см. пункт 23).

Тест — это короткое утверждение о поведении, а не мини-программа. Чем точнее формулировка `it`, тем легче читать спецификацию как документацию.

```ruby
# плохо
it "creates a user" do
  expect { post_signup }.to change(User, :count)
  expect(response).to redirect_to dashboard_path
end
```

```ruby
# хорошо
it "redirects user to dashboard after signup" do
  post_signup
  expect(response).to redirect_to dashboard_path
end

it "persists the user after signup" do
  expect { post_signup }.to change(User, :count)
end
```

Что не так в плохом примере:

- Два разных поведения спрятаны в одном `it`, поэтому при падении непонятно, какое правило нарушено.
- Информация в отчёте RSpec теряет связь с описанием поведения, и тест перестаёт быть спецификацией.
- Информацию в отчёте RSpec приходится анализировать, а так же обращаться к тесту, чтобы разобраться, какое поведение было ожидаемым, из-за отсутствия описания в отчете.

Request spec пример. Мы хотим убедиться, что авторизация успешна, и выбираем наблюдение на уровне API, а не БД:

```ruby
# плохо
it "creates a session" do
  post "/sessions", params: creds
  expect(Session.count).to eq 1
end
```

```ruby
# хорошо
it "returns an access token" do
  post "/sessions", params: creds
  expect(response).to have_http_status(:created)
  expect(response.parsed_body.fetch("token")).to be_present
end
```

Что не так в плохом примере:

- Проверка обращается к базе напрямую и фиксирует реализацию контроллера вместо публичного API-контракта.
- Падение такого теста подсказывает только «запись не создана», а не то, что клиенту пришёл неверный ответ.

> Не сравнивайте JSON целиком строкой: смотрите раздел 22 («Делайте вывод падения теста читаемым») — там показано, как структурный дифф помогает увидеть расхождение сразу.

Если в `it` появляется много `expect`, это обычно сигнал: мы пытаемся зафиксировать побочные эффекты вместо поведения. Типичный пример — регистрация пользователя и отправка welcome-письма. В request-spec мы проверяем статус/ответ API, а факт отправки письма опускаем на уровень юнит/сервисного теста (или возвращаемся к пирамиде и пишем отдельный сценарий, если письмо — самостоятельное правило). Не превращайте спецификацию поведения в маленькую программу: циклы, условные операторы и вычисления в тестах — прямой признак, что мы перестали описывать правила и начали переписывать реализацию.

**Почему не стоит совмещать много ожиданий в один `it`:**

Хотя это ускоряет тесты (данные создаются один раз, при первом падении остальные пропускаются), это приводит к проблемам:

1. Менее читаемые результаты и сам тест
2. Непонятно, какое ожидание соответствует описанию в `it`
3. Отсутствие изоляции между ожиданиями
4. **Главное:** это запах плохого дизайна кода — если тест проверяет несколько разных вещей, значит код делает несколько разных вещей, нарушая принцип "Do One Thing" (Clean Code, Robert Martin)

Если тесты стали "слишком умными", вероятно таков и тестируемый код. Разделите код на простые части, напишите модульные тесты для каждой, затем простой интеграционный тест для их композиции.

#### 2.1. Исключение для интерфейсного тестирования

При тестировании объектов, предоставляющих набор связанных атрибутов (см. "Интерфейсное тестирование" в глоссарии), несколько ожиданий в одном `it` с `:aggregate_failures` допустимы и предпочтительны, так как они представляют единое поведение: "объект предоставляет корректный интерфейс в заданном состоянии".

**Когда применимо интерфейсное тестирование:**

- Value objects с множественными атрибутами (Money, Address, Coordinate)
- Конфигурационные объекты (Settings, Config, Preferences)
- Read-only интерфейсы, построенные из единого источника данных
- Presenter/Decorator объекты, предоставляющие производные атрибуты

**Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, объедините их в один `it` с `:aggregate_failures`.

Подробнее о том, когда `:aggregate_failures` допустим и какие есть альтернативы, см. [правило 23](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило).

**Примеры хороших названий для интерфейсных тестов:**

- ✅ `'exposes product catalog interface'` — явно указывает на проверку интерфейса
- ✅ `'returns complete order summary'` — показывает, что проверяется полный набор данных
- ✅ `'builds user profile from session data'` — описывает источник и что строится
- ✅ `'provides shipping address details'` — чёткое описание предоставляемого интерфейса

**Избегайте:**

- ❌ `'works correctly'` — слишком общее, не описывает что проверяется
- ❌ `'returns correct values'` — не ясно, какие именно значения
- ❌ `'has valid attributes'` — расплывчато, не указывает на интерфейс

```ruby
# плохо: over-splitting интерфейса на отдельные тесты
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }
  
  it('returns product name') { expect(presenter.display_name).to eq('Laptop') }
  it('returns formatted price') { expect(presenter.formatted_price).to eq('$999.99') }
  # ... еще 2 проверки для availability и SKU
end
```

```ruby
# хорошо: интерфейсное тестирование с aggregate_failures
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }

  it 'exposes product display interface', :aggregate_failures do
    expect(presenter.display_name).to eq('Laptop')
    expect(presenter.formatted_price).to eq('$999.99')
    # ... еще 2 проверки для availability и SKU
  end

  # Отдельные тесты для независимого поведения
  context 'when product is out of stock' do
    let(:product) { create(:product, stock: 0) }
    it('indicates unavailability') { expect(presenter.availability).to eq('Out of Stock') }
  end
end
```

Что не так в плохом примере:

- Четыре отдельных теста проверяют части одного интерфейса, который presenter предоставляет на основе одного объекта `product`.
- При изменении источника данных (product) придётся обновлять все четыре теста, хотя они описывают единое поведение.
- Название каждого теста не передаёт, что все атрибуты связаны и формируют целостный интерфейс презентера.

Что даёт хороший пример:

- Один тест с `:aggregate_failures` явно показывает: "presenter предоставляет полный интерфейс отображения".
- Все атрибуты проверяются вместе, потому что они выводятся из одного источника и представляют единое поведение.
- Отдельный контекст для `out of stock` проверяет независимое поведение (изменение логики availability), а не просто другой атрибут.

**Важно:** Не путайте интерфейсное тестирование с проверкой независимых побочных эффектов. Если каждое ожидание описывает самостоятельное бизнес-правило (создание записи + отправка email), разделяйте их на отдельные `it` по основному правилу 2.

#### 2.2. Работа с большими интерфейсами

Когда объект предоставляет 10+ атрибутов, тест с множественными `expect` становится громоздким и сложным для поддержки. Используйте подходящие инструменты в зависимости от типа объекта.

**Для доменных объектов (value objects, presenters, config):**

Используйте `have_attributes` — это компактнее и читаемее, чем список отдельных `expect`.

```ruby
# плохо: длинный список expect
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile', :aggregate_failures do
    expect(profile.first_name).to eq('John')
    expect(profile.last_name).to eq('Doe')
    expect(profile.full_name).to eq('John Doe')
    # ... еще 7 похожих проверок для email, phone, city, country, account_type, verified, created_at
  end
end

# хорошо: компактно через have_attributes
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile' do
    expect(profile).to have_attributes(
      first_name: 'John',
      last_name: 'Doe',
      full_name: 'John Doe'
      # ... остальные атрибуты: email, phone, city, country, account_type, verified
    )
  end
end
```

**Преимущества `have_attributes`:**

- Компактная запись — вся проверка в одном месте
- Автоматический `:aggregate_failures` — показывает все несоответствия сразу
- Читаемый вывод при падении теста

**Для JSON API с большими вложенными структурами:**

Когда ответ API содержит десятки полей и вложенных объектов, проверка всей структуры inline становится нечитаемой. Используйте **декомпозицию через `let`** для управления сложностью.

```ruby
# плохо: вся структура в одном месте — сложно читать
describe 'GET /api/orders/:id' do
  it 'returns order with items and customer' do
    get "/api/orders/#{order.id}"
    
    expect(response.parsed_body).to eq({
      'id' => order.id,
      'status' => 'pending',
      'total' => 150.0,
      'customer' => {
        'id' => customer.id,
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'shipping_address' => {
          'street' => '123 Main St',
          'city' => 'Springfield',
          'postal_code' => '12345',
          'country' => 'USA'
        },
        'billing_address' => { ... }
      },
      'items' => [
        { 'id' => item1.id, 'product_name' => 'Laptop', ... },
        { 'id' => item2.id, 'product_name' => 'Mouse', ... }
      ],
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601
    })
  end
end
```

```ruby
# хорошо: декомпозиция через let — структура плоская и читаемая
describe 'GET /api/orders/:id' do
  let(:order) { create(:order, customer: customer) }
  let(:customer) { create(:customer) }
  let(:item1) { create(:order_item, order: order, product_name: 'Laptop', price: 999.99, quantity: 1) }
  let(:item2) { create(:order_item, order: order, product_name: 'Mouse', price: 25.0, quantity: 2) }

  # Вложенные структуры разнесены по отдельным let
  let(:expected_address) do
    {
      'street' => '123 Main St',
      'city' => 'Springfield',
      'postal_code' => '12345',
      'country' => 'USA'
    }
  end

  let(:expected_customer) do
    {
      'id' => customer.id,
      'name' => 'John Doe',
      'email' => 'john@example.com',
      'shipping_address' => expected_address,
      'billing_address' => expected_address
    }
  end

  let(:expected_items) do
    [
      {
        'id' => item1.id,
        'product_name' => 'Laptop',
        'quantity' => 1,
        'price' => 999.99,
        'subtotal' => 999.99
      },
      {
        'id' => item2.id,
        'product_name' => 'Mouse',
        'quantity' => 2,
        'price' => 25.0,
        'subtotal' => 50.0
      }
    ]
  end

  let(:expected_response) do
    {
      'id' => order.id,
      'status' => 'pending',
      'total' => 150.0,
      'customer' => expected_customer,
      'items' => expected_items,
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601
    }
  end

  it 'returns complete order details' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body).to match(expected_response)
  end
end
```

**Преимущества декомпозиции:**

- Вложенная структура становится плоской и читаемой
- Легко переиспользовать части (например, `expected_address`)
- При изменении структуры ясно, какой блок обновлять
- Сохраняется иерархия: `expected_response` → `expected_customer` → `expected_address`

**Когда использовать декомпозицию через `let`:**

- Проверяете **поведение** — ключевые поля, которые важны для бизнес-логики
- Структура средней сложности (5-20 полей с 2-3 уровнями вложенности)
- Нужна гибкость для динамических значений (`order.id`, `customer.email`)

**Когда НЕ использовать:**

- Проверяете **контракт API** — все поля, типы, обязательность, вложенность
- Структура огромная (50+ полей, глубокая вложенность)
- Важна полная фиксация схемы для внешних потребителей

**Для фиксации полной структуры API используйте специализированные инструменты:**

- **JSON Schema validation** (thoughtbot/json_matchers) — валидация структуры и типов
- **rspec-openapi** — автоматическая генерация OpenAPI из Request specs
- **Snapshot testing** — фиксация эталонного ответа

Подробнее см. раздел ["Тестирование API-контрактов: границы применимости RSpec"](#тестирование-api-контрактов-границы-применимости-rspec).

**Как это снижает когнитивную нагрузку:**
- Один `it` = одно поведение → при падении теста сразу ясно, какое правило нарушено
- Уникальные описания → можно найти нужный тест по названию, не читая код
- Разделение поведений на разные `it` → легко изменить или удалить одно правило, не трогая другие

### 4. Выделяйте характеристики поведения и их состояния

**[Характеристика](#характеристики-и-состояния)** — доменный аспект, который влияет на исход проверяемого поведения (роль пользователя, способ оплаты, статус заказа).

**[Состояние характеристики](#характеристики-и-состояния)** — конкретный вариант этой характеристики, который важен для правила (подписка активна, баланс меньше лимита, статус = shipped).

Как понять, что вы нашли характеристику:

- задайте вопрос: «если изменить этот аспект, ожидание примера изменится?»;
- характеристика описывает бизнес-факт, а не реализацию (`user has subscription`, а не `premium_flag`);
- характеристика формулируется как сущность с уточнением (`user role`, `card balance`).

Как подобрать состояния:

- перечислите все варианты, которые различает бизнес (роль = admin / customer; статус = draft / paid / cancelled);
- числовые величины группируйте в диапазоны, которые влияют на решение (баланс ≥ стоимость, баланс < стоимость);
- каждое состояние выражайте отдельным `context` с ясной формулировкой.

**Как это снижает когнитивную нагрузку:**
- Явное выделение характеристик → тесты читаются как бизнес-правила, а не технические проверки
- Каждое состояние в своём `context` → не нужно держать в голове "а при каких условиях это работает?"
- Характеристики формулируются доменным языком → разработчик и бизнес говорят на одном языке

### 5. Стройте иерархию `context` по зависимостям характеристик (happy path → corner cases)

Характеристики могут быть:

- **базовыми** — без них остальные не имеют смысла (нет карты → нет баланса);
- **уточняющими** — уточняют базовую характеристику (баланс карты при наличии карты);
- **независимыми** — не влияют друг на друга (роль пользователя и флаг beta-теста).

Алгоритм:

1. Выпишите характеристики и состояния.
2. Отметьте зависимости: характеристика B зависит от A, если её состояние осмысленно только при конкретном состоянии A.
3. Постройте таблицу иерархии.
4. Для каждой ветки создайте вложенные `context` от базовой к уточняющей, упорядочив состояния: сначала happy path (нормальный сценарий), затем corner cases (отклонения).

#### Зависимые характеристики (бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Привязка карты | has card / has NO card | — |
| Баланс карты | balance ≥ price / balance < price | Привязка карты (has card) |

```ruby
describe '#purchase' do
  context 'when user has a payment card' do               # happy path: карта привязана
    context 'and card balance covers the price' do        # happy path: баланс достаточен
      it 'charges the card'
    end

    context 'but card balance does NOT cover the price' do # corner case: денег не хватило
      it 'rejects the purchase'
    end
  end

  context 'when user has NO payment card' do              # corner case: карты нет
    it 'rejects the purchase'
  end
end
```

> ```ruby
> # плохо
> describe '#purchase' do
>   context 'but card balance does NOT cover the price' do
>     it 'rejects the purchase'
>   end
>
>   context 'when user has a payment card' do
>     context 'and card balance covers the price' do
>       it 'charges the card'
>     end
>   end
> end
> ```
>
> Что не так:
>
> - Ветка `but ...` оторвана от базового `when user has a payment card`, поэтому happy path и corner case меняются местами.
> - Читателю приходится держать в голове зависимость, которую раньше показывала вложенность: спецификацию становится трудно читать.

#### Независимые характеристики (enum + бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Роль пользователя | admin / customer | — |
| Флаг beta-доступа | enabled / disabled | — |

```ruby
describe '#feature_access' do
  context 'when user role is admin' do        # happy path: полный доступ
    it('grants access to admin tools') { ... }

    context 'and beta feature is enabled' do  # happy path: бонусный доступ
      it('grants access to beta tools') { ... }
    end

    context 'but beta feature is disabled' do # corner case для admin
      it('falls back to standard tools') { ... }
    end
  end

  context 'when user role is customer' do     # corner case: ограниченные права
    it('denies access to admin tools') { ... }

    context 'and beta feature is enabled' do  # corner case: частичное смягчение
      it('grants access to beta tools') { ... }
    end

    context 'but beta feature is disabled' do # самый строгий corner case
      it('denies access to beta tools') { ... }
    end
  end
end
```

Порядок независимых характеристик можно менять (сначала флаг, потом роль), но happy path должен оставаться выше, а отклонения — группироваться ниже на соответствующем уровне вложенности.

**Как это снижает когнитивную нагрузку:**
- Иерархия контекстов визуализирует зависимости характеристик — не нужно держать условия в голове
- Happy path сверху → читатель сразу понимает основной сценарий, не копаясь в отклонениях
- Симметричная структура (все состояния характеристики на одном уровне) упрощает навигацию: "где тест для случая X?" → "на том же уровне, что Y и Z"
- При добавлении нового состояния сразу видно, куда его поместить — структура самодокументируется

### 6. Финальный аудит контекстов: два типа дубликатов

Каждый раз, как вы закончили работу над тестами, убедитесь, что структура `describe/context` реально соответствует [характеристикам](#характеристики-и-состояния) и их [состояниям](#характеристики-и-состояния) из глоссария (см. пункт 5). Финальный аудит включает два типа проверок: дубликаты `let`/`before` выдают пропущенные состояния характеристик, а дубликаты `it` с одинаковыми ожиданиями выдают инвариантные контракты интерфейса.

#### 6.1. Дубликаты `let`/`before` выдают пропущенные состояния

Повторяющиеся `let` или `before` на одном уровне — тревожный сигнал: какое-то состояние не вынесено в явный контекст, и тест для него легко потерять.

Чек-лист после написания:

- Пройдитесь по каждому уровню вложенности и выпишите все `let`/`before`. Если в соседних ветках повторяются одинаковые значения, характеристику нужно поднять выше или вынести в отдельный контекст.
- Попробуйте поднять общий `let` на уровень выше. Если тесты после этого рушатся, значит, вы обнаружили скрытое состояние — добавьте для него контекст и пример.
- Сверьте структуру с первоначальным списком характеристик и их состояний. Если какое-то состояние нигде не проявилось, сценарий для него пропущен.
- Посмотрите на `before`-блоки. Повторяющаяся подготовка данных — частый признак того, что вы оставили только happy path и забыли про ветку с альтернативным контекстом.

```ruby
# плохо
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :usd }

      it 'returns 0.15' do
        expect(discount).to eq(0.15)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :usd }

      it 'returns 0.10' do
        expect(discount).to eq(0.10)
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :eur }

      it 'returns 0.12' do
        expect(discount).to eq(0.12)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :eur }

      it 'returns 0.05' do
        expect(discount).to eq(0.05)
      end
    end
  end
end
```

```ruby
# хорошо
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.15') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.10') { ... }
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.11') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.06') { ... }
      end
    end

    context 'with EUR currency' do
      let(:currency) { :eur }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.12') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.05') { ... }
      end
    end
  end
end
```

`Что` не так в плохом примере:

- По описанию всё похоже на правильную иерархию из пункта 4, но `currency` в каждой ветке задаётся вручную, значит, характеристика фактически «живёт» не там, где описана.
- Для состояния `currency: :usd` в сегменте `:b2b` пример отсутствует — дефект пройдёт мимо, потому что тесты читаются как полная спецификация.

Теперь:

- Валюта занимает своё место в иерархии, дубликаты `let` исчезли, и структура повторяет реальные зависимости характеристик (см. пункт 5).
- Каждая комбинация `segment → currency → loyalty_status` из предметной модели имеет пример, а отдельный corner case фиксирует негативное поведение.
- Формулировки контекстов складываются в читаемые предложения, и happy path стоит выше corner case (см. пункт 7), поэтому сценарии считываются быстро.
- При появлении нового состояния чек-лист сработает автоматически: вы либо добавите контекст, либо заметите, что возврат к общему `let` ломает тест.

#### 6.2. Дубликаты `it` с одинаковыми ожиданиями выдают инвариантные контракты

После построения симметричного дерева контекстов (пункт 5) и устранения дубликатов `let`/`before` (пункт 6.1), просмотрите все листовые контексты. Если несколько `it` повторяются с одинаковыми ожиданиями во всех или большинстве листовых контекстов — это инварианты интерфейса: правила, которые не зависят от состояний характеристик и должны выполняться всегда.

Чек-лист после написания:

1. Просмотрите все листовые контексты и выпишите все `it`.
2. Найдите ожидания, которые повторяются дословно или с минимальными вариациями.
3. Если ожидание присутствует во всех листовых контекстах, независимо от характеристик — это инвариант интерфейса.
4. Вынесите инвариантные ожидания в `shared_examples` и подключите их через `it_behaves_like` (см. пункт 25.2).

Пример см. в пункте 22.2 — класс `BookingSearchValidator`, где проверки `respond_to(:valid?)`, `respond_to(:errors)`, `respond_to(:normalized_params)` повторялись во всех четырёх листовых контекстах независимо от `client_type` и `region`. Это инварианты интерфейса, которые были вынесены в `shared_examples 'a booking search validator'`.

Такой финальный проход заставляет держать тесты на уровне поведенческого контракта, а не набора случайных happy path.

### 7. Располагайте happy path перед corner cases

Внутри каждого `describe` читающий ожидает увидеть нормальное поведение первым, а уже затем — исключения.

```ruby
# плохо
describe '#enroll' do
  context 'when enrollment is rejected because email is invalid' do
    it('shows a validation error') { ... }
  end

  context 'when enrollment is rejected because plan is sold out' do
    it('puts the user on the waitlist') { ... }
  end

  context 'when enrollment is accepted' do # happy path затерян внизу
    it('activates the membership') { ... }
  end
end
```

```ruby
# хорошо
describe '#enroll' do
  context 'when enrollment is accepted' do
    it('activates the membership') { ... }
  end

  context 'when enrollment is rejected because email is invalid' do
    it('shows a validation error') { ... }
  end

  context 'when enrollment is rejected because plan is sold out' do
    it('puts the user on the waitlist') { ... }
  end
end
```

Что не так в плохом примере:

- Happy path спрятан внизу ветки, из-за чего читатель тратит больше времени, чтобы понять нормальное поведение.
- При появлении новых corner cases порядок ещё сильнее смешается, и отчет RSpec перестанет читаться сверху вниз.

Инструкция: добавляя новые примеры, проверьте, что блоки happy path остаются первыми на своем уровне вложенности. Corner cases должны находиться ниже и либо начинаться с `but`/`without`, либо явно описывать отклонение.

**Как это снижает когнитивную нагрузку:**
- Happy path сверху → читатель сразу понимает основной сценарий работы системы
- Предсказуемый порядок (успех → отклонения) → не нужно прыгать по файлу в поисках "как оно должно работать в норме?"
- Отчёт RSpec читается сверху вниз как история: сначала норма, потом исключения

### 8. Пишите положительный и отрицательный тест

Каждая ветка контекстов описывает конкретное сочетание состояний характеристик. Для этих сочетаний нужен минимум один пример, подтверждающий поведение, и один пример, показывающий отказ — так мы защищаемся от регрессий в обе стороны.

```ruby
# плохо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }

  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния `blocked = true`
    let(:blocked) { true }

    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... настройка уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to be(true) # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  
  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { true }

    # Контекст 2 уровня для состояния характеристики `blocked_at`
    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }
      it("allows unlocking the user") { ... }
    end

    context "but blocking duration is under a month" do # отрицательный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 1.month.ago }
      it("does NOT allow unlocking the user") { ... }
    end
  end

  context "when user is NOT blocked by admin" do # отрицательный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { false }
    it("does NOT allow unlocking the user") { ... }
  end
end
```

Что не так в плохом примере:

- Характеристика `blocked` проверяется только на положительном состоянии — защита от обратного сценария отсутствует.
- Уточняющий контекст не показывает альтернативное состояние `blocked_at`, поэтому пропущен отрицательный тест для сочетания состояний.
Если присутствуют только положительные тесты, то в дальнейшем на такие тесты нельзя полагаться,
ввиду того, что они не отразят факта регрессии поведения при дальнейших изменениях в коде,
так как они не будут проверять обратный случай.

### 9. Каждый контекст должен отражать различие вложенной части от внешней

Можно ещё сказать так: если у вас есть контекст, внутри которого между `context "..." do` и `it` пусто, это чисто
синтаксический контекст. Он либо не нужен вовсе, либо не содержит настройки, соответствующей описанию контекста.

Правило можно сформулировать иначе: настройка, которая делает контекст истинным, должна находиться сразу после строки `context "..." do`.
Не заставляйте читателя искать по всему тесту, где именно готовится контекст под описанное состояние.

```ruby
# Есть пользователи и метод some_action, позволяющий определить, можно ли пользователя разблокировать.
# У пользователей есть состояния `blocked`, `blocked_at`.
```

```ruby
# очень плохо
describe "#some_action" do
  let(:user) { build :user }
  let(:blocked_user) { build :user, blocked: true }
  let(:old_blocked_user) { build :user, blocked: true, blocked_at: 2.month.ago }

  it "does NOT allow unlocking the user" do
    expect(user.some_action).to be(false)
  end
  
  context "when user is blocked by admin" do # есть контекст
    # нет никакой настройки, которая делает его отличным от внешнего блока
    it "allows unlocking the user" do
      expect(blocked_user.some_action).to be(true)
    end
    
    context "and blocking duration is over a month" do 
      # Что отличает этот контекст от внешнего? В большом тесте искать настройку будет невозможно.
      # Экономьте свой и чужой труд — размещайте блок, который готовит контекст, сразу под объявлением: там его и ожидают увидеть.
      it "allows unlocking the user" do
        expect(old_blocked_user.some_action).to be(true)
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  let(:blocked) { false } # базовое состояние характеристики `blocked`
  let(:blocked_at) { nil } # базовое состояние характеристики `blocked_at`
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  subject(:result) { user.some_action }

  it "does NOT allow unlocking the user" do
    expect(result).to be(false)
  end

  context "when user is blocked by admin" do
    let(:blocked) { true } # настройка этого контекста — на своём месте, сразу заметна

    context "and blocking duration is over a month" do
      let(:blocked_at) { 2.month.ago } # настройка вложенного контекста — здесь же, под объявлением

      it "allows unlocking the user" do
        expect(result).to be(true)
      end
    end

    context "but blocking duration is under a month" do
      let(:blocked_at) { 1.month.ago } # отрицательное состояние характеристики `blocked_at`

      it "does NOT allow unlocking the user" do
        expect(result).to be(false)
      end
    end
  end
end
```

Что не так в плохом примере:

- Контекст `when user is blocked by admin` не задаёт отличающих условий — настройка `let` находится далеко и не читается вместе с описанием.
- Внутренний `context` не подготавливает `blocked_at`, поэтому сложно понять, какое состояние характеристики проверяется.

Кроме того, требуемое состояние может задаваться вычислением — например, располагаться внутри `before`.

## Синтаксис и читаемость

Хороший стиль тестов — это не только поведение, но и очевидность того, что читаешь: явный `subject`, предсказуемые конструкции и минимум поиска глазами.

### 10. Указывайте `subject`, чтобы явно обозначить предмет тестирования

Когда `subject` явно объявлен, читатель сразу видит, что именно проверяется, и не тратит время на поиск объекта тестирования в ожиданиях.

`subject` особенно полезен:

- Когда один и тот же результат проверяется в нескольких `it` внутри разных контекстов
- Когда действие требует подготовки или вызова метода с параметрами
- Когда нужно дать имя проверяемому результату через именованный `subject(:result)`

**Как это снижает когнитивную нагрузку:**
- Явный `subject` → сразу видно, что тестируется, не нужно искать объект в каждом `expect`
- Именованный `subject(:result)` → описательное имя заменяет повторяющиеся вызовы метода
- Структура теста становится предсказуемой → меньше времени на понимание

## Подготовка контекста и данных

Гладкие тесты строятся на повторяемом сетапе: чётких фазах Given/When/Then, фабриках, которые прячут рутину, и явных зависимостях. Этот раздел собирает практики подготовки окружения перед проверками.

### 11. Каждый тест должен быть разделен на 3 этапа в строгой последовательности

`let` и `let!` подготавливают данные, которые делают контекст истинным (Given), `before` доводит систему до нужного состояния или вызывает действие (When), а ожидания внутри `it` фиксируют результат (Then). Не смешивайте эти роли.

1. Подготовка данных для контекста (обычно через `let` или фабрики)
2. Перевод данных в нужное состояние/вызов действия (чаще `before`, иногда прямо в `it`)
3. Ожидание результата (Then)

```ruby
# очень плохо
describe "#block" do
  before do
    user = create :user # тестовые данные
    admin = create :admin # тестовые данные
    admin.block(user) # действие
  end

  it "true" do
    expect(User.find(1).bloсked).to be(true) # ожидание
  end
end
```

```ruby
# хорошо
describe "#block" do
  # 1 этап
  let(:user) { create :user } # создание тестовых данных
  let(:admin) { create :admin }

  # 2 этап
  before { admin.block(user) } # действие/операция

  # 3 этап
  it "marks the user as blocked" do
    expect(user.blocked).to be(true) # ожидание
  end
end
```

Вариант с действием внутри примера:

```ruby
# нормально
describe "#block" do
  # 1 этап
  let(:user) { create :user }
  let(:admin) { create :admin }

  it "marks the user as blocked" do
    # 2 этап
    admin.block(user)

    # 3 этап
    expect(user.blocked).to be(true)
  end
end
```

Что не так в плохом примере:

- Этапы Given/When/Then смешаны внутри `before`, из-за чего непонятно, где заканчивается подготовка и начинается проверка.
- Тест обращается к `User.find(1)` вместо подготовки контекста через `let`, поэтому пример зависит от глобального состояния.

Даже если действие выполняется прямо в `it`, держите структуру явной и возвращайте вычисления в `before`, когда это возможно.

- `let` ленивый: значение вычисляется при первом обращении. Если состояние контекста должно появиться до выполнения `it`, используйте `before` или `let!`, чтобы явно зафиксировать порядок и не нарушать этапы правила 8.

**Как это снижает когнитивную нагрузку:**
- Предсказуемая структура (Given → When → Then) → читатель знает, где искать подготовку, действие, проверку
- Не нужно "выполнять код в голове", чтобы понять порядок выполнения
- При изменении теста сразу ясно, в какую секцию добавлять код

### FactoryBot и подготовка данных

FactoryBot помогает описывать [характеристики](#характеристики-и-состояния) доменных объектов через трейты и параметризованные хэши, поэтому используем его, чтобы тесты говорили о [поведении](#основные-понятия), а не о технических атрибутах.

#### 12. Используйте возможности FactoryBot для скрытия деталей исходных данных

Если в проекте есть FactoryBot, используйте его, чтобы тесты оставались читабельными и фиксировали только [характеристики](#характеристики-и-состояния) и их [состояния](#характеристики-и-состояния).

- Дефолтная фабрика должна создавать «средний» объект, который подходит для happy path. Всё, что не участвует в описании контекста, прячьте внутрь фабрики.
- В повторяющихся сценариях оформляйте состояния через трейты: `:blocked`, `:with_verified_email`, `:expired`. Трейты можно свободно комбинировать (`create(:user, :blocked, :verified)`), получая нужные состояния без копипаста. Контексту не нужно перечислять вспомогательные поля, достаточно упомянуть характеристику.
- Избегайте ручной передачи десятков атрибутов в `create`. Если требуется много явных значений, возможно, фабрику стоит уточнить или выделить новую характеристику.

```ruby
# плохо
describe '#unlock' do
  let(:user) do
    create(:user,
           blocked: true,
           blocked_at: 2.months.ago,
           email_confirmed: true
           # ... еще 2 атрибута: last_sign_in_at, otp_required
    )
  end

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

```ruby
# хорошо
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { 'secret123' }

    trait :blocked do
      blocked { true }
      blocked_at { 2.months.ago }
    end

    trait :verified do
      email_confirmed { true }
    end
  end
end

describe '#unlock' do
  let(:user) { create(:user, :blocked, :verified) }

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

- Трейты документируют состояния характеристик и избавляют от громоздких setup-блоков.
- Читатель видит только важные аспекты (`:blocked`, `:verified`) и быстро соотносит их с описанием контекста.
- Изменения дефолтных атрибутов происходят в фабрике, поэтому тесты не «захламляются» техническими деталями данных.
- Что не так в плохом примере: фабрика используется как `create` со всеми атрибутами, поэтому тест не показывает, какие состояния важны; любое изменение вспомогательных полей требует менять тест, а не фабрику.

Такая дисциплина делает тесты чище, легче для поддержки и лучше подчёркивает бизнес-поведение.

Дополнительно: хороший обзор приёмов работы с трейтами есть у Thoughtbot — [Remove duplication with FactoryBot’s traits](https://thoughtbot.com/blog/remove-duplication-with-factorybots-traits).

#### 13. Используйте `attributes_for` для генерации параметров, которые не являются важной деталью в тестировании поведения

При тестировании поведения часто важен сам факт выполнения действия (создание заказа, обновление профиля), а не конкретные значения большинства атрибутов. `attributes_for` позволяет сгенерировать валидный хэш параметров из фабрики, избегая дублирования между фабрикой и тестом.

**Ключевой принцип:** Используйте `attributes_for`, когда конкретные значения атрибутов не важны для понимания проверяемого поведения. Если атрибут критичен для теста — переопределите его явно.

#### Основной use case: Request specs

Request specs — наиболее частое место применения `attributes_for`, так как API-эндпоинты принимают хэши параметров.

```ruby
# плохо
describe 'POST /api/orders' do
  let(:order_params) do
    {
      customer_email: 'user@example.com',
      total: 150.0
      # ... еще 2 поля: currency, status
    }
  end

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('returns order id') { expect(response.parsed_body['id']).to be_present }
end
```

```ruby
# хорошо
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order) }
  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('returns order id') { expect(response.parsed_body['id']).to be_present }
end
```

**Что не так в плохом примере:**

- Значения `customer_email`, `total`, `currency`, `status` не важны для понимания теста "API создаёт заказ"
- Дублирование: те же атрибуты уже определены в `factory :order`
- Читатель вынужден анализировать каждый атрибут, хотя они не влияют на проверяемое поведение
- При изменении дефолтных значений в фабрике нужно менять и тест

**Теперь:**

- Читатель сразу видит: "используются стандартные параметры заказа"
- Не нужно анализировать несущественные детали
- Нет дублирования между фабрикой и тестом
- Изменения дефолтных значений в фабрике автоматически применяются к тесту

#### Переопределение критичных атрибутов

Если конкретное значение атрибута **важно для проверяемого поведения**, переопределите его явно:

```ruby
# хорошо: явно показываем, что тестируем b2b-сегмент
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order, segment: 'b2b', discount: 0.15) }
  before { post '/api/orders', params: order_params }

  it('applies b2b pricing') { expect(Order.last.pricing_tier).to eq('corporate') }
  it('applies 15% discount') { expect(Order.last.final_total).to eq(order_params[:total] * 0.85) }
end
```

Здесь `segment: 'b2b'` и `discount: 0.15` — критичные детали поведения, поэтому они явно переопределены.

#### Комбинирование с трейтами

```ruby
# хорошо: трейт документирует состояние
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order, :international, :with_insurance) }

  before { post '/api/orders', params: order_params }

  it('includes customs declaration') { expect(Order.last.customs_required?).to be true }
end
```

Трейты `:international` и `:with_insurance` ясно показывают характеристики заказа без необходимости перечислять десятки атрибутов.

#### Другие use cases

`attributes_for` полезен везде, где код работает с хэшами параметров:

**Form Objects:**

```ruby
describe OrderForm do
  let(:form_params) { attributes_for(:order) }
  let(:form) { described_class.new(form_params) }

  it('validates successfully') { expect(form).to be_valid }
end
```

**Service Objects:**

```ruby
describe OrderCreationService do
  let(:order_params) { attributes_for(:order) }

  it('creates order record') { expect { described_class.call(order_params) }.to change(Order, :count).by(1) }
end
```

#### Когда НЕ использовать `attributes_for`

❌ **НЕ ИСПОЛЬЗУЙТЕ когда:**

**Интерфейс API отличается от интерфейса модели** — параметры запроса имеют другие названия или структуру:

```ruby
# плохо: attributes_for возвращает атрибуты модели, а API ожидает другие названия
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order) }  
  # factory возвращает: { customer_email: '...', total_cents: 15000 }
  # но API ожидает:     { email: '...', amount: 150.0 }

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) } # упадёт: неправильные параметры
end
```

```ruby
# хорошо: явно формируем параметры согласно API-контракту
describe 'POST /api/orders' do
  let(:order_params) do
    {
      email: 'user@example.com',      # API использует 'email', а модель 'customer_email'
      amount: 150.0                    # API использует 'amount' в рублях, а модель 'total_cents'
    }
  end

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('maps API params to model attributes') { expect(Order.last).to have_attributes(...) }
end
```

**Золотое правило:** Если для понимания теста читатель должен открыть фабрику — значит, критичные параметры лучше прописать явно в тесте. Используйте `attributes_for` для снижения дублирования, но не в ущерб читаемости.

#### 14. В юнит-тестах (кроме моделей) используйте `build_stubbed`

Юнит-спеки сервисов, политик, presenter'ов и form-объектов не должны зависеть от базы данных. `build_stubbed` создаёт объект ActiveRecord без `INSERT`/`UPDATE`, но с заполненными `id`, `created_at`, `updated_at` и запретом на `save`. Это делает тесты быстрее и подчёркивает, что код работает с готовым контекстом, а не строит интеграцию с БД.

- `build_stubbed` избавляет от лишних раунд-трипов к БД и ускоряет пакет модульных тестов.
- Объект невозможно случайно сохранить: если код пытается вызвать `save`/`reload`, тест упадёт и покажет, что вы пересекаете границу уровня (значит, нужен интеграционный тест).
- Stubbed-экземпляры удобнее подменять в doubles: у них есть `id`, предзаполненные атрибуты и отключены callbacks, поэтому тест остаётся предсказуемым.

Когда `build_stubbed` использовать не стоит:

- тест модели или скоупа, где нужно проверить реальное взаимодействие с БД;
- код, который опирается на callbacks/триггеры или читает изменения после `save`;
- фича, где валидация/уникальность/foreign key проверяются именно БД (тогда используйте `create`).

```ruby
# плохо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { create(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  it 'schedules confirmation email' do
    allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer)

    expect { call }.not_to change(Order, :count)
    expect(mailer).to have_received(:deliver_later)
  end
end
```

```ruby
# хорошо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { build_stubbed(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  before { allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer) }

  it 'schedules confirmation email' do
    call
    expect(mailer).to have_received(:deliver_later)
  end
end
```

Что не так в плохом примере:

- `create` выполняет запись в базу ради данных, которыми сервис только пользуется; тесты замедляются без необходимости.
- Если реализация вызовет `save`/`reload`, тест этого не увидит, потому что объект уже живёт в БД — мы незаметно проверяем интеграционный сценарий.

Что даёт хороший пример:

- `build_stubbed` создаёт полноценный объект без обращения к БД, поэтому юнит-спеки бегут быстрее и остаются изолированными.
- Попытка сохранить объект из тестируемого кода завершится ошибкой, сигнализируя, что сценарий перешёл границу уровня и нужен интеграционный тест.

Если тест неожиданно требует `save` или чтения из базы, значит, вы тестируете поведение более высокого уровня — перенесите пример в интеграционный слой или поменяйте стратегию подготовки данных.

**Как FactoryBot снижает когнитивную нагрузку:**
- **Трейты** — имя трейта описывает [состояние](#характеристики-и-состояния) модели (`:blocked`, `:verified`) → читатель видит [характеристику](#характеристики-и-состояния), не погружаясь в детали реализации
- **Технические детали** спрятаны в фабрике → не нужно держать в голове "а зачем здесь все эти поля?"
- **attributes_for** фокусирует на проверяемом [поведении](#основные-понятия) → не нужно анализировать несущественные параметры
- **build_stubbed** явно сигнализирует "это юнит-тест" → сразу понятен уровень изоляции
- **Централизация [характеристик](#характеристики-и-состояния)** → все технические детали реализации характеристики находятся в фабрике, изменения требуют правок в одном месте, а не в десятках тестов
- **Изменения атрибутов по умолчанию** не ломают тесты → меньше ментальной нагрузки при рефакторинге

### 15. Не программируйте в тестах

Тест — это спецификация поведения, а не место для написания мини-фреймворков. Когда вместо декларативных `let`, фабрик и helper-методов появляются приватные утилиты с прямой работой с БД, тест перестаёт быть читаемым и надёжным.

```ruby
# ужасно
describe SomeService do
  it 'stores report' do
    result = described_class.call(raw_payload)

    expect(result).to be_success
    expect(find_report(result.id)).to have_attributes(status: 'done', rows: 3)
  end

  private

  def raw_payload
    DB[:reports].insert(name: 'daily', data: '{"rows":[1,2,3]}')
    DB[:reports].where(name: 'daily').first
  end

  def find_report(id)
    DB[:reports].where(id: id).first
  end
end
```

```ruby
# хорошо
describe SomeService do
  let(:report) { create(:report, :daily, :with_rows) }
  subject(:result) { described_class.call(report.payload) }

  it 'stores report' do
    expect(result).to be_success
    expect(report.reload).to have_attributes(status: 'done', rows_count: 3)
  end
end
```

Что не так в плохом примере:

- Приватные методы скрывают, как задаются состояния: читателю нужно «выполнить» код в голове, чтобы понять характеристики.
- Прямая работа с БД минует фабрики/фикстуры и создаёт жёсткую привязку к схеме.
- При изменении структуры таблиц тесты ломаются молча или дают нечитаемые ошибки.
- Если подобный стиль кажется удобным, это тревожный сигнал: такая запись тяготеет к assert-style-DSL вроде minitest. В RSpec же мы описываем поведение, а не переписываем код тестового фреймворка.

Что даёт хороший пример:

- `let` с фабрикой явно описывает характеристику (`report` со статусом и данными), а не SQL-обходные пути.
- При смене схемы адаптируем фабрику — тесты остаются декларативными и следуют глоссарию характеристик.

Это правило тесно связано с пунктами 1, 7 и 8: мы описываем поведение, проверяем обе стороны правила и держим подготовку контекста рядом с его описанием.

### 16. Явность важнее DRY

В BDD-тестах важно, чтобы было сразу видно ЧТО проверяется. Читаемость и понятность спецификации важнее устранения дублирования кода. Если extraction метода или переменной делает тест менее очевидным — оставьте дублирование.

Тесты — это документация поведения системы. Когда читатель открывает spec-файл, он должен сразу понимать контекст и проверяемое поведение, не прыгая по определениям вспомогательных методов.

Конечно, это не значит отказ от `let`, фабрик или shared contexts — они как раз помогают декларативно описать характеристики. Но если абстракция скрывает важную деталь проверки, лучше написать явно.

**Важно:** Этот пункт требует выбора золотой середины. Всегда можно дискутировать, где проходит граница между полезной абстракцией и избыточной явностью. Нет универсального правила — решение зависит от контекста, сложности домена и договорённостей команды.

**Как это снижает когнитивную нагрузку:**
- **Единый DSL RSpec** — все знают этот язык тестирования, не нужно изучать каждый раз новый "диалект"
- **Программирование в тестах** создаёт собственный мини-язык → команде приходится изучать custom API каждого spec-файла
- **Интеграция с экосистемой** — RSpec DSL даёт понятный вывод при падении, custom код выдаёт невнятные ошибки
- **Согласованность синтаксиса** — `let`, фабрики, матчеры работают предсказуемо, приватные методы с БД-логикой нарушают ожидания

## Язык описания спецификаций

### 17. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны составлять валидное предложение на английском языке

Описание спецификаций (`describe`/`context`/`it`) пишите по-английски: так отчёты RSpec остаются читаемыми в CI, а команда использует единый язык описания поведения.
Для примера оставим только описание тестов, без примера создания тестовых данных и изменений в контекстах.

```ruby
# отвратительно
describe "#some_action" do
  context "blocked" do # что заблокировано, когда, кем? что это вообще значит?
    context "month ago" do # месяц назад что? заблокирован? точно?
      it("true") { test } # что значит true? как оно оценивается?
    end
  end
end
# когда вы запустите тест он вернет вот такое непонятное описание
# #some_action user blocked month ago /it/ true

# идеально
describe "#some_action" do
  context "when user is blocked by admin" do # здесь понятно, кто, что и с кем сделал
    context "and blocking duration is over a month" do # а здесь уже понятно что это продолжение предложения, начатого в прошлом контексте
      it("allows unlocking the user") { test } # ага, теперь вообще понятно, зачем этот метод нужен, в чем его ценность
      # он определяет "можно ли разблокировать пользователя?"
    end
  end
end
# #some_action when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user 
```

Что не так в плохом примере:

- Контексты не складываются в цельное предложение: непонятно, кто заблокирован и что означает `month ago`.
- Описание `it("true")` не рассказывает о поведении, поэтому отчёт RSpec не несёт смысла.

### 18. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны быть написаны так, чтобы их понимал любой человек

Здесь имеется ввиду, что описание поведения должно быть абсолютно однозначно понятным и не требующим познания чего-то специфичного из программирования.
Вы должны быть в состоянии просто дать все описания тестов любому человеку, для того чтобы он в свою очередь прочитав их мог понять бизнес.

```
when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user
when user is blocked by admin but blocking duration is under a month /it/ does NOT allow unlocking the user
```

вполне понятное описание, по которому однозначно понятно, что разблокировать пользователя заблокированного менее месяца назад нельзя.

### 19. Грамматика формулировок в describe/context/it

Мы описываем устойчивое поведение системы, поэтому формулировки должны звучать как правила предметной области, а не как инструкции тестировщику.

1. **Present Simple.** Поведение считается верным всегда, поэтому говорим о нем в настоящем времени: `it 'returns the summary'`. Настоящее простое время делает фразу универсальной и убирает ощущение временности.
2. **Активный залог в `it`, третье лицо.** Субъектом предложения выступает объект системы: `order generates invoice`, `service authenticates user`. Так читающий понимает, кто выполняет действие, и предложение остается коротким.
3. **Пассивный залог и глаголы-состояния для контекстов.** Контекст задает состояние характеристики, поэтому используем форму `is/are + V3` или короткие конструкции со статичным глаголом: `when user is blocked`, `when account has balance`. Так мы фиксируем факт состояния, а не действие, которое к нему привело.
4. **Zero conditional для связки контекста и результата.** В паре `context/it` обе части остаются в Present Simple: `when payment is confirmed, it issues receipt`. Такая структура читается как бизнес-правило «если … то …» без временных сдвигов.
5. **Без модальных глаголов и лишних слов.** Избегаем `should`, `can`, `must` и вводных конструкций (`it should`, `it is expected that`). Остается декларация поведения — она короче и лучше ложится в отчеты.
6. **Явное отрицание `NOT`.** Негативные сценарии выделяем капсом: в контекстах — `when user is NOT verified`, в примерах — `it 'does NOT unlock user'`. Так в отчете сразу видно, что падает отрицательный кейс.

Минимальный шаблон: объект и характеристику описываем в `describe`, контекст — через `context` в пассивном залоге, ожидаемую реакцию — через `it` в активном Present Simple.

```ruby
describe OrderMailer do
  context 'when invoice is generated' do
    it 'sends the invoice email'
  end
end
```

### 20. Язык контекстов: when / with / and / without / but / NOT

Следуем логике Gherkin, чтобы ветка читалась как последовательность уточнений контекста. Каждая связка отвечает типу состояния и уровню вложенности.

- **`when …`** — открывает ветку и описывает состояние базовой характеристики. На этом уровне часто нет `it`, потому что дальше ветка уточняется. Пример: `context 'when user has a payment card' do … end`.
- **`with …`** — вводит первое уточняющее положительное состояние и продолжает happy path: `context 'with verified email'`.
- **`and …`** — добавляет ещё одно положительное состояние в том же направлении. Можно использовать несколько подряд, пока ветка остаётся частью happy path: `context 'and balance covers the price'`.
- **`without …`** — используем для бинарных характеристик, когда явно показываем обе полярности. Happy path описан положительным состоянием, поэтому ветка `without …` сразу содержит тест, демонстрирующий альтернативный исход: `context 'without verified email' do … end`.
- **`but …`** — подчёркивает противопоставление happy path. Часто применяется, когда happy path основан на состоянии по умолчанию (отдельный `with`-контекст не нужен). Контекст `but …` обязан содержать тест, показывающий, как меняется поведение, когда базовый контекст перестаёт выполняться: `context 'but balance does NOT cover the price'`.
- **`NOT`** — используем капсом внутри названия контекста или `it`, чтобы подчеркнуть отрицательное состояние бинарной характеристики либо выделить отрицательный тест: `context 'when user does NOT have a payment card'`, `it 'does NOT charge the card'`.
- Если в описании `it` появляется `when`/`with`/`and`/`without`/`but`, значит, вы потеряли соответствующий контекст. Вынесите это состояние в `context`, иначе пример будет смешивать Given и Then и нарушит правила 1–7. Исключение — отрицательные формулировки с `does NOT`, где `NOT` подчёркивает результат, а не контекст.

Рекомендуемая последовательность внутри ветки: `when` → `with` → `and` (по необходимости) → `but`/`without` → `it`. Как только контекст полностью подготовлен, добавляем пример: happy path или corner case.

```ruby
describe '#charge' do
  context 'when user has a payment card' do                      # базовая характеристика
    context 'with verified email' do                            # happy path уточнение
      context 'and balance covers the price' do                 # ещё одно happy path состояние
        it 'charges the card'                                   # happy path case
      end

      context 'but balance does NOT cover the price' do         # corner case: противопоставление
        it 'does NOT charge the card'                           # отрицательный тест
      end
    end

    context 'without verified email' do                         # corner case: отсутствие обязательного состояния
      it 'does NOT charge the card'
    end
  end

  context 'when user does NOT have a payment card' do           # другая ветка для бинарной характеристики
    it 'does NOT charge the card'
  end
end
```

Следите, чтобы happy path ветка шла первой на своём уровне, а контексты с `without`/`but` логически ссылались на неё: «когда всё хорошо → что происходит; но если базовый контекст ломается → как меняется результат».

Иногда happy path строится на значении по умолчанию, и дополнительный `with`-контекст не нужен — пример можно разместить сразу под `when`. Corner case всё так же раскрывается через `but` или `without` на том же уровне.

```ruby
describe '#authenticate' do
  context 'when account exists' do                        # базовая ветка
    it 'signs the user in'                                # happy path сразу под when

    context 'but account is blocked' do                   # corner case на том же уровне
      it 'denies the sign-in'
    end
  end

  context 'when account does NOT exist' do                # противопоставление на уровне контекста
    it 'denies the sign-in'
  end
end
```

### 21. Изучите подробно правила из rubocop по части наименования <https://rspec.rubystyle.guide/#naming>

## Инструменты и поддержка тестов

### 22. Не используйте [any_instance](https://rspec.info/features/3-13/rspec-mocks/old-syntax/any-instance/), allow_any_instance_of, expect_any_instance_of

В большинстве случаев это "запах" к тому, что вы не следуете `dependency inversion principle`,
или, что ваш класс не следует `single responsibility` и объединяет в себе код для двух акторов,
которые в свою очередь зависят друг от друга в одностороннем порядке.
Таким образом, ваш класс можно разбить на два класса поменьше, для которых в свою очередь можно покрыть тестами их поведение в отдельных тестах.
Справедливости ради, следовать этому правилу не очень просто тогда, когда у вас накопился гигантский технический долг, поэтому это правило может иметь исключения.

Подробнее о том, почему его не стоит использовать, читайте здесь <https://rspec.info/features/3-13/rspec-mocks/working-with-legacy-code/any-instance/>.

```ruby
# плохо: allow_any_instance_of глобально мокает все экземпляры
describe HighLevelClass do
   before do
      allow_any_instance_of(LowLevelClass).to receive(:foo).and_return({some_key: :some_value})
   end

   it "returns the processed value" do
      expect(HighLevelClass.new.some_method).to eq(:some_expected_value)
   end
end

# хорошо: инъекция зависимости через конструктор
describe HighLevelClass do
   let(:low_level_dependency) { instance_double(LowLevelClass) }
   subject(:instance) { described_class.new(low_level_dependency) }

   before do
      allow(low_level_dependency).to receive(:foo).and_return({some_key: :some_value})
      # теперь мы просто разрешаем вернуть нужное нам значение одному instance double
      # причем будет проверка что такой метод действительно есть у данного класса
   end

   it "returns the processed value" do
      expect(instance.some_method).to eq(:some_expected_value)
   end
end
```

Что не так в плохом примере:

- `allow_any_instance_of` глобально подменяет метод `foo` и затрагивает все экземпляры класса, из-за чего тест перестает быть изолированным.
- Класс не принимает зависимость явно, поэтому приходится пробивать мок через глобальную настройку, вместо того чтобы внедрить ее через конструктор.

### 23. Используйте `:aggregate_failures` только когда описываете одно правило

По умолчанию один `it` содержит одну проверку. `:aggregate_failures` полезен, когда мы говорим об одном поведении и хотим увидеть все нарушения сразу, вместо того чтобы фиксировать только первое упавшее ожидание.

**Ключевой принцип:** Используйте `:aggregate_failures` только если все ожидания описывают один и тот же бизнес-исход и зависят от одного набора подготовленных состояний контекста. Не применяйте флаг, чтобы спрятать разные поведения в одном `it` — так вы нарушаете правило 3.

#### Зачем нужен `:aggregate_failures`: практическая проблема

Без `:aggregate_failures` RSpec останавливается на первом упавшем ожидании. Это создаёт дорогостоящий цикл отладки, особенно в следующих сценариях:

**Сценарий 1: [Flaky-тесты](#характеристики-и-состояния), которые падают только в CI**

Представьте: у вас есть тест API-эндпоинта, который иногда падает только в CI-окружении (проблемы с таймингами, race conditions, особенности базы данных). Локально воспроизвести не получается, и каждая итерация отладки через CI занимает 10-15 минут.

```ruby
# без aggregate_failures
it 'returns order details' do
  get "/api/orders/#{order.id}"
  
  expect(response).to have_http_status(:ok)           # ✅ прошло
  expect(response.content_type).to match(/json/)      # ✅ прошло
  expect(response.parsed_body['id']).to eq(order.id)  # ❌ ПАДЕНИЕ: nil вместо order.id
  # Тест останавливается здесь. Вы не знаете про остальные поля
  expect(response.parsed_body['status']).to eq('pending')
  expect(response.parsed_body['total']).to eq(150.0)
  expect(response.parsed_body['customer_email']).to be_present
end
```

**Что происходит:**

1. CI падает: "expected order.id, got nil"
2. Видя только одну ошибку, вы предполагаете: "наверное, проблема с ID в маршруте". Исправляете логику получения `order.id`, пушите, ждёте 15 минут
3. CI падает снова: "expected 'pending', got nil" — оказывается, `status` тоже `nil`. Теперь думаете: "может, проблема в scope для статуса?"
4. Исправляете scope, пушите, ждёте ещё 15 минут
5. CI падает: "expected 150.0, got nil" — и `total` тоже сломан. Наконец понимаете: весь сериализатор не работает!
6. **Итого: 45+ минут потрачено + 2 неправильных исправления из-за неполного контекста**

**Проблема неполного контекста:** Видя только первое падение, вы не понимаете масштаб проблемы. Вместо того чтобы сразу увидеть "весь `parsed_body` пустой → сериализатор сломан", вы решаете локальные проблемы (`id`, потом `status`, потом `total`), которые на самом деле симптомы одной глобальной причины. Неполный контекст ведёт к неправильной диагностике и неэффективным исправлениям. Как говорится, знание — сила.

```ruby
# с aggregate_failures
it 'returns order details', :aggregate_failures do
  get "/api/orders/#{order.id}"
  
  expect(response).to have_http_status(:ok)
  expect(response.content_type).to match(/json/)
  expect(response.parsed_body['id']).to eq(order.id)
  expect(response.parsed_body['status']).to eq('pending')
  expect(response.parsed_body['total']).to eq(150.0)
  expect(response.parsed_body['customer_email']).to be_present
end
```

**Вывод с aggregate_failures показывает ВСЁ сразу:**

```
Failures:

  1) GET /api/orders/:id returns order details
     Got 4 failures:

     1.1) Failure/Error: expect(response.parsed_body['id']).to eq(order.id)
            expected: 123
                 got: nil

     1.2) Failure/Error: expect(response.parsed_body['status']).to eq('pending')
            expected: "pending"
                 got: nil

     1.3) Failure/Error: expect(response.parsed_body['total']).to eq(150.0)
            expected: 150.0
                 got: nil

     1.4) Failure/Error: expect(response.parsed_body['customer_email']).to be_present
            expected present value
                 got: nil
```

Вы **сразу видите**, что проблема глобальная — сериализатор вообще не работает, `parsed_body` пустой. Исправляете за один раз, пушите, ждёте 15 минут — готово. **Экономия: 30+ минут.**

**Сценарий 2: Тесты, которые нельзя запустить локально**

Иногда тесты зависят от окружения, которое сложно поднять локально:

- Интеграция с внешним сервисом (staging-окружение)
- Специфичная инфраструктура (Kubernetes, особые сетевые настройки)
- Доступ к определённым данным или credentials, которые есть только в CI

В таких случаях каждый запуск теста — это коммит + push + ожидание CI. Если тест проверяет 6 атрибутов объекта и все сломаны, без `:aggregate_failures` вам придётся сделать 6 итераций вместо одной.

Аналогичная проблема возникает с длительными интеграционными тестами, хотя такие встречаются редко.

**Правило:** Если тест проверяет атрибуты одного результата (объект, HTTP-ответ, результат вычислений) и вы не можете быстро переитерировать (CI-only, [flaky](#характеристики-и-состояния)), используйте `:aggregate_failures`. Это экономит время и нервы команды.

#### Когда использовать `:aggregate_failures`

✅ **ИСПОЛЬЗУЙТЕ когда:**

1. **Проверяете атрибуты одного созданного/полученного объекта** — атрибуты выводятся из одного источника и формируют целостный интерфейс (см. правило 3.1 "Интерфейсное тестирование"):

   ```ruby
   # нормально: aggregate_failures покажет все несоответствия сразу
   it 'exposes user profile attributes', :aggregate_failures do
     expect(profile.full_name).to eq('John Doe')
     expect(profile.email).to eq('john@example.com')
     expect(profile.account_type).to eq('premium')
   end
   
   # идеально: have_attributes даёт тот же эффект + компактнее
   it 'exposes user profile attributes' do
     expect(profile).to have_attributes(
       full_name: 'John Doe',
       email: 'john@example.com',
       account_type: 'premium'
     )
   end
   ```

   **Предпочитайте `have_attributes`** когда проверяете атрибуты объекта — он автоматически показывает все несоответствия и делает код читаемее (см. правило 3.1).

2. **Тестируете интерфейс/контракт объекта в заданном состоянии** — все проверки относятся к единому представлению:

   ```ruby
   # нормально
   it 'provides shipping address details', :aggregate_failures do
     expect(address.street).to eq('123 Main St')
     expect(address.city).to eq('Springfield')
     expect(address.postal_code).to eq('12345')
     expect(address.country).to eq('USA')
   end
   
   # идеально
   it 'provides shipping address details' do
     expect(address).to have_attributes(
       street: '123 Main St',
       city: 'Springfield',
       postal_code: '12345',
       country: 'USA'
     )
   end
   ```

3. **Проверяете структуру HTTP-ответа** — статус, заголовки и основные поля тела ответа как единый контракт:

   ```ruby
   it 'returns successful response with order data', :aggregate_failures do
     post '/orders', params: order_params
     expect(response).to have_http_status(:created)
     expect(response.content_type).to match(/json/)
     expect(response.parsed_body).to include('id', 'status', 'total')
   end
   ```

4. **Проверяете связанные значения, выведенные из одного источника** — вычисляемые или производные атрибуты:

   ```ruby
   it 'calculates order totals correctly', :aggregate_failures do
     expect(order.subtotal).to eq(100.0)
     expect(order.tax).to eq(8.0)
     expect(order.total).to eq(108.0)
   end
   ```

❌ **НЕ ИСПОЛЬЗУЙТЕ когда:**

1. **Тестируете разные поведения** — каждое действие вызывает независимый бизнес-эффект:

   ```ruby
   # плохо: два независимых поведения
   it 'creates order and sends confirmation', :aggregate_failures do
     expect { place_order }.to change(Order, :count).by(1)
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   
   # хорошо: разделены на отдельные тесты
   it 'creates an order' do
     expect { place_order }.to change(Order, :count).by(1)
   end
   
   it 'enqueues confirmation email' do
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   ```

2. **Тестируете разных акторов** — каждый актор представляет отдельное правило:

   ```ruby
   # плохо: два актора с разной логикой
   it 'hides notifications', :aggregate_failures do
     expect(admin_notifications).to be_hidden
     expect(user_notifications).not_to be_hidden
   end
   
   # хорошо: отдельные контексты для каждого актора
   context 'for admin' do
     it 'hides admin notifications' do
       expect(admin_notifications).to be_hidden
     end
   end
   
   context 'for regular user' do
     it 'does NOT hide user notifications' do
       expect(user_notifications).not_to be_hidden
     end
   end
   ```

#### Дополнительные рекомендации

- **Держите описание конкретным:** Даже с флагом название `it` должно чётко указывать, что проверяется. Избегайте общих формулировок (`'works correctly'`, `'returns data'`).
- **Ограничивайте количество ожиданий:** Если в тесте больше 10-15 ожиданий, возможно вы проверяете слишком много — подумайте о разбиении на несколько тестов или вынесении части логики.
- **Подготовка контекста не оправдывает смешивание поведений:** Даже если setup дорогой, правильнее оптимизировать фабрики или вынести общий контекст в `before`, чем прятать независимые правила в одном `it`.

### Руководство по принятию решения: один `it` или несколько?

Когда непонятно, объединять проверки в один тест или разделять на несколько, используйте эти контрольные вопросы:

#### 1. "Можно ли описать эти проверки одним предложением для нетехнического человека?"

**Если НЕТ** (требуются разные предложения) → Разделяйте на отдельные `it`.

Пример: "Система создаёт заказ" и "система отправляет подтверждение" — нужны два предложения, это два разных действия с точки зрения бизнеса.

**Если ДА** (одно предложение описывает всё) → Рассмотрите один `it` с `:aggregate_failures`.

Пример: "Профиль пользователя содержит имя, email и тип аккаунта" — одно предложение описывает единое представление данных профиля.

#### 2. "Тестирует ли каждое ожидание независимый путь выполнения кода?"

**Если ДА** → Разделяйте на отдельные `it`.

Пример: Проверка создания записи (`expect { ... }.to change(Order, :count)`) и проверка отправки email (`expect { ... }.to have_enqueued_job`) выполняют разные ветки логики.

**Если НЕТ** → Один `it` с `:aggregate_failures`.

Пример: Все атрибуты презентера вычисляются из одного объекта `product` — нет ветвления, только трансформация данных.

#### 3. "Проверяю ли я разные части публичного интерфейса?"

**Если ДА, разные части** → Разделяйте на отдельные `it`.

Пример: `#create_order` и `#send_confirmation` — это разные методы, каждый из которых представляет отдельное поведение.

**Если НЕТ, один интерфейс** → Один `it` с `:aggregate_failures`.

Пример: Все проверки относятся к атрибутам одного метода `#summary` — это единый интерфейс объекта в заданном состоянии.

#### Примеры применения

```ruby
# Вопрос 1: Можно ли описать это одним предложением?
# "Создаёт заказ" + "Отправляет email"
# → НЕТ, нужны два разных предложения → Разделяем

# ❌ Не делайте так:
it 'processes order', :aggregate_failures do
  expect { place_order }.to change(Order, :count).by(1)
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end

# ✅ Разделяем на отдельные поведения:
it 'creates an order' do
  expect { place_order }.to change(Order, :count).by(1)
end

it 'enqueues confirmation email' do
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end

# ✅ Но если это интерфейс:
# "Продукт предоставляет свой каталожный интерфейс (имя + цена + наличие)"
# → ДА, одно предложение описывает всё → Объединяем

# нормально
it 'exposes catalog interface', :aggregate_failures do
  expect(product.name).to eq('Laptop')
  expect(product.price).to eq(999.99)
  expect(product.availability).to eq('In Stock')
end

# идеально: have_attributes компактнее и даёт тот же эффект
it 'exposes catalog interface' do
  expect(product).to have_attributes(
    name: 'Laptop',
    price: 999.99,
    availability: 'In Stock'
  )
end
```

```ruby
# Вопрос 2: Независимые пути выполнения?
# Создание Order и отправка Email — разные пути
# → ДА → Разделяем

it 'creates an order' do
  expect { checkout }.to change(Order, :count).by(1)
end

it 'sends confirmation email' do
  expect { checkout }.to have_enqueued_job(OrderConfirmationJob)
end
```

```ruby
# Вопрос 3: Один интерфейс или разные?
# AddressPresenter#formatted_address предоставляет несколько строк адреса
# → Один интерфейс → Объединяем

# нормально
it 'formats address with all components', :aggregate_failures do
  expect(presenter.street_line).to eq('123 Main St')
  expect(presenter.city_line).to eq('Springfield, IL')
  expect(presenter.country_line).to eq('USA 12345')
end

# идеально
it 'formats address with all components' do
  expect(presenter).to have_attributes(
    street_line: '123 Main St',
    city_line: 'Springfield, IL',
    country_line: 'USA 12345'
  )
end
```

#### Быстрый чек-лист

| Критерий | Разделять | Объединять |
|----------|-----------|------------|
| Можно описать каждую проверку отдельным предложением для бизнеса | ✅ | ❌ |
| Проверки затрагивают независимые пути кода | ✅ | ❌ |
| Тестируются разные методы/поведения | ✅ | ❌ |
| Все атрибуты из одного источника/состояния | ❌ | ✅ |
| Проверяется интерфейс объекта (value object, presenter, config) | ❌ | ✅ |
| Проверки описывают единое представление данных | ❌ | ✅ |

**Золотое правило:** Если сомневаетесь — разделяйте. Лучше иметь больше точных тестов, чем один неопределённый.

### Паттерны тестирования: до/после

Этот раздел показывает типичные антипаттерны и их правильные версии.

#### Пример 1: Тестирование конфигурационного объекта

❌ **Over-splitting (излишнее разделение):**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  let(:env_vars) do
    {
      'APP_NAME' => 'MyStore',
      'APP_URL' => 'https://mystore.com',
      'SUPPORT_EMAIL' => 'support@mystore.com'
      # ... еще 3 переменные: NOREPLY_EMAIL, MAX_UPLOAD_SIZE, SESSION_TIMEOUT
    }
  end

  it('returns application name from ENV') { expect(config.app_name).to eq('MyStore') }
  it('returns application URL from ENV') { expect(config.app_url).to eq('https://mystore.com') }
  it('returns support email from ENV') { expect(config.support_email).to eq('support@mystore.com') }
  # ... еще 3 проверки для noreply_email, max_upload_size, session_timeout
end
```

**Проблемы:**

- 6 отдельных тестов проверяют одно поведение: "конфигурация корректно инициализируется из ENV"
- При добавлении нового параметра придётся создавать ещё один тест
- Все тесты зависят от одного источника (`env_vars`), но это не отражено в структуре
- Если источник изменится, все 6 тестов упадут, хотя проблема одна

✅ **Правильное интерфейсное тестирование:**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  context 'when initialized from environment variables' do
    let(:env_vars) do
      {
        'APP_NAME' => 'MyStore',
        'APP_URL' => 'https://mystore.com',
        'SUPPORT_EMAIL' => 'support@mystore.com'
        # ... еще 3 переменные: NOREPLY_EMAIL, MAX_UPLOAD_SIZE, SESSION_TIMEOUT
      }
    end

    it 'exposes configuration interface from ENV', :aggregate_failures do
      # Application identity
      expect(config.app_name).to eq('MyStore')
      expect(config.app_url).to eq('https://mystore.com')
      
      # ... еще 4 проверки для email адресов и лимитов
    end
  end

  context 'when required ENV variables are missing' do
    let(:env_vars) { {} }

    it 'raises configuration error' do
      expect { config.app_name }.to raise_error(AppConfig::MissingConfigError)
    end
  end
end
```

**Преимущества:**

- Один тест ясно выражает поведение: "объект предоставляет полный интерфейс из ENV"
- Группировка комментариями показывает структуру конфигурации
- Отдельный контекст для error case проверяет другое поведение (валидацию)
- Быстрее выполняется (один setup вместо шести)
- Легче читается и поддерживается

#### Пример 2: Тестирование API-ответа

❌ **Излишняя детализация (проверка всего хэша):**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001', stock: 5) }

  it 'returns product details' do
    get "/api/products/#{product.id}"
    
    expect(response.parsed_body).to eq({
      'id' => product.id,
      'name' => 'Laptop',
      'price' => 999.99,
      'sku' => 'LPT-001',
      'stock' => 5
      # ... еще 6 полей: category, created_at, updated_at, description, weight, dimensions
    })
  end
end
```

**Проблемы:**

- Тест сломается при добавлении любого нового поля в сериализатор
- Проверяются технические детали (`created_at`, `updated_at`), не важные для бизнеса
- Не понятно, какие поля критичны для клиента API
- Тест фиксирует реализацию, а не контракт

✅ **Правильный подход: проверка ключевых полей + специализированные инструменты:**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001') }

  it 'returns product with essential attributes', :aggregate_failures do
    get "/api/products/#{product.id}"
    
    expect(response).to have_http_status(:ok)
    expect(response.parsed_body).to include(
      'id' => product.id,
      'name' => 'Laptop',
      'price' => a_value_within(0.01).of(999.99),
      'sku' => 'LPT-001'
    )
  end

  # Полная структура ответа фиксируется через rspec-openapi или RSwag
  # (см. раздел "Тестирование API-контрактов")
end
```

**Преимущества:**

- Тест проверяет только критичные для бизнеса поля
- Использование `include` позволяет добавлять новые поля без поломки теста
- `a_value_within` учитывает особенности Float-арифметики
- Полная структура API фиксируется отдельными инструментами (OpenAPI, JSON Schema)

#### Пример 3: Принудительный вызов ленивого let

❌ **Вызов let внутри before (антипаттерн eager инициализации):**

```ruby
describe OrderProcessor do
  subject(:processor) { described_class.new }

  context 'when products are available in stock' do
    let(:product) { create(:product, stock: 10) }
    let(:order) { create(:order, product: product) }

    before do
      product  # <- принудительный вызов для eager инициализации
      order
    end

    it 'processes the order successfully' do
      result = processor.call(order)
      expect(result).to be_success
    end

    it 'decreases product stock' do
      processor.call(order)
      expect(product.reload.stock).to eq(9)
    end
  end
end
```

**Проблемы:**

- `let` создан для ленивой инициализации (lazy evaluation), а `before` вызывает их принудительно
- Неочевидно, зачем нужен отдельный `before` блок — это создаёт путаницу при чтении
- Смешивается роль Given (подготовка данных через `let`) с явной инициализацией (роль `before`)
- Нарушает принцип явности — если нужна eager инициализация, для этого есть `let!`

✅ **Используйте let! для eager инициализации:**

```ruby
describe OrderProcessor do
  subject(:processor) { described_class.new }

  context 'when products are available in stock' do
    let!(:product) { create(:product, stock: 10) }
    let!(:order) { create(:order, product: product) }

    it 'processes the order successfully' do
      result = processor.call(order)
      expect(result).to be_success
    end

    it 'decreases product stock' do
      processor.call(order)
      expect(product.reload.stock).to eq(9)
    end
  end
end
```

**Преимущества:**

- `let!` явно показывает, что объекты создаются перед каждым тестом (eager evaluation)
- Меньше кода, нет лишнего `before` блока
- Идиоматичный RSpec — `let!` существует именно для этой цели
- Соблюдается разделение ролей из пункта 11: `let!` = Given (подготовка данных), `before` остаётся для When (действие/операция)

**Как это снижает когнитивную нагрузку:**
- Видим все нарушения сразу → полный контекст проблемы, правильная subjectдиагностика с первого раза
- Экономия циклов отладки (особенно в CI) → меньше фрустрации и переключений контекста
- Флаг `:aggregate_failures` явно сигнализирует "это проверка одного правила с множеством аспектов"

### 24. Предпочитайте verifying doubles (`instance_double`, `class_double`, `object_double`)

`double` создаёт «анонимный» двойник без проверки интерфейса. Он позволяет замокать несуществующие методы и пропустить регрессию, когда контракт меняется. `instance_double`, `class_double` и `object_double` проверяют интерфейс реальных объектов и защищают от ложных зелёных тестов.

```ruby
# плохо
let(:gateway) { double('PaymentGateway', charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end

# хорошо
let(:gateway) { instance_double(PaymentGateway, charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end
```

Что не так в плохом примере:

- `double` принимает любые методы, поэтому опечатка или изменение интерфейса пройдут незамеченными.
- Тест остаётся зелёным даже при несовпадении контракта с реальным `PaymentGateway`, и регрессия попадёт в продакшен.

- `instance_double(SomeClass)` проверяет методы экземпляра `SomeClass`.
- `class_double(SomeClass)` — методы самого класса (например, `.find`, `.call`).
- `object_double(existing_object)` — фиксирует интерфейс конкретного объекта (удобно для зависимостей, построенных в тесте).

**Когда verifying double использовать нельзя:**

- Класс или модуль создаётся динамически и ещё не загружен в момент выполнения теста (`require` отсутствует).
- Интерфейс формируется через `method_missing`/`respond_to_missing?`, и в спецификации нет сигнатур, которые можно проверить (например, `OpenStruct`, `Hashie::Mash`).
- Вы мокаете внешний сервис, у которого нет Ruby-класса (SOAP/XML API), и эмуляция происходит через `Struct.new` или обёртку на лету.

В этих редких ситуациях:

- Документируйте причину (`let(:gateway) { double('LegacyGateway') } # нет реального класса, метод задаётся в runtime`).
- Ограничьте контракт явными `allow(...).to receive(:method)` и добавьте интеграционный тест, который проверит реальное взаимодействие.

Во всех остальных случаях выбирайте verifying doubles — это дешёвый способ поймать опечатку ещё до запуска приложения.

### 25. Используйте shared examples для декларации контрактов

`shared_examples` служат для декларации контрактов — ожиданий, которые повторяются в разных местах. Они не про DRY ради снижения строк кода — тесты мы не «программируем» (см. пункт 15), они описывают правила. Если ожидание повторяется, выносите именно его описание и наблюдаемые последствия.

Существует два сценария использования shared examples:

#### 23.1. Для общего поведения разных объектов

Когда несколько классов реализуют один контракт (например, включают общий модуль), используйте shared examples для проверки общего поведения.

- Название `shared_examples` формулируйте через поведение по формуле: **`'a/an + [прилагательное] + существительное [+ уточнение]'`**. Примеры: `'an enumerable resource'`, `'a pageable API'`, `'a collection of orders'`. Так в выводе RSpec видно, какое правило описывается.
  - Проверка правильности: подставьте в предложение **"it behaves like [ваше_название]"**. Если звучит как естественное английское предложение — название подходит.
  - Исключение: абстрактные существительные могут использоваться без артикля (`'sortability'`, `'enumerability'`).
- Применяйте `it_behaves_like`/`it_should_behave_like` там, где объект реально реализует контракт: например, класс включает модуль с общими методами (`Enumerable`, ваш `Paginatable` mixin).
- Внутри shared examples работайте только с публичным интерфейсом, ожидая то же поведение, которое проверял бы отдельный тест.

```ruby
# shared_examples: spec/support/shared_examples/paginatable.rb
RSpec.shared_examples 'a pageable API' do
  it('returns the second page') { expect(resource.paginate(page: 2).current_page).to eq 2 }
  it('limits page size') { expect(resource.paginate(page: 1, per_page: 5).items.count).to eq 5 }
end

# использование
describe OrdersQuery do
  subject(:resource) { described_class.new(scope: Order.all) }

  it_behaves_like 'a pageable API'
end

describe UsersQuery do
  subject(:resource) { described_class.new(scope: User.active) }

  it_behaves_like 'a pageable API'
end
```

- Shared example формулирует «что значит быть pageable», без нелепых «general behaviour».
- Каждый класс, включающий модуль `Paginatable`, подключает shared example и доказывает, что контракт выполняется.
- Если нужно добавить новую характеристику (например, сортировку), расширяете shared example — все клиенты автоматически проверяют обновлённый контракт.

#### 23.2. Для инвариантных ожиданий внутри одного теста

Когда вы проверяете объект с множеством характеристик и обнаруживаете ожидания, которые повторяются во всех листовых контекстах (независимо от состояний характеристик), — это инварианты интерфейса. Они должны выполняться всегда, вне зависимости от входных данных.

- Инвариантные ожидания выявляются на этапе финального аудита (см. пункт 6.2).
- Вынесите повторяющиеся `it` в `shared_examples` и подключите их в корневом `describe` или в каждом листовом контексте через `it_behaves_like`.
- Название формулируйте через контракт: `'valid booking search params'`, `'serializable to JSON'`, `'responds to required methods'`.

Пример: класс `BookingSearchValidator` проверяет параметры поиска отелей. Независимо от типа клиента (b2c/b2b) и региона поиска (domestic/international), он всегда должен возвращать структуру с полями `valid?`, `errors`, `normalized_params`.

```ruby
# плохо: повторяющиеся it во всех листовых контекстах
describe BookingSearchValidator do
  subject(:validator) { described_class.new(params, client_type: client_type, region: region) }

  context 'when client is b2c' do
    let(:client_type) { :b2c }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { ... } # параметры внутреннего поиска

      it('validates check_in date') { expect(validator.valid?).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { ... } # параметры международного поиска

      it('validates international booking rules') { expect(validator.valid?).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end
  end

  context 'when client is b2b' do
    let(:client_type) { :b2b }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { ... } # параметры внутреннего поиска

      it('applies b2b pricing rules') { expect(validator.normalized_params[:pricing_tier]).to eq('corporate') }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { ... } # параметры международного поиска

      it('applies international b2b rules') { expect(validator.normalized_params[:requires_passport]).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end
  end
end
```

```ruby
# хорошо: инвариант вынесен в shared_examples
RSpec.shared_examples 'a booking search validator' do
  it('responds to valid?') { expect(validator).to respond_to(:valid?) }
  it('responds to errors') { expect(validator).to respond_to(:errors) }
  it('responds to normalized_params') { expect(validator).to respond_to(:normalized_params) }
end

describe BookingSearchValidator do
  subject(:validator) { described_class.new(params, client_type: client_type, region: region) }

  context 'when client is b2c' do
    let(:client_type) { :b2c }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { { check_in: '2025-11-01', check_out: '2025-11-03', guests: 2 } }

      it_behaves_like 'a booking search validator'

      it 'validates check_in date' do
        expect(validator.valid?).to be true
      end
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { { check_in: '2025-12-01', check_out: '2025-12-05', guests: 1 } }

      it_behaves_like 'a booking search validator'

      it 'validates international booking rules' do
        expect(validator.valid?).to be true
      end
    end
  end

  context 'when client is b2b' do
    let(:client_type) { :b2b }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { { check_in: '2025-11-10', check_out: '2025-11-15', guests: 5 } }

      it_behaves_like 'a booking search validator'

      it 'applies b2b pricing rules' do
        expect(validator.normalized_params[:pricing_tier]).to eq('corporate')
      end
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { { check_in: '2026-01-01', check_out: '2026-01-10', guests: 3 } }

      it_behaves_like 'a booking search validator'

      it 'applies international b2b rules' do
        expect(validator.normalized_params[:requires_passport]).to be true
      end
    end
  end
end
```

- Три проверки `respond_to` повторялись во всех четырёх листовых контекстах — это инвариант интерфейса.
- Shared example `'a booking search validator'` декларирует обязательный контракт результата валидации.
- Каждый листовой контекст теперь содержит только проверки, специфичные для его характеристик (b2c/b2b, domestic/international).
- При добавлении нового метода в интерфейс валидатора (например, `warnings`), достаточно расширить shared example, и все контексты автоматически проверят новый контракт.

Использование shared examples не отменяет требования писать осмысленные контексты и `it`. Они помогают избежать дублирования контрактов, но не подменяют понятные спецификации.

### 26. Предпочитайте Request specs вместо controller specs

Controller specs считаются устаревшими: Rails core и RSpec core команды официально рекомендуют писать Request specs, начиная с релиза RSpec 3.5 и Rails 5.0 ([подробнее](https://rspec.info/blog/2016/07/rspec-3-5-has-been-released/#rails-support-for-rails-5)). Request specs проверяют HTTP-контракт, а значит остаются ближе к наблюдаемому поведению и не зависят от внутренних контроллерных фильтров.

- Для новых тестов выбирайте Request specs; только они покрывают стек Rack → контроллер → middleware целиком и показывают, что увидит клиент.
- Если приходится поддерживать legacy controller specs, помечайте их как наследие (например, `describe SomeController, :legacy`) и планируйте миграцию. При доработках расширяйте по пирамиде: поведение — в Request spec, мелкую логику выносите в сервис/модель и покрывайте юнитами.
- Не дублируйте проверки: если действие уже описано на уровне Request spec, controller spec лишь повторит реализацию и будет ломаться при рефакторинге маршрутов или фильтров.

## Тестирование API-контрактов: границы применимости RSpec

Детальный разбор переехал в отдельный документ `guide.api.ru.md`, чтобы основной гайд оставался компактным.

- Используйте RSpec Request specs для поведения: HTTP-статусы, ключевые поля и побочные эффекты.
- Для структуры JSON-ответов подключайте специализированные инструменты (JSON Schema, rswag, Pact) — они публикуют контракты и не ломаются при изменении реализации.
- Не пытайтесь хранить контракт в десятках `expect`: держите его в одном месте, а в RSpec проверяйте только наблюдаемые правила.

[Полный гайд с анти-паттернами, инструментами и практическим пайплайном →](./guide.api.ru.md)

## Внешние сервисы

- **HTTP-запросы.** Реальные вызовы в тестах запрещены: включайте WebMock (или аналог) и явно разрешайте только те хосты, которые эмулируете. Любая попытка обратиться во внешний интернет должна завершаться понятной ошибкой.
- **Фиксация контрактов.** Если протокол стабилен, используйте VCR — он фиксирует ответы и предотвращает флейки. Когда важнее документировать формат и семантику, подключайте контрактные тесты: Pact для сценариев потребитель ↔ поставщик, `rspec-openapi` или RSwag для актуальной OpenAPI-спецификации. В контракте фиксируйте только публичные поля, иначе получится тест реализации.
- **Очереди и фоновые джобы.** В спецификациях проверяйте факт постановки (`expect { ... }.to have_enqueued_job`) и корректность аргументов. Бизнес-логику самой джобы выносите в отдельный юнит-тест: там запускаем `perform`/`perform_now` и убеждаемся, что поведение соответствует правилам домена.

## Нюансы времени между Ruby и PostgreSQL

- `Date#wday` возвращает 0 для воскресенья, в то время как `EXTRACT(DOW FROM ...)` в PostgreSQL даёт 0 по воскресеньям и 1 по понедельникам. Совмещая Ruby- и SQL-проверки в тестах, явно фиксируйте ожидаемый день недели и не сравнивайте цифры «как есть».
- `Date.current.beginning_of_week` подчиняется `Rails.application.config.beginning_of_week`, а `date_trunc('week', ...)` в PostgreSQL по ISO всегда стартует с понедельника. Если приложение работает с календарём, добавляйте тесты, которые проверяют корректный «первый день недели» через публичный интерфейс, иначе легко получить [flaky тест](#характеристики-и-состояния) при смене настройки.
- `Date.parse` и `Time.parse` игнорируют `Time.zone`, тогда как ActiveRecord сохраняет `timestamp` в UTC. В тестах, где важна зона, используйте `Time.zone.parse`, `Time.zone.local` и `in_time_zone`, а ожидания выносите в `Time.zone.at`/`change`.
- Переходы через полночь и DST: PostgreSQL вычисляет интервалы UTC-значениями, а Ruby при `travel_to` может попасть в «не существующий» час. Чтобы не ловить плавающие падения, фиксируйте время в середине дня (`travel_to(Time.zone.parse('2024-03-25 12:00'))`) и пишите отдельные примеры на переходы, если бизнес-процесс затрагивает крайние точки.
