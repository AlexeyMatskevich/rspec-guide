# Что можно изучить по тестам

Better Specs — краткий свод лучших (и худших) практик для RSpec: как формулировать примеры, работать с матчерами и контекстами. https://www.betterspecs.org

Testing for Beginners — вводная книга по тестированию на Ruby: что тестировать, как думать о сценариях и как читать фейлы. http://testing-for-beginners.rubymonstas.org/index.html

Pluralsight: RSpec Ruby Application Testing — наглядный курс: BDD на примере игры в карты, структура describe/context/it, три фазы теста (подготовка -> действие -> ожидание). Есть 10-дневный триал; https://www.pluralsight.com/courses/rspec-ruby-application-testing

Everyday Rails Testing with RSpec — практичная "библиотека приемов": factory_bot, VCR, WebMock и другие инструменты. Около 230 страниц; можно прочитать за пару дней. https://leanpub.com/everydayrailsrspec

Эти материалы дадут базу. Ниже — философия RSpec/BDD, на которой держатся правила из следующего раздела.

# Про RSpec

RSpec — тестовая библиотека для Ruby с DSL, заточенным под описание поведения, а не внутренней реализации.

```ruby
describe "my app" do
  it "works" do
    expect(MyApp.working).to eq(true)
  end
end
```

Официальный слоган на https://rspec.info/:

```
Behaviour Driven Development for Ruby.
Making TDD Productive and Fun.
```

Ключевая мысль: RSpec — инструмент BDD для Ruby. Он делает практику TDD продуктивной и более "человечной" за счет языка, близкого к бизнес-формулировкам.

## Как связаны RSpec, BDD и TDD

TDD (test-driven development) — короткий цикл Red -> Green -> Refactor:
- пишем тест, фиксирующий желаемое поведение;
- пишем минимальный код, чтобы тест прошел;
- рефакторим, сохраняя зеленое состояние.

BDD (behaviour-driven development) вырос из TDD и смещает фокус на поведение домена и язык разговора с бизнесом. Тесты становятся читаемой спецификацией, а не просто проверкой кода.

RSpec воплощает BDD в экосистеме Ruby: `describe/context/it` помогают формулировать поведение единообразно и понятно.

## Зачем нам BDD на практике

- Единый язык с бизнесом: формулируем правила домена "человеческими" фразами, не зная реализации.
- Исполняемая документация: тесты — проверяемая спецификация поведения.
- Быстрая локализация проблем: упавший тест явно показывает, какое правило нарушено.
- Свободный рефакторинг: фокус на том, что делает система, а не как она устроена.

**Предметная область** — набор правил и понятий, которые бизнес хочет видеть в системе (например, биллинг). В коде мы реализуем именно эти правила поведения.

## От естественного языка к формальному синтаксису Gherkin

BDD часто опирается на Gherkin — формальный, но читаемый синтаксис для описания историй и сценариев. Он фиксирует три ключевые фазы: Given (условия), When (действие), Then (результат).

Пример истории и сценариев:

```
As a store owner
In order to keep track of stock
I want to add items back to stock when they're returned.

Scenario 1: Refunded items should be returned to stock
  Given that a customer previously bought a black sweater from me
  And I have three black sweaters in stock
  When they return the black sweater for a refund
  Then I should have four black sweaters in stock

Scenario 2: Replaced items should be returned to stock
  Given that a customer previously bought a blue garment from me
  And I have two blue garments in stock
  And three black garments in stock
  When they return the blue garment for a replacement in black
  Then I should have three blue garments in stock
  And two black garments in stock
```

И адаптация на русском:

```
Как владелец магазина
Чтобы следить за запасами на складе
Я хочу возвращать товары на склад, когда их возвращают покупатели.

Сценарий 1: Возвращенные товары должны вернуться на склад
  Дано, что клиент ранее купил у меня черный свитер
  И на складе есть три таких свитера
  Когда клиент возвращает свитер
  Тогда на складе должно быть четыре черных свитера

Сценарий 2: Обмененные товары должны вернуться на склад
  Дано, что клиент покупал у меня одежду синего цвета
  И на складе есть два таких наименования синего цвета
  И три наименования черного цвета
  Когда клиент возвращает синюю вещь, чтобы обменять на черную
  Тогда на складе должно быть три синих наименования
  И два черных наименования
```

### Язык Gherkin — памятка

| Ключевое слово (EN) | Русский | Короткое описание |
| --- | --- | --- |
| Story / Feature | История | Заголовок спецификации, формулирует ценность. |
| As a | Как (в роли) | Роль заинтересованного лица. |
| In order to | Чтобы достичь | Цель роли. |
| I want to | Я хочу | Краткий желаемый результат. |
| Scenario | Сценарий | Конкретный сценарий истории. |
| Given | Дано | Начальные условия (повторяются через And). |
| When | Когда | Действие, запускающее сценарий. |
| Then | Тогда | Наблюдаемый результат (можно добавлять And/But). |
| And / But | И / Но | Дополнительные условия или исключения. |

### Как это соотносится с RSpec

RSpec не требует Gherkin и не исполняет `.feature`-файлы, но следует тем же смысловым фазам:

- **Given** -> подготовка данных и окружения (`let`, `before`, вспомогательные методы).
- **When** -> действие, которое проверяем (вызов метода, HTTP-запрос, команда).
- **Then** -> ожидаемый результат (`expect`-утверждения).
- **Feature / Story** -> верхний уровень `describe`, задающий область поведения.
- **Scenario** -> `it`, конкретный пример поведения.
- **And / But** -> уточнения условий через вложенные `context`.

Это не механическое соответствие один-к-одному, но такая оптика помогает писать тесты как читабельные спецификации домена. На этой базе построены правила из следующего раздела.

## Пирамида тестирования и выбор уровня

BDD ставит во главу угла поведение, но сами проверки живут на разных уровнях. Держите в голове пирамиду: быстрые модульные тесты в основании, сервисные/интеграционные — посредине, end-to-end и контрактные — на вершине. Правильный выбор уровня помогает не скатываться к проверкам реализации.

| Уровень | Вопрос | Наблюдение | Типичные инструменты |
| --- | --- | --- | --- |
| Юнит (модель, сервис, объект) | Как ведёт себя маленький кусок логики? | Возвращаемое значение, вызовы зависимостей (через doubles) | `expect`, doubles, pure Ruby |
| Интеграционный / сервисный | Как взаимодействуют несколько компонентов? | Ответ сервиса, изменение доменной модели, побочные эффекты | Request/feature specs, ActiveJob, mailers |
| Контрактный / API | Что видит клиент (frontend, внешний сервис)? | HTTP-статус, тело ответа, заголовки | request specs, pact/contract tests |
| Системный (E2E) | Работает ли пользовательская история целиком? | UI-реакции, end-to-end поток | Capybara, Cypress, etc. |

Железных правил нет, но есть ориентиры:

- Проверяйте на том уровне, где поведение естественно наблюдать. Request-spec проверяет статус/ответ, а не содержимое базы — иначе вы тестируете реализацию контроллера, а не API-контракт (см. правило 6).
- Если одна проверка требует сложной подготовки или медленных зависимостей, подумайте, не лучше ли перенести часть логики в более низкий уровень пирамиды.
- Единичный побочный эффект (создана запись, отправлено письмо) лучше выносить в отдельный юнит/сервисный тест. В BDD-контрактах фиксируйте лишь то, что важно потребителю.
- `:aggregate_failures` (правило 14) применяем, только если говорим об одном поведении и хотим увидеть все нарушения сразу — это не способ проверить половину пирамиды в одном `it`.

С пирамидой в голове легче решать, что считать happy path, что — corner case, и какой уровень тестов ответственен за подтверждение каждого правила.

## Глоссарий

- **Поведение** — наблюдаемый результат системы, сформулированный как правило предметной области ("если … то …").

- **Характеристика** — доменный аспект, влияющий на исход поведения (роль пользователя, способ оплаты, статус заказа).
  - *Как найти:* спросите «если изменить этот аспект, изменится ли ожидаемый результат?», и убедитесь, что речь идёт о бизнес-факте, а не о технической детали.

- **Состояние характеристики** — конкретный вариант значения характеристики, важный для правила (подписка активна, баланс ниже лимита).
  - *Как выделить:* сгруппируйте возможные значения в доменные диапазоны и сформулируйте их короткими утверждениями.
  - *Типы состояний:*
    - бинарные (да/нет: карта привязана ↔ не привязана);
    - множественные (enum: роль = admin / manager / guest);
    - диапазоны (число/дата: баланс ≥ стоимость / баланс < стоимость).

- **Контекст (`context`)** — блок, фиксирующий одно или несколько состояний характеристик. Контекст отвечает за «Given»-часть спецификации.
  - **Положительный контекст** — состояние выполняется (обычно часть happy path).
  - **Отрицательный контекст** — состояние нарушено или отрицается (часто часть corner case).
  - **Вложенный контекст** — уточняет внешний, добавляя состояние новой характеристики или уточняя текущую.

- **Кейс / пример (`it`)** — минимальный сценарий, проверяющий конкретное поведение на выбранном наборе состояний.
  - **Happy path case** — основной поток: ожидаемый успех без исключений.
  - **Corner case** — отклонение от основного потока: крайние значения, ошибки, исключительные ситуации.
  - **Положительный тест** — пример подтверждает поведение (чаще совпадает с happy path).
  - **Отрицательный тест** — пример показывает отказ или защиту от некорректного поведения (часто совпадает с corner case).
  - *Важно:* happy/corner описывают тип кейса, а положительный/отрицательный — результат проверки. При множественных состояниях возможно несколько happy path кейсов без отрицательных тестов на этой характеристике.

- **Настройка контекста** — подготовка данных или окружения (через `let`, `before`, вспомогательные методы), делающая состояние характеристики истинным. Должна находиться сразу под соответствующим `context`.

```
| Тип кейса        | Тип контекстов внутри            | Результат теста       |
| ---------------- | -------------------------------- | --------------------- |
| Happy path case  | Положительные контексты          | Положительный тест    |
| Corner case      | Отрицательные / уточняющие контексты | Отрицательный тест / защита |
```

Таблица отражает типичную связь, но возможны исключения — например, enum-характеристика может включать несколько happy path кейсов без отрицательных тестов, или corner case может завершаться положительным результатом (например, graceful degradation).

- **Flaky test** — тест, который ведёт себя непредсказуемо: иногда зелёный, иногда красный при неизменном коде. Чаще всего связан с нестабильным временем, глобальным состоянием, случайным порядком или зависимостями от внешних сервисов.

# RSpec style guide
### 1. Тестируйте поведение, а не реализацию.

Если в вашем тесте нет описания поведения, то это не тест. Почему? При отсутствии описания поведения возникает привязка
к реализации, когда после вас кто-то будет смотреть тесты - он ничего не поймет и тесты окажутся бесполезными.
###### далее `some_action` в примерах - это псевдокод, который мы тестируем и поведение которого мы описываем
```ruby
# очень плохой пример кода
describe "#some_action" do
  # ... создаем пользователя, но не связываем подготовку с описанием контекста
  it "true" do          # из этого описания не понятно, что означает факт того, что мы ожидаем `true`
    expect(some_action).to eq true
  end
end

# хороший пример кода
describe "#some_action" do
  # ... создаем пользователя и явно подготавливаем характеристику, о которой говорим в `it`
  it "allows unlocking the user" do         # это описание рассказывает нам о том, что означает наше ожидание от кода
    expect(some_action).to eq true
  end
end
```

Или, например, используйте `match_array`, когда пишите ожидание для массива, порядок значений в котором вам не важен.
```ruby
# плохо
expect(some_action).to eq [1, 2, 3] # pass
# хорошо
expect(some_action).to match_array [2, 3, 1] # pass
```
Представим что `some_action` возвращал всегда `[1, 2, 3]` и ваши тесты проходили,
потом вы внесли какие-то изменения в код, обновили базу данных и т.д. То есть по какой-то причине порядок в массиве изменился,
например, он стал `[2, 1, 3]`,
и у вас начала падать дюжина тестов. И все это произошло из-за вашей привязки к реализации!
Не делайте так, тестируйте конкретное поведение.
Если это выборка данных, то проверяйте факт правильной выборки данных.

В целом, каждый раз как вы работаете с любой коллекцией (массивы, хеши, ActiveRecord::Relation ...)
и используете `eq`, то это звоночек, что вы делаете что-то не так. Возможно существует хелпер из библиотеки `RSpec Expectations`, подходящий
для определения вашего ожидания, а возможно вы в принципе не то тестируете (не поведение вашего кода) или даже не то реализуете.

### 2. Выделяйте характеристики поведения и их состояния

**Характеристика** — доменный аспект, который влияет на исход проверяемого поведения (роль пользователя, способ оплаты, статус заказа).

**Состояние характеристики** — конкретный вариант этой характеристики, который важен для правила (подписка активна, баланс меньше лимита, статус = shipped).

Как понять, что вы нашли характеристику:

- задайте вопрос: «если изменить этот аспект, ожидание примера изменится?»;
- характеристика описывает бизнес-факт, а не реализацию (`user has subscription`, а не `premium_flag`);
- характеристика формулируется как сущность с уточнением (`user role`, `card balance`).

Как подобрать состояния:

- перечислите все варианты, которые различает бизнес (роль = admin / customer; статус = draft / paid / cancelled);
- числовые величины группируйте в диапазоны, которые влияют на решение (баланс ≥ стоимость, баланс < стоимость);
- каждое состояние выражайте отдельным `context` с ясной формулировкой.

### 3. Стройте иерархию `context` по зависимостям характеристик (happy path → corner cases)

Характеристики могут быть:

- **базовыми** — без них остальные не имеют смысла (нет карты → нет баланса);
- **уточняющими** — уточняют базовую характеристику (баланс карты при наличии карты);
- **независимыми** — не влияют друг на друга (роль пользователя и флаг beta-теста).

Алгоритм:

1. Выпишите характеристики и состояния.
2. Отметьте зависимости: характеристика B зависит от A, если её состояние осмысленно только при конкретном состоянии A.
3. Постройте таблицу иерархии.
4. Для каждой ветки создайте вложенные `context` от базовой к уточняющей, упорядочив состояния: сначала happy path (нормальный сценарий), затем corner cases (отклонения).

#### Зависимые характеристики (бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Привязка карты | has card / has NO card | — |
| Баланс карты | balance ≥ price / balance < price | Привязка карты (has card) |

```ruby
describe '#purchase' do
  context 'when user has a payment card' do               # happy path: карта привязана
    context 'and card balance covers the price' do        # happy path: баланс достаточен
      it 'charges the card'
    end

    context 'but card balance does NOT cover the price' do # corner case: денег не хватило
      it 'rejects the purchase'
    end
  end

  context 'when user has NO payment card' do              # corner case: карты нет
    it 'rejects the purchase'
  end
end
```

> Антипример: если вынести уточняющую характеристику на верхний уровень, контекст перестанет быть самодостаточным и потеряет связь с базовым условием.
>
> ```ruby
> # плохо
> describe '#purchase' do
>   context 'but card balance does NOT cover the price' do
>     it 'rejects the purchase'
>   end
>
>   context 'when user has a payment card' do
>     context 'and card balance covers the price' do
>       it 'charges the card'
>     end
>   end
> end
> ```

#### Независимые характеристики (enum + бинарная характеристика)

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Роль пользователя | admin / customer | — |
| Флаг beta-доступа | enabled / disabled | — |

```ruby
describe '#feature_access' do
  context 'when user role is admin' do        # happy path: полный доступ
    it 'grants access to admin tools'

    context 'and beta feature is enabled' do  # happy path: бонусный доступ
      it 'grants access to beta tools'
    end

    context 'but beta feature is disabled' do # corner case для admin
      it 'falls back to standard tools'
    end
  end

  context 'when user role is customer' do     # corner case: ограниченные права
    it 'denies access to admin tools'

    context 'and beta feature is enabled' do  # corner case: частичное смягчение
      it 'grants access to beta tools'
    end

    context 'but beta feature is disabled' do # самый строгий corner case
      it 'denies access to beta tools'
    end
  end
end
```

Порядок независимых характеристик можно менять (сначала флаг, потом роль), но happy path должен оставаться выше, а отклонения — группироваться ниже на соответствующем уровне вложенности.

### 4. Располагайте happy path перед corner cases

Внутри каждого `describe` читающий ожидает увидеть нормальное поведение первым, а уже затем — исключения. Такой порядок снижает когнитивную нагрузку: мы быстро убеждаемся, что система делает «как надо», и только потом разбираем, что происходит, когда что-то идет не так.

Антипример (нарушен порядок, хотя сами формулировки корректны):

```ruby
# плохо: corner cases выше happy path
describe '#enroll' do
  context 'when enrollment is rejected because email is invalid' do
    it 'shows a validation error'
  end

  context 'when enrollment is rejected because plan is sold out' do
    it 'puts the user on the waitlist'
  end

  context 'when enrollment is accepted' do # happy path затерян внизу
    it 'activates the membership'
  end
end
```

Правильный порядок:

```ruby
# хорошо: happy path сверху, затем corner cases
describe '#enroll' do
  context 'when enrollment is accepted' do
    it 'activates the membership'
  end

  context 'when enrollment is rejected because email is invalid' do
    it 'shows a validation error'
  end

  context 'when enrollment is rejected because plan is sold out' do
    it 'puts the user on the waitlist'
  end
end
```

Инструкция: добавляя новые примеры, проверьте, что блоки happy path остаются первыми на своем уровне вложенности. Corner cases должны находиться ниже и либо начинаться с `but`/`without`, либо явно описывать отклонение.

### 5. Пишите положительный и отрицательный тест

Каждая ветка контекстов описывает конкретное сочетание состояний характеристик. Для этих сочетаний нужен минимум один пример, подтверждающий поведение, и один пример, показывающий отказ — так мы защищаемся от регрессий в обе стороны.

```ruby
# Плохо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }

  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния `blocked = true`
    let(:blocked) { true }

    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... настройка уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to eq true # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end
  end
end

# хорошо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  
  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { true }

    # Контекст 2 уровня для состояния характеристики `blocked_at`
    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to eq true # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end

    context "but blocking duration is under a month" do # отрицательный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 1.month.ago }

      it "does NOT allow unlocking the user" do
        expect(some_action).to eq false # отрицательный тест для состояния характеристики `blocked_at`
      end
    end
  end

  context "when user is NOT blocked by admin" do # отрицательный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { false }

    it "does NOT allow unlocking the user" do
      expect(some_action).to eq false # отрицательный тест для состояния характеристики `blocked_at`
    end
  end
end
```
Если присутствуют только положительные тесты, то в дальнейшем на такие тесты нельзя полагаться,
ввиду того, что они не отразят факта регрессии поведения при дальнейших изменениях в коде,
так как они не будут проверять обратный случай.

### 6. Каждый example (`it`) описывает одно наблюдаемое поведение

Описание в `it` должно быть уникальным и рассказывать об одной бизнес-истине. Если два примера называют одно и то же, значит мы проверяем реализацию разными путями. Это запах: либо нужно выделить отдельное поведение, либо перераспределить проверки по пирамиде тестирования.

- Один `it` = одна ситуация из спецификации = одно ключевое наблюдение.
- Наблюдение выбираем на уровне контракта (HTTP-статус, тело ответа, возвращаемое значение), а не внутренних побочных эффектов, если только команда не договорилась иначе.
- Когда нужно проверить несколько следствий одного правила, разделяйте их на разные `it`. `:aggregate_failures` используйте лишь когда действительно говорите об одном поведении (см. пункт 14).

Тест — это короткое утверждение о поведении, а не мини-программа. Чем точнее формулировка `it`, тем легче читать спецификацию как документацию.

```ruby
# плохо: два поведения в одном it
it "creates a user" do
  expect { post_signup }.to change(User, :count)
  expect(response).to redirect_to dashboard_path
end

# хорошо: поведение разделено на два примера — каждое `it` формулирует своё правило
it "redirects user to dashboard after signup" do
  post_signup
  expect(response).to redirect_to dashboard_path
end

it "persists the user after signup" do
  expect { post_signup }.to change(User, :count)
end
```

Request-spec пример. Мы хотим убедиться, что авторизация успешна, и выбираем наблюдение на уровне API, а не БД:

```ruby
# плохо: тест читает базу и привязывается к реализации контроллера
it "creates a session" do
  post "/sessions", params: creds
  expect(Session.count).to eq 1
end

# хорошо: тест проверяет публичный контракт
it "returns an access token" do
  post "/sessions", params: creds
  expect(response).to have_http_status(:created)
  expect(response.parsed_body.fetch("token")).to be_present
end
```

Если в `it` появляется много `expect`, это обычно сигнал: мы пытаемся зафиксировать побочные эффекты вместо поведения. Типичный пример — регистрация пользователя и отправка welcome-письма. В request-spec мы проверяем статус/ответ API, а факт отправки письма опускаем на уровень юнит/сервисного теста (или возвращаемся к пирамиде и пишем отдельный сценарий, если письмо — самостоятельное правило). Не превращайте спецификацию поведения в маленькую программу: циклы, условные операторы и вычисления в тестах — прямой признак, что мы перестали описывать правила и начали переписывать реализацию.
Кто-то может сказать, что это накладно по ресурсам и лучше совмещать многие тесты в один `it`.

Да, действительно, это ускорит тесты по нескольким причинам:

1. Ожидания в одном `it` не изолированы друг от друга, из-за чего тестовые данные создаются для них один раз, что быстрее,
   чем создавать их много раз для каждого ожидания;
2. При падении первого ожидания, следующие не проверяются, что тоже экономит время.

Но смотрите к каким недостаткам это приводит:
1. Это делает менее читаемыми результаты тестов (вывод в консоли);
2. Это делает менее читаемым сам тест, его ожидания;
3. Будет не вполне понятно, какое именно ожидание соответствует описанию поведения в `it`;
4. Отсутствие изоляции делает менее надежными ожидания, они могут начать друг на друга влиять (но такое очень редко бывает);
5. Самое важное, что это может быть запахом плохого дизайна кода, который покрывается данными тестами.

   Если вы делаете ожидания на несколько разных вещей, то получается что ваш код делает тоже несколько разных вещей,
   а это нарушает данное правило:
    ```markdown
    Do One Thing
    
    FUNCTIONS SHOULD DO ONE THING. THEY SHOULD DO IT WELL.
    THEY SHOULD DO IT ONLY.
    
    * Clean Code Robert Martin
    ```
   Как видите, тестирование поведения отражает поведение самого кода и его изъяны. Если ваши тесты стали "слишком умными",
   то наверняка из-за того, что таковым является тестируемый код. Попробуйте разделить код на более простые части и
   тестировать их поведение отдельно, напишите сначала модульные тесты на каждую маленькую часть, покрывая их отдельное поведение.
   Потом напишите код, который будет использовать эти маленькие части, и уже для него напишие один простой интеграционный тест,
   а в нем проверяйте ожидаемое поведение, не привязываясь к деталям и поведению маленьких частей кода, которыми он пользуется.


### 7. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны составлять валидное предложение на английском языке.

Для примера оставим только описание тестов, без примера создания тестовых данных и изменений в контекстах:
```ruby
# отвратительно
describe "#some_action" do
  context "blocked" do # что заблокировано, когда, кем? что это вообще значит?
    context "month ago" do # месяц назад что? заблокирован? точно?
      it("true") { test } # что значит true? как оно оценивается?
    end
  end
end
# когда вы запустите тест он вернет вот такое непонятное описание
# #some_action user blocked month ago /it/ true

# идеально
describe "#some_action" do
  context "when user is blocked by admin" do # здесь понятно, кто, что и с кем сделал
    context "and blocking duration is over a month" do # а здесь уже понятно что это продолжение предложения, начатого в прошлом контексте
      it("allows unlocking the user") { test } # ага, теперь вообще понятно, зачем этот метод нужен, в чем его ценность
      # он определяет "можно ли разблокировать пользователя?"
    end
  end
end
# #some_action when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user 
```

### 8. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны быть написаны так, чтобы их понимал любой человек

Здесь имеется ввиду, что описание поведения должно быть абсолютно однозначно понятным и не требующим познания чего-то специфичного из программирования.
Вы должны быть в состоянии просто дать все описания тестов любому человеку, для того чтобы он в свою очередь прочитав их мог понять бизнес.

```
when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user
when user is blocked by admin but blocking duration is under a month /it/ does NOT allow unlocking the user
```
вполне понятное описание, по которому однозначно понятно, что разблокировать пользователя заблокированного менее месяца назад нельзя.

### 9. Каждый тест должен быть разделен на 3 этапа в строгой последовательности
1. Предварительное создание тестовых данных
2. Действие или предварительные вычисления над подготовленными тестовыми данными (необязательный этап)
3. Ожидание
```ruby
# отвратительно
describe "#block" do
  before do
    user = create :user # тестовые данные
    admin = create :admin # тестовые данные
    admin.block(user) # действие
  end
  
  it "true" do
    expect(User.find(1).bloсked).to eq true # ожидание
  end
end

# хорошо
describe "#block" do
  # 1 этап
  let(:user) { create :user } # создание тестовых данных 
  let(:admin) { create :admin }
  
  # 2 этап
  before { admin.block(user) } # действие/операция

  # 3 этап
  it "marks the user as blocked" do
    expect(user.blocked).to eq true # ожидание
  end
end
# или
describe "#block" do
   # 1 этап
   let(:user) { create :user } # создание тестовых данных
   let(:admin) { create :admin }
   
   it "marks the user as blocked" do
      # 2 этап
      admin.block(user) # действие/операция

      # 3 этап
      expect(user.blocked).to eq true # ожидание
   end
end
# но лучше по возможности переносить действие и любые runtime вычисления в before.
```

### 10. Каждый контекст должен отражать различие вложенной части от внешней

Можно ещё сказать так: если у вас есть контекст, внутри которого между `context "..." do` и `it` пусто, это чисто
синтаксический контекст. Он либо не нужен вовсе, либо не содержит настройки, соответствующей описанию контекста.

Правило можно сформулировать иначе: настройка, которая делает контекст истинным, должна находиться сразу после строки `context "..." do`.
Не заставляйте читателя искать по всему тесту, где именно выполняется подготовка под указанное состояние.

```ruby
# Есть пользователи и метод some_action, позволяющий определить, можно ли пользователя разблокировать.
# У пользователей есть состояния `blocked`, `blocked_at`.

# плохо
describe "#some_action" do
  let(:user) { build :user }
  let(:blocked_user) { build :user, blocked: true }
  let(:old_blocked_user) { build :user, blocked: true, blocked_at: 2.month.ago }

  it "does NOT allow unlocking the user" do
    expect(user.some_action).to eq false
  end
  
  context "when user is blocked by admin" do # есть контекст
    # нет никакой настройки, которая делает его отличным от внешнего блока
    it "allows unlocking the user" do
      expect(blocked_user.some_action).to eq true
    end
    
    context "and blocking duration is over a month" do 
      # Что отличает этот контекст от внешнего? В большом тесте искать настройку будет невозможно.
      # Экономьте свой и чужой труд — размещайте подготовку сразу под контекстом, там её все и ожидают увидеть.
      it "allows unlocking the user" do
        expect(old_blocked_user.some_action).to eq true
      end
    end
  end
end

# хорошо
describe "#some_action" do
  let(:blocked) { false } # базовое состояние характеристики `blocked`
  let(:blocked_at) { nil } # базовое состояние характеристики `blocked_at`
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  subject(:result) { user.some_action }

  it "does NOT allow unlocking the user" do
    expect(result).to eq false
  end

  context "when user is blocked by admin" do
    let(:blocked) { true } # настройка этого контекста — на своём месте, сразу заметна

    context "and blocking duration is over a month" do
      let(:blocked_at) { 2.month.ago } # настройка вложенного контекста — здесь же, под объявлением

      it "allows unlocking the user" do
        expect(result).to eq true
      end
    end

    context "but blocking duration is under a month" do
      let(:blocked_at) { 1.month.ago } # отрицательное состояние характеристики `blocked_at`

      it "does NOT allow unlocking the user" do
        expect(result).to eq false
      end
    end
  end
end
```

Кроме того, настройка контекста может быть вычислимой операцией — например, располагаться внутри `before`.

### 11. Грамматика формулировок в describe/context/it

Мы описываем устойчивое поведение системы, поэтому формулировки должны звучать как правила предметной области, а не как инструкции тестировщику.

1. **Present Simple.** Поведение считается верным всегда, поэтому говорим о нем в настоящем времени: `it 'returns the summary'`. Настоящее простое время делает фразу универсальной и убирает ощущение временности.
2. **Активный залог в `it`, третье лицо.** Субъектом предложения выступает объект системы: `order generates invoice`, `service authenticates user`. Так читающий понимает, кто выполняет действие, и предложение остается коротким.
3. **Пассивный залог и глаголы-состояния для контекстов.** Контекст задает состояние характеристики, поэтому используем форму `is/are + V3` или короткие конструкции со статичным глаголом: `when user is blocked`, `when account has balance`. Так мы фиксируем факт состояния, а не действие, которое к нему привело.
4. **Zero conditional для связки условия и результата.** В паре `context/it` обе части остаются в Present Simple: `when payment is confirmed, it issues receipt`. Такая структура читается как бизнес-правило «если … то …» без временных сдвигов.
5. **Без модальных глаголов и лишних слов.** Избегаем `should`, `can`, `must` и вводных конструкций (`it should`, `it is expected that`). Остается декларация поведения — она короче и лучше ложится в отчеты.
6. **Явное отрицание `NOT`.** Негативные сценарии выделяем капсом: в контекстах — `when user is NOT verified`, в примерах — `it 'does NOT unlock user'`. Так в отчете сразу видно, что падает отрицательный кейс.

Минимальный шаблон: объект и характеристику описываем в `describe`, условия — через `context` в пассивном залоге, ожидаемую реакцию — через `it` в активном Present Simple.

```ruby
describe OrderMailer do
  context 'when invoice is generated' do
    it 'sends the invoice email'
  end
end
```

### 12. Язык контекстов: when / with / and / without / but / NOT

Следуем логике Gherkin, чтобы контексты читались как последовательность условий. Каждая связка отвечает типу состояния и уровню вложенности.

- **`when …`** — открывает ветку и описывает состояние базовой характеристики. На этом уровне часто нет `it`, потому что дальше ветка уточняется. Пример: `context 'when user has a payment card' do … end`.
- **`with …`** — вводит первое уточняющее положительное состояние и продолжает happy path: `context 'with verified email'`.
- **`and …`** — добавляет ещё одно положительное состояние в том же направлении. Можно использовать несколько подряд, пока ветка остаётся частью happy path: `context 'and balance covers the price'`.
- **`without …`** — используем для бинарных характеристик, когда явно показываем обе полярности. Happy path описан положительным состоянием, поэтому ветка `without …` сразу содержит тест, демонстрирующий альтернативный исход: `context 'without verified email' do … end`.
- **`but …`** — подчёркивает противопоставление happy path. Часто применяется, когда happy path основан на состоянии по умолчанию (отдельный `with`-контекст не нужен). Контекст `but …` обязан содержать тест, показывающий, как меняется поведение при нарушении базового условия: `context 'but balance does NOT cover the price'`.
- **`NOT`** — используем капсом внутри названия контекста или `it`, чтобы подчеркнуть отрицательное состояние бинарной характеристики либо выделить отрицательный тест: `context 'when user does NOT have a payment card'`, `it 'does NOT charge the card'`.

Рекомендуемая последовательность внутри ветки: `when` → `with` → `and` (по необходимости) → `but`/`without` → `it`. Как только условия полностью описаны, добавляем пример: happy path или corner case.

```ruby
describe '#charge' do
  context 'when user has a payment card' do                      # базовая характеристика
    context 'with verified email' do                            # happy path уточнение
      context 'and balance covers the price' do                 # ещё одно happy path состояние
        it 'charges the card'                                   # happy path case
      end

      context 'but balance does NOT cover the price' do         # corner case: противопоставление
        it 'does NOT charge the card'                           # отрицательный тест
      end
    end

    context 'without verified email' do                         # corner case: отсутствие обязательного состояния
      it 'does NOT charge the card'
    end
  end

  context 'when user does NOT have a payment card' do           # другая ветка для бинарной характеристики
    it 'does NOT charge the card'
  end
end
```

Следите, чтобы happy path ветка шла первой на своём уровне, а контексты с `without`/`but` логически ссылались на неё: «когда всё хорошо → что происходит; но если условие нарушается → как меняется результат».

Иногда happy path строится на значении по умолчанию, и дополнительный `with`-контекст не нужен — пример можно разместить сразу под `when`. Corner case всё так же раскрывается через `but` или `without` на том же уровне.

```ruby
describe '#authenticate' do
  context 'when account exists' do                        # базовая ветка
    it 'signs the user in'                                # happy path сразу под when

    context 'but account is blocked' do                   # corner case на том же уровне
      it 'denies the sign-in'
    end
  end

  context 'when account does NOT exist' do                # противопоставление на уровне контекста
    it 'denies the sign-in'
  end
end
```


### 13. Не используйте [any_instance](https://rspec.info/features/3-13/rspec-mocks/old-syntax/any-instance/), allow_any_instance_of, expect_any_instance_of

В большинстве случаев это "запах" к тому, что вы не следуете `dependency inversion principle`,
или, что ваш класс не следует `single responsibility` и объединяет в себе код для двух акторов,
которые в свою очередь зависят друг от друга в одностороннем порядке.
Таким образом, ваш класс можно разбить на два класса поменьше, для которых в свою очередь можно покрыть тестами их поведение в отдельных тестах.
Справедливости ради, следовать этому правилу не очень просто тогда, когда у вас накопился гигантский технический долг, поэтому это правило может иметь исключения.

Подробнее о том, почему его не стоит использовать читайте здесь https://rspec.info/features/3-13/rspec-mocks/working-with-legacy-code/any-instance/.
```ruby
# плохо
class HighLevelClass
   def some_method
      data = LowLevelClass.foo

      data.uniq.select { some code }.map { some code }
   end
end

describe HighLevelClass do
   let(:some_data) { build :some_data }

   before do
      allow_any_instance_of(LowLevelClass).to receive(:foo).and_return({some_key: :some_value}) # замокали все обьекты этого класса глобально
   end

   it "returns the processed value" do
      expect(HighLevelClass.new.some_method).to eq(:some_expected_value)
   end
end

# хорошо
class HighLevelClass
   def initialize(low_level_dependency = LowLevelClass)
      @low_level_dependency = low_level_dependency # Произвели инверсию зависимости
   end

   def some_method
      data = low_level_dependency.foo

      data.uniq.select { some code }.map { some code }
   end
end

describe HighLevelClass do
   let(:some_data) { build :some_data }
   let(:low_level_dependency) { instance_double(LowLevelClass) }
   let(:instanse) { HighLevelClass.new(low_level_dependency) } # теперь зависимость можно просто подставить через new

   before do
      allow(low_level_dependency).to receive(:foo).and_return({some_key: :some_value})
      # теперь мы просто разрешаем вернуть нужное нам значение одному instance double,
      # причем будет проверка что такой метод действительно есть у данного класса.
      # таким образом при рефакторинге интерфейса класса, данный тест может предупредить сломанную зависимость других классов
   end

   it "returns the processed value" do
      expect(instanse.some_method).to eq(:some_expected_value)
   end
end
```
### 14. Используйте `:aggregate_failures` только когда описываете одно правило

По умолчанию один `it` содержит одну проверку. `:aggregate_failures` полезен, когда подготовка тяжёлая или дорогостоящая, но мы всё ещё говорим об одном поведении и хотим увидеть все нарушения сразу (например, проверяем несколько полей одного JSON-ответа).

- Не применяйте флаг, чтобы спрятать разные поведения в одном `it` — так вы нарушаете правило 6 («Каждый example (`it`) описывает одно наблюдаемое поведение»).
- Используйте `:aggregate_failures`, только если все ожидания описывают один и тот же бизнес-исход и зависят от одной подготовки данных.
- Даже с флагом держите описание конкретным и коротким, чтобы было понятно, что именно сломалось.

```ruby
# плохо: два независимых поведения в одном примере
describe Notifier do
  describe '#call', :aggregate_failures do
    it 'sends email and logs event' do
      expect { subject.call }.to change(EmailDelivery, :count)
      expect(logs).to include('event stored')
    end
  end
end

# хорошо: поведения разделены
describe Notifier do
  describe '#call' do
    it 'sends email' do
      expect { subject.call }.to change(EmailDelivery, :count)
    end

    it 'logs event' do
      subject.call
      expect(logs).to include('event stored')
    end
  end
end

# допустимо: один ответ с несколькими проверками
describe SessionsController do
  describe 'POST /sessions', :aggregate_failures do
    it 'returns token payload' do
      post '/sessions', params: creds
      expect(response).to have_http_status(:created)
      expect(response.parsed_body).to include('token', 'expires_at')
    end
  end
end
```
### 15. Изучите подробно правила из rubocop по части наименования https://rspec.rubystyle.guide/#naming

### 16. Предпочитайте request specs вместо controller specs

Controller specs считаются устаревшими: Rails core и RSpec core команды официально рекомендуют писать request specs, начиная с релиза RSpec 3.5 и Rails 5.0 ([подробнее](https://rspec.info/blog/2016/07/rspec-3-5-has-been-released/#rails-support-for-rails-5)). Request specs проверяют HTTP-контракт, а значит остаются ближе к наблюдаемому поведению и не зависят от внутренних контроллерных фильтров.

- Для новых тестов выбирайте request specs; только они покрывают стек Rack → контроллер → middleware целиком и показывают, что увидит клиент.
- Если приходится поддерживать legacy controller specs, помечайте их как наследие (например, `describe SomeController, :legacy`) и планируйте миграцию. При доработках расширяйте по пирамиде: поведение — в request spec, мелкую логику выносите в сервис/модель и покрывайте юнитами.
- Не дублируйте проверки: если действие уже описано на уровне request spec, controller spec лишь повторит реализацию и будет ломаться при рефакторинге маршрутов или фильтров.

### 17. Стабилизируйте время через `ActiveSupport::Testing::TimeHelpers`

Rails даёт модуль [`ActiveSupport::Testing::TimeHelpers`](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/Testing/TimeHelpers.html), который нужно подключать в тестах вместо ручного управления временем. Его ключевые методы (`freeze_time`, `travel_to`, `travel`, `travel_back`) замораживают `Time.zone` и очищают отложенные задачи, помогая избежать flaky тестов.

- Если вызываете `freeze_time` или `travel_to` без блока (например, в `before`), обязательно добавляйте `after { travel_back }`. Эти методы автоматически откатывают время только в блочной форме (`freeze_time { example.run }`, `travel_to(time) { ... }`), где модуль вызовет `travel_back` в `ensure`. Ручное изменение `Time.now` без обратного вызова оставит глобальное состояние и приведёт к плавающим падениям.
- В Rails-тестах опирайтесь на `Time.zone.now`/`Time.current` и методы `5.minutes`/`2.days`, чтобы расчёты учитывали часовой пояс приложения. `Time.now` и `Date.today` игнорируют зону — с ними легче получить несогласованность с `created_at`.
- При работе с ActiveJob/ActionMailer не забывайте, что `freeze_time` фиксирует таймеры. Если в примере запускается джоб с `wait_until`, возвращайте время в `after`, иначе последующие тесты будут ждать «прошлого».

В сумме: «заморозили — откатили». Любое отклонение ведёт к случайным, трудно воспроизводимым багам.

### 18. Не программируйте в тестах

Тест — это спецификация поведения, а не место для написания мини-фреймворков. Когда вместо декларативных `let`, фабрик и helper-методов появляются приватные утилиты с прямой работой с БД, тест перестаёт быть читаемым и надёжным.

```ruby
# ужасный пример
describe SomeService do
  it 'stores report' do
    result = described_class.call(raw_payload)

    expect(result).to be_success
    expect(find_report(result.id)).to have_attributes(status: 'done', rows: 3)
  end

  private

  def raw_payload
    DB[:reports].insert(name: 'daily', data: '{"rows":[1,2,3]}')
    DB[:reports].where(name: 'daily').first
  end

  def find_report(id)
    DB[:reports].where(id: id).first
  end
end
```

- Приватные методы скрывают подготовку: читателю нужно «выполнить» код в голове, чтобы понять состояния характеристик.
- Прямая работа с БД минует фабрики/фикстуры и создаёт жёсткую привязку к схеме.
- При изменении структуры таблиц тесты ломаются молча или дают нечитаемые ошибки.
- Если подобный стиль кажется удобным, это тревожный сигнал: такая запись тяготеет к assert-style-DSL вроде minitest. В RSpec же мы описываем поведение, а не переписываем код тестового фреймворка.

```ruby
# хорошо
describe SomeService do
  let(:report) { create(:report, :daily, :with_rows) }
  subject(:result) { described_class.call(report.payload) }

  it 'stores report' do
    expect(result).to be_success
    expect(report.reload).to have_attributes(status: 'done', rows_count: 3)
  end
end
```

- `let` с фабрикой явно описывает характеристику (`report` со статусом и данными).
- В ожиданиях используем публичный интерфейс (`reload`, атрибуты), а не SQL-обходные пути.
- При смене схемы адаптируем фабрику — тесты остаются декларативными и следуют глоссарию характеристик.

Это правило тесно связано с пунктами 1, 5 и 10: мы описываем поведение, не смешиваем разные сценарии и держим подготовку рядом с контекстом.

### 19. Используйте shared examples для проверки разделяемого поведения

`shared_examples` служат для проверки общего поведения разных объектов. Они не про DRY ради снижения строк кода — тесты мы не «программируем» (см. пункт 18), они описывают правила. Если поведение повторяется, выносите именно его описание и ожидаемые наблюдения.

- Название `shared_examples` формулируйте через поведение: `'an enumerable resource'`, `'a pageable API'`, `'a collection of orders'`. Так в выводе RSpec видно, какое правило описывается.
- Применяйте `it_behaves_like`/`it_should_behave_like` там, где объект реально реализует контракт: например, класс включает модуль с общими методами (`Enumerable`, ваш `Paginatable` mixin).
- Внутри shared examples работайте только с публичным интерфейсом, ожидая то же поведение, которое проверял бы отдельный тест.

```ruby
# shared_examples: spec/support/shared_examples/paginatable.rb
RSpec.shared_examples 'a pageable API' do
  it 'returns the second page' do
    expect(resource.paginate(page: 2).current_page).to eq 2
  end

  it 'limits page size' do
    expect(resource.paginate(page: 1, per_page: 5).items.count).to eq 5
  end
end

# использование
describe OrdersQuery do
  subject(:resource) { described_class.new(scope: Order.all) }

  it_behaves_like 'a pageable API'
end

describe UsersQuery do
  subject(:resource) { described_class.new(scope: User.active) }

  it_behaves_like 'a pageable API'
end
```

- Shared example формулирует «что значит быть pageable», без нелепых «general behaviour».
- Каждый класс, включающий модуль `Paginatable`, подключает shared example и доказывает, что контракт выполняется.
- Если нужно добавить новую характеристику (например, сортировку), расширяете shared example — все клиенты автоматически проверяют обновлённый контракт.

Использование shared examples не отменяет требования писать осмысленные контексты и `it`. Они помогают избежать дублирования поведения, но не подменяют понятные спецификации.

### 20. Делайте вывод падения теста читаемым

Перед тем как зафиксировать пример, представьте, что он упал: текст, который увидит команда, должен мгновенно объяснить ожидаемое и фактическое поведение. Если приходится вычитывать десятки строк разрозненного вывода, тест требует переработки.

```ruby
# ужасный пример
it 'returns response payload' do
  expect(response.body).to eq(
    "{\"meta\":{\"status\":\"ok\",\"total\":3},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":2,\"name\":\"Bob\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[]}"
  )
end

# предполагаемый вывод при падении:
# expected: "{\"meta\":{\"status\":\"ok\",\"total\":3},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":2,\"name\":\"Bob\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[]}"
#      got: "{\"meta\":{\"status\":\"ok\",\"total\":2},\"data\":[{\"id\":1,\"name\":\"Alice\"},{\"id\":3,\"name\":\"Carol\"}],\"errors\":[\"missing Bob\"]}"
# (Compared using ==)
#
# Здесь две многострочные строки без форматирования; чтобы заметить расхождение, нужно вручную искать отличия в кавычках.
```

```ruby
# хорошо
describe 'GET /users' do
  subject(:payload) { JSON.parse(response.body, symbolize_names: true) }

  it 'returns metadata and users' do
    expect(payload.fetch(:meta)).to include(status: 'ok', total: 3)
    expect(payload.fetch(:data)).to match_array([
      include(id: 1, name: 'Alice'),
      include(id: 2, name: 'Bob'),
      include(id: 3, name: 'Carol')
    ])
    expect(payload.fetch(:errors)).to be_empty
  end
end

# Падение покажет структурный дифф, например:
# expected collection contained: [{:id=>1, :name=>"Alice"}, {:id=>2, :name=>"Bob"}, {:id=>3, :name=>"Carol"}]
# actual collection contained:   [{:id=>1, :name=>"Alice"}, {:id=>3, :name=>"Carol"}]
# the missing elements were:     [{:id=>2, :name=>"Bob"}]
# the extra elements were:       []
# => видно, что отсутствует пользователь Bob и нарушена мета-информация.
```

- Используйте структурные ожидания (`match_array`, `include`, `have_attributes`), чтобы RSpec показывал предметный дифф.
- Форматируйте сложные данные перед сравнением (`JSON.parse`, `hash.deep_symbolize_keys`). Сырые строки или SQL-дампы в падении почти бесполезны.
- Если matcher не даёт достаточной ясности, напишите helper, который вернёт компактное описание расхождения (но не превращайтесь в mini-программу — см. пункт 18).
- В конечных request-тестах не сравнивайте огромные JSON через дифф-матчеры «побайтно»: такая привязка к деталям приводит к постоянным падениям при малейших изменениях и в 95% случаев рождает flaky тесты. Для проверки интерфейса используйте специализированные инструменты генерации спецификаций — например, `rspec-openapi` для автоматического слепка и сравнения OpenAPI или RSwag, если нужно поддерживать Swagger-документацию. Эти решения точнее и эффективнее фиксируют контракт, чем ручные diff-ожидания, а при необходимости можно подключать и другие подходы (Pact, contract-тесты на уровне инфраструктуры).

### 21. Предпочитайте verifying doubles (`instance_double`, `class_double`, `object_double`)

`double` создаёт «анонимный» двойник без проверки интерфейса. Он позволяет замокать несуществующие методы и пропустить регрессию, когда контракт меняется. `instance_double`, `class_double` и `object_double` проверяют интерфейс реальных объектов и защищают от ложных зелёных тестов.

```ruby
# плохо: generic double пропускает опечатки
let(:gateway) { double('PaymentGateway', charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end

# если реальный PaymentGateway переименовал метод в `charge!`,
# тест останется зелёным — double не знает, что интерфейс изменился.
```

```ruby
# хорошо: verifying double ловит рассинхронизацию
let(:gateway) { instance_double(PaymentGateway, charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end

# При переименовании метода RSpec сообщит:
#   the PaymentGateway class does not implement the instance method: charge
# и тест упадёт, защищая от скрытой регрессии.
```

- `instance_double(SomeClass)` проверяет методы экземпляра `SomeClass`.
- `class_double(SomeClass)` — методы самого класса (например, `.find`, `.call`).
- `object_double(existing_object)` — фиксирует интерфейс конкретного объекта (удобно для зависимостей, построенных в тесте).

**Когда verifying double использовать нельзя:**

- Класс или модуль создаётся динамически и ещё не загружен в момент выполнения теста (`require` отсутствует).
- Интерфейс формируется через `method_missing`/`respond_to_missing?`, и в спецификации нет сигнатур, которые можно проверить (например, `OpenStruct`, `Hashie::Mash`).
- Вы мокаете внешний сервис, у которого нет Ruby-класса (SOAP/XML API), и эмуляция происходит через `Struct.new` или обёртку на лету.

В этих редких ситуациях:

- Документируйте причину (`let(:gateway) { double('LegacyGateway') } # нет реального класса, метод задаётся в runtime`).
- Ограничьте контракт явными `allow(...).to receive(:method)` и добавьте интеграционный тест, который проверит реальное взаимодействие.

Во всех остальных случаях выбирайте verifying doubles — это дешёвый способ поймать опечатку ещё до запуска приложения.

### 22. Используйте возможности FactoryBot для скрытия деталей подготовки

Если в проекте есть FactoryBot, используйте его, чтобы тесты оставались читабельными и фиксировали только характеристики и их состояния (см. глоссарий).

- Дефолтная фабрика должна создавать «средний» объект, который подходит для happy path. Всё, что не участвует в описании контекста, прячьте внутрь фабрики.
- В повторяющихся сценариях оформляйте состояния через трейты: `:blocked`, `:with_verified_email`, `:expired`. Трейты можно свободно комбинировать (`create(:user, :blocked, :verified)`), получая нужные состояния без копипаста. Контексту не нужно перечислять вспомогательные поля, достаточно упомянуть характеристику.
- Избегайте ручной передачи десятков атрибутов в `create`. Если требуется много явных значений, возможно, фабрику стоит уточнить или выделить новую характеристику.

```ruby
# ужасный пример
describe '#unlock' do
  let(:user) do
    create(:user,
           blocked: true,
           blocked_at: 2.months.ago,
           email_confirmed: true,
           last_sign_in_at: 1.day.ago,
           otp_required: false)
  end

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

```ruby
# хорошо
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { 'secret123' }

    trait :blocked do
      blocked { true }
      blocked_at { 2.months.ago }
    end

    trait :verified do
      email_confirmed { true }
    end
  end
end

describe '#unlock' do
  let(:user) { create(:user, :blocked, :verified) }

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

- Трейты документируют состояния характеристик и избавляют от громоздких setup-блоков.
- Читатель видит только важные аспекты (`:blocked`, `:verified`) и быстро соотносит их с описанием контекста.
- Изменения дефолтных атрибутов происходят в фабрике, поэтому тесты не «захламляются» технической подготовкой.

Такая дисциплина делает тесты чище, легче для поддержки и лучше подчёркивает бизнес-поведение.

Дополнительно: хороший обзор приёмов работы с трейтами есть у Thoughtbot — [Remove duplication with FactoryBot’s traits](https://thoughtbot.com/blog/remove-duplication-with-factorybots-traits).

## Нюансы времени между Ruby и PostgreSQL

- `Date#wday` возвращает 0 для воскресенья, в то время как `EXTRACT(DOW FROM ...)` в PostgreSQL даёт 0 по воскресеньям и 1 по понедельникам. Совмещая Ruby- и SQL-проверки в тестах, явно фиксируйте ожидаемый день недели и не сравнивайте цифры «как есть».
- `Date.current.beginning_of_week` подчиняется `Rails.application.config.beginning_of_week`, а `date_trunc('week', ...)` в PostgreSQL по ISO всегда стартует с понедельника. Если приложение работает с календарём, добавляйте тесты, которые проверяют корректный «первый день недели» через публичный интерфейс, иначе легко получить flaky тест при смене настройки.
- `Date.parse` и `Time.parse` игнорируют `Time.zone`, тогда как ActiveRecord сохраняет `timestamp` в UTC. В тестах, где важна зона, используйте `Time.zone.parse`, `Time.zone.local` и `in_time_zone`, а ожидания выносите в `Time.zone.at`/`change`.
- Переходы через полночь и DST: PostgreSQL вычисляет интервалы UTC-значениями, а Ruby при `travel_to` может попасть в «не существующий» час. Чтобы не ловить плавающие падения, фиксируйте время в середине дня (`travel_to(Time.zone.parse('2024-03-25 12:00'))`) и пишите отдельные примеры на переходы, если бизнес-процесс затрагивает крайние точки.
