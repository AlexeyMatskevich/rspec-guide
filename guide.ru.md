# Оглавление

## Философия и основы
- [Что можно изучить по тестам](#что-можно-изучить-по-тестам)
- [Про RSpec](#про-rspec)
  - [Как связаны RSpec, BDD и TDD](#как-связаны-rspec-bdd-и-tdd)
  - [Зачем нам BDD на практике](#зачем-нам-bdd-на-практике)
  - [От естественного языка к формальному синтаксису Gherkin](#от-естественного-языка-к-формальному-синтаксису-gherkin)
  - [Пирамида тестирования и выбор уровня](#пирамида-тестирования-и-выбор-уровня)
- [Глоссарий](#глоссарий)
  - [Основные понятия](#основные-понятия)
  - [Виды тестирования](#виды-тестирования)
  - [Принципы проектирования](#принципы-проектирования)
  - [Характеристики и состояния](#характеристики-и-состояния)
- [Почему мы пишем тесты именно так: когнитивная нагрузка](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка)
  - [Три типа когнитивной нагрузки в тестах](#три-типа-когнитивной-нагрузки-в-тестах)
  - [Как правила снижают когнитивную нагрузку](#как-правила-снижают-когнитивную-нагрузку)
  - [Как тесты выявляют проблемы дизайна](#как-тесты-выявляют-проблемы-дизайна)

## Краткая справка
- [Все правила одним списком](#все-правила-одним-списком)
- [Быстрая диагностика: "Почему мой тест плохо пахнет?"](#быстрая-диагностика-почему-мой-тест-плохо-пахнет)

## RSpec Style Guide

### Поведение и структура тестов
- [1. Тестируйте поведение, а не реализацию](#1-тестируйте-поведение-а-не-реализацию)
- [2. Проверяйте, что тест тестирует](#2-проверяйте-что-тест-тестирует)
- [3. Каждый example (`it`) описывает одно наблюдаемое поведение](#3-каждый-example-it-описывает-одно-наблюдаемое-поведение)
  - [3.1. Исключение для интерфейсного тестирования](#31-исключение-для-интерфейсного-тестирования)
  - [3.2. Работа с большими интерфейсами](#32-работа-с-большими-интерфейсами)
- [4. Выделяйте характеристики поведения и их состояния](#4-выделяйте-характеристики-поведения-и-их-состояния)
- [5. Стройте иерархию `context` по зависимостям характеристик](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases)
- [6. Финальный аудит контекстов: два типа дубликатов](#6-финальный-аудит-контекстов-два-типа-дубликатов)
- [7. Располагайте happy path перед corner cases](#7-располагайте-happy-path-перед-corner-cases)
- [8. Пишите положительный и отрицательный тест](#8-пишите-положительный-и-отрицательный-тест)
- [9. Каждый контекст должен отражать различие вложенной части от внешней](#9-каждый-контекст-должен-отражать-различие-вложенной-части-от-внешней)

### Синтаксис и читаемость
- [10. Указывайте `subject`, чтобы явно обозначить предмет тестирования](#10-указывайте-subject-чтобы-явно-обозначить-предмет-тестирования)
- [11. Каждый тест должен быть разделен на 3 этапа](#11-каждый-тест-должен-быть-разделен-на-3-этапа-в-строгой-последовательности)

### Подготовка контекста и данных
- [FactoryBot и подготовка данных](#factorybot-и-подготовка-данных)
  - [12. Используйте возможности FactoryBot](#12-используйте-возможности-factorybot-для-скрытия-деталей-исходных-данных)
  - [13. Используйте `attributes_for` для генерации параметров](#13-используйте-attributes_for-для-генерации-параметров-которые-не-являются-важной-деталью-в-тестировании-поведения)
  - [14. В юнит-тестах используйте `build_stubbed`](#14-в-юнит-тестах-кроме-моделей-используйте-build_stubbed)
  - [Выбор метода FactoryBot: Decision Tree](#выбор-метода-factorybot-decision-tree)
- [15. Не программируйте в тестах](#15-не-программируйте-в-тестах)
- [16. Явность важнее DRY](#16-явность-важнее-dry)

### Язык описания спецификаций
- [17. Описание должно составлять валидное предложение](#17-описание-контекстов-context-и-тестовых-кейсов-it-вместе-включая-it-должны-составлять-валидное-предложение-на-английском-языке)
- [18. Описание должно быть понятно любому человеку](#18-описание-контекстов-context-и-тестовых-кейсов-it-вместе-включая-it-должны-быть-написаны-так-чтобы-их-понимал-любой-человек)
- [19. Грамматика формулировок в describe/context/it](#19-грамматика-формулировок-в-describecontextit)
- [20. Язык контекстов: when / with / and / without / but / NOT](#20-язык-контекстов-when--with--and--without--but--not)
- [21. Правила Rubocop по наименованию](#21-изучите-подробно-правила-из-rubocop-по-части-наименования)

### Инструменты и поддержка
- [22. Не используйте `any_instance`](#22-не-используйте-any_instance)
- [23. Используйте `:aggregate_failures` только когда описываете одно правило](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило)
  - [Руководство по принятию решения: один `it` или несколько?](#руководство-по-принятию-решения-один-it-или-несколько)
  - [Паттерны тестирования: до/после](#паттерны-тестирования-допосле)
- [24. Предпочитайте verifying doubles](#24-предпочитайте-verifying-doubles-instance_double-class_double-object_double)
- [25. Используйте shared examples для декларации контрактов](#25-используйте-shared-examples-для-декларации-контрактов)
- [26. Предпочитайте Request specs вместо controller specs](#26-предпочитайте-request-specs-вместо-controller-specs)

## Специализированные разделы
- [Тестирование API-контрактов: границы применимости RSpec](#тестирование-api-контрактов-границы-применимости-rspec)
  - [Полный гайд по API-контрактам](guide.api.ru.md)
- [Внешние сервисы](#внешние-сервисы)
- [Нюансы времени между Ruby и PostgreSQL](#нюансы-времени-между-ruby-и-postgresql)

## Практические руководства
- [Миграция от implementation-focused к behavior-focused тестам](#миграция-от-implementation-focused-к-behavior-focused-тестам)
- [Рефакторинг глубоких иерархий контекстов](#рефакторинг-глубоких-иерархий-контекстов)
- [Внедрение структуры по характеристикам в существующие тесты](#внедрение-структуры-по-характеристикам-в-существующие-тесты)

# Что можно изучить по тестам

- **Better Specs** — стиль и формулировки: научитесь писать читаемые `describe/context/it`, выбирать матчеры и избегать анти-паттернов. <https://www.betterspecs.org>
- **Testing for Beginners** — вводная книга: поймёте, что тестировать, как мыслить сценариями и разбирать красные тесты. <http://testing-for-beginners.rubymonstas.org/index.html>
- **Pluralsight: RSpec Ruby Application Testing** — hands-on курс: шаг за шагом построите BDD-цикл, закрепите структуру `describe/context/it` и три фазы теста. <https://www.pluralsight.com/courses/rspec-ruby-application-testing>
- **Everyday Rails Testing with RSpec** — практики и инструменты: от factory_bot до VCR/WebMock, плюс ежедневные паттерны поддержки базового покрытия. <https://leanpub.com/everydayrailsrspec>

Эти материалы дадут базу. Ниже — философия RSpec/BDD, на которой держатся правила из следующего раздела.

# Про RSpec

RSpec — тестовая библиотека для Ruby с DSL, заточенным под описание поведения, а не внутренней реализации.

```ruby
describe "my app" do
  it "works" do
    expect(MyApp.working).to eq(true)
  end
end
```

Официальный слоган на <https://rspec.info/>:

```
Behaviour Driven Development for Ruby.
Making TDD Productive and Fun.
```

Ключевая мысль: RSpec — инструмент BDD для Ruby. Он делает практику TDD продуктивной и более "человечной" за счет языка, близкого к бизнес-формулировкам.

## Как связаны RSpec, BDD и TDD

TDD (test-driven development) — короткий цикл Red -> Green -> Refactor:

- пишем тест, фиксирующий желаемое поведение;
- пишем минимальный код, чтобы тест прошел;
- рефакторим, сохраняя зеленое состояние.

BDD (behaviour-driven development) вырос из TDD и смещает фокус на поведение [домена](#домен) и язык разговора с бизнесом. Тесты становятся читаемой спецификацией, а не просто проверкой кода.

RSpec воплощает BDD в экосистеме Ruby: `describe/context/it` помогают формулировать поведение единообразно и понятно.

## Зачем нам BDD на практике

- Единый язык с бизнесом: формулируем правила [домена](#домен) "человеческими" фразами, не зная реализации.
- Исполняемая документация: тесты — проверяемая спецификация поведения.
- Быстрая локализация проблем: упавший тест явно показывает, какое правило нарушено.
- Свободный рефакторинг: фокус на том, что делает система, а не как она устроена.

**Предметная область** — набор правил и понятий, которые бизнес хочет видеть в системе (например, биллинг). В коде мы реализуем именно эти правила поведения.

## От естественного языка к формальному синтаксису Gherkin

BDD часто опирается на Gherkin — формальный, но читаемый синтаксис для описания историй и сценариев. Он фиксирует три ключевые фазы: Given (исходный контекст), When (действие), Then (результат).

Пример истории и сценариев:

```
As a store owner
In order to keep track of stock
I want to add items back to stock when they're returned.

Scenario 1: Refunded items should be returned to stock
  Given that a customer previously bought a black sweater from me
  And I have three black sweaters in stock
  When they return the black sweater for a refund
  Then I should have four black sweaters in stock

Scenario 2: Replaced items should be returned to stock
  Given that a customer previously bought a blue garment from me
  And I have two blue garments in stock
  And three black garments in stock
  When they return the blue garment for a replacement in black
  Then I should have three blue garments in stock
  And two black garments in stock
```

И адаптация на русском:

```ruby
Как владелец магазина
Чтобы следить за запасами на складе
Я хочу возвращать товары на склад, когда их возвращают покупатели.

Сценарий 1: Возвращенные товары должны вернуться на склад
  Дано, что клиент ранее купил у меня черный свитер
  И на складе есть три таких свитера
  Когда клиент возвращает свитер
  Тогда на складе должно быть четыре черных свитера

Сценарий 2: Обмененные товары должны вернуться на склад
  Дано, что клиент покупал у меня одежду синего цвета
  И на складе есть два таких наименования синего цвета
  И три наименования черного цвета
  Когда клиент возвращает синюю вещь, чтобы обменять на черную
  Тогда на складе должно быть три синих наименования
  И два черных наименования
```

### Язык Gherkin — памятка

| Ключевое слово (EN) | Русский | Короткое описание |
| --- | --- | --- |
| Story / Feature | История | Заголовок спецификации, формулирует ценность. |
| As a | Как (в роли) | Роль заинтересованного лица. |
| In order to | Чтобы достичь | Цель роли. |
| I want to | Я хочу | Краткий желаемый результат. |
| Scenario | Сценарий | Конкретный сценарий истории. |
| Given | Дано | Исходный контекст (повторяется через And). |
| When | Когда | Действие, запускающее сценарий. |
| Then | Тогда | Наблюдаемый результат (можно добавлять And/But). |
| And / But | И / Но | Уточнение контекста или исключения. |

### Как это соотносится с RSpec

RSpec не требует Gherkin и не исполняет `.feature`-файлы, но следует тем же смысловым фазам:

- **Given** -> подготовка контекста (`let`, `before`, вспомогательные методы).
- **When** -> действие, которое проверяем (вызов метода, HTTP-запрос, команда).
- **Then** -> ожидаемый результат (`expect`-утверждения).
- **Feature / Story** -> верхний уровень `describe`, задающий область поведения.
- **Scenario** -> `it`, конкретный пример поведения.
- **And / But** -> уточнение контекста через вложенные `context`.

Это не механическое соответствие один-к-одному, но такая оптика помогает писать тесты как читабельные спецификации [домена](#домен). На этой базе построены правила из следующего раздела.

## Пирамида тестирования и выбор уровня

BDD ставит во главу угла поведение, но сами проверки живут на разных уровнях. Держите в голове пирамиду: быстрые юнит-тесты в основании, сервисные/интеграционные — посредине, end-to-end и контрактные — на вершине. Правильный выбор уровня помогает не скатываться к проверкам реализации.

| Уровень | Вопрос | Наблюдение | Типичные инструменты |
| --- | --- | --- | --- |
| Юнит (модель, сервис, объект) | Как ведёт себя маленький кусок логики? | Возвращаемое значение, вызовы зависимостей (через doubles) | `expect`, doubles, pure Ruby |
| Интеграционный / сервисный | Как взаимодействуют несколько компонентов? | Ответ сервиса, изменение [доменной](#домен) модели, побочные эффекты | Request/feature specs, ActiveJob, mailers |
| Request / API-контракты | Что видит клиент (frontend, внешний сервис)? | HTTP-статус, тело ответа, заголовки | Request specs, pact/contract tests |
| Системный (E2E) | Работает ли пользовательская история целиком? | UI-реакции, end-to-end поток | Capybara, Cypress, etc. |

Железных правил нет, но есть ориентиры:

- Проверяйте на том уровне, где поведение естественно наблюдать. Request spec проверяет статус/ответ, а не содержимое базы — иначе вы тестируете реализацию контроллера, а не API-контракт (см. правило 1).
- Если одна проверка требует сложной подготовки контекста или медленных зависимостей, подумайте, не лучше ли перенести часть логики в более низкий уровень [пирамиды](#пирамида-тестирования-и-выбор-уровня).
- Единичный побочный эффект (создана запись, отправлено письмо) лучше выносить в отдельный юнит/сервисный тест. В BDD-контрактах фиксируйте лишь то, что важно потребителю.
- `:aggregate_failures` (правило 23) применяем, только если говорим об одном поведении и хотим увидеть все нарушения сразу — это не способ проверить половину [пирамиды](#пирамида-тестирования-и-выбор-уровня) в одном `it`.

С [пирамидой](#пирамида-тестирования-и-выбор-уровня) в голове легче решать, что считать happy path, что — corner case, и какой уровень тестов ответственен за подтверждение каждого правила.

## Глоссарий

### Основные понятия

#### Поведение

Наблюдаемое изменение состояния системы или её реакция на внешнее воздействие, которое можно описать одним предложением на естественном языке.

Поведение в контексте BDD и RSpec — это не каждый атрибут или метод объекта, а бизнес-правило или результат действия, который имеет значение для заинтересованных лиц.

**Примеры поведений:**
- "Создаёт заказ в базе данных"
- "Отправляет подтверждение на email"
- "Предоставляет полный профиль пользователя из сессии"
- "Блокирует доступ для неавторизованного пользователя"
- "Вычисляет итоговую стоимость с учётом скидки"

**НЕ являются отдельными поведениями:**
- Каждый отдельный атрибут конфигурационного объекта (например, `name`, `email`, `phone` — это части интерфейса объекта User)
- Каждое поле в структуре API-ответа (все поля вместе составляют контракт ответа)
- Каждый геттер value object (геттеры вместе формируют публичный интерфейс)

**Правило:** Если вы не можете описать проверку как самостоятельное действие или результат на естественном языке, скорее всего это часть более крупного поведения.

#### Домен

Предметная область или бизнес-домен, для которого разрабатывается приложение. Концепция происходит из Domain-Driven Design (DDD).

В контексте тестирования и архитектуры:
- **Правила домена** — бизнес-правила и логика домена, которые мы проверяем в тестах
- **Доменная модель** — совокупность сущностей и их поведения, отражающих правила домена
- **Доменный язык** — единый язык (ubiquitous language), который используют и разработчики, и бизнес-специалисты для описания правил
- **Доменный слой** — архитектурный слой, содержащий бизнес-логику, изолированный от деталей инфраструктуры (БД, HTTP, внешние сервисы)
- **Доменные объекты** — объекты, выражающие понятия домена: сущности (entities), объекты-значения (value objects), сервисы
- **Бизнес-домен** — конкретная область ответственности (например, "домен платежей", "домен аутентификации")

**В тестах:** Мы формулируем правила домена доменным языком вместо технических терминов. На интеграционном уровне детали внутри одного бизнес-домена объединяются, а их комбинаторика проверяется в юнит-тестах (см. [Правило 5](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases)).

### Виды тестирования

В зависимости от того, что именно мы проверяем, тесты делятся на два основных типа:

#### Поведенческое тестирование

Проверка бизнес-логики через наблюдаемые побочные эффекты или реакции системы. Каждое действие вызывает независимый эффект, который важен для бизнеса.

**Примеры:**
- Проверка, что метод создаёт запись в базе данных
- Проверка, что сервис отправляет email
- Проверка, что статус заказа изменился после оплаты
- Проверка, что система логирует событие

**Характерные признаки:**
- Каждый эффект — отдельное правило бизнес-логики
- Эффекты независимы друг от друга
- Можно описать каждый эффект отдельным предложением: "система делает X"

#### Интерфейсное тестирование

Проверка набора атрибутов объекта в определённом состоянии. Все проверяемые атрибуты выводятся из одного источника/состояния и представляют единое поведение: "объект предоставляет корректный интерфейс".

**Примеры применения:**
- Value objects с множественными атрибутами (Money, Address, Coordinate)
- Конфигурационные объекты (Settings, Config, Preferences)
- Read-only интерфейсы, построенные из единого источника
- Presenter/Decorator объекты, предоставляющие производные атрибуты

**Характерные признаки:**
- Атрибуты связаны общим источником данных
- Изменение источника влияет на все атрибуты сразу
- Атрибуты формируют целостный контракт объекта
- Описывается как "объект предоставляет интерфейс X"

**Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, это интерфейсное тестирование — объедините проверки в один `it` с `:aggregate_failures`.

**Важно:** Интерфейсное тестирование применимо к [доменным](#домен) объектам. Для HTTP API-интерфейсов используйте специализированные инструменты фиксации контрактов (см. раздел "Тестирование API-контрактов: границы применимости RSpec").

### Принципы проектирования

Эти принципы из объектно-ориентированного проектирования напрямую влияют на тестируемость кода. Тесты честно показывают нарушения этих принципов через свою сложность.

#### Do One Thing

Принцип из "Clean Code" (Robert Martin): функция/метод/класс должен иметь одну ответственность и делать только одно дело на одном уровне абстракции.

**Сигнал в тестах:**
- **На уровне метода:** Глубокая вложенность контекстов (5+ уровней), десятки комбинаций характеристик для одного метода
- **На уровне класса:** Слишком много `describe` блоков (10+ публичных методов) — класс делает слишком много разных вещей

**Типичные нарушения:**
- Смешивание уровней абстракции (высокоуровневая бизнес-логика + низкоуровневые детали в одном методе)
- Множественная ответственность (метод ИЛИ класс решает несколько независимых задач)
- Нечёткие границы слоёв (контроллер содержит бизнес-логику, модель строит сложные SQL-запросы И обрабатывает данные)

**Решение для Rails:** Контроллер → координация, Service Object → бизнес-логика, Model → работа с данными

**См. также:** [Правило 5](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases)

#### Single Responsibility Principle

Класс должен иметь только одну причину для изменения. Часть SOLID принципов.

**Сигнал в тестах:** Сложные фабрики с десятками обязательных полей, невозможно изолированно протестировать один аспект поведения.

**Типичное нарушение:** God Object — класс, который знает или делает слишком много. Модель ActiveRecord с бизнес-логикой, валидацией, вычислениями, интеграциями и т.д.

**См. также:** [Правила 12-14](#12-используйте-возможности-factorybot-трейты-и-атрибуты-по-умолчанию)

#### Инкапсуляция

Сокрытие внутренних деталей реализации за публичным интерфейсом. Объект управляет своим состоянием и не выставляет внутренности наружу.

**Сигнал в тестах:** Тесты проверяют внутренние вызовы методов (`receive`), приходится знать детали схемы БД для создания тестовых данных, невозможно создать объект через публичный API.

**Типичные нарушения:**
- Прямая работа с внутренними полями объекта
- Публичные методы, которые на самом деле служебные (должны быть private)
- Утечка деталей реализации через API

**См. также:** [Правило 1](#1-тестируйте-поведение-а-не-реализацию), [Правило 15](#15-не-программируйте-в-тестах)

#### Dependency Injection

Зависимости передаются объекту извне (через конструктор, setter, параметр метода), а не создаются внутри объекта.

**Сигнал в тестах:** Нужен `any_instance_of` для моков, невозможно протестировать класс в изоляции, приходится мокать глобальные объекты.

**Типичное нарушение:** Класс создаёт зависимости внутри себя: `service = SomeService.new` в методе вместо `def initialize(service)`.

**Решение:** Передавайте зависимости через конструктор. Это делает код тестируемым и гибким.

**См. также:** [Правило 22](#22-не-используйте-any_instance)

#### Tight Coupling

Ситуация, когда классы/модули слишком сильно зависят друг от друга, знают о внутренних деталях друг друга.

**Сигнал в тестах:** Для теста одного класса нужно создавать множество связанных объектов, изменение одного класса ломает тесты других классов, невозможно использовать `build_stubbed`.

**Типичное нарушение:** Класс напрямую обращается к полям другого класса, жёстко зависит от конкретной реализации вместо интерфейса.

**Решение:** Зависьте от абстракций/интерфейсов, а не от конкретных реализаций (Dependency Inversion из SOLID).

**См. также:** [Правила 13-14](#13-используйте-attributes_for-для-генерации-параметров-которые-не-являются-важной-деталью-в-тестировании-поведения), [Правило 22](#22-не-используйте-any_instance)

#### Leaky Abstraction

Когда детали нижнего уровня "протекают" через интерфейс верхнего уровня. Пользователь абстракции вынужден знать детали реализации.

**Сигнал в тестах:** Приходится знать детали схемы БД для работы с [доменной](#домен) моделью, бизнес-логика смешана с SQL, публичный API не выражает бизнес-операции.

**Типичное нарушение:** ActiveRecord модель с публичными методами типа `update_column`, бизнес-сервис, который требует знания структуры БД.

**Решение:** Чётко разделите слои (domain → persistence), [доменный](#домен) слой не должен знать о деталях хранения.

**См. также:** [Правило 15](#15-не-программируйте-в-тестах)

**Ключевая идея:** Если тесты сложные — проблема в дизайне кода. Не усложняйте тесты, упрощайте код. Тесты — это честная обратная связь о качестве архитектуры.

### Характеристики и состояния

#### Характеристика

[Доменный](#домен) аспект, влияющий на исход поведения (роль пользователя, способ оплаты, статус заказа).

*Как найти:* спросите «если изменить эту характеристику, изменится ли ожидаемый результат?», и убедитесь, что речь идёт о бизнес-факте, а не о технической детали.

#### Состояние

Конкретный вариант значения характеристики, важный для правила (подписка активна, баланс ниже лимита).

*Как выделить:* сгруппируйте возможные значения в [доменные](#домен) диапазоны и сформулируйте их короткими утверждениями.

*Типы состояний:*
- бинарные (да/нет: карта привязана ↔ не привязана);
- множественные (enum: роль = admin / manager / guest);
- диапазоны (число/дата: баланс ≥ стоимость / баланс < стоимость).

#### Контекст

Блок `context`, фиксирующий одно или несколько состояний характеристик. Контекст отвечает за «Given»-часть спецификации.

**Типы контекстов:**
- **Положительный контекст** — состояние выполняется (обычно часть happy path).
- **Отрицательный контекст** — состояние нарушено или отрицается (часто часть corner case).
- **Вложенный контекст** — уточняет внешний, добавляя состояние новой характеристики или уточняя текущую.

#### Кейс

Минимальный сценарий (блок `it`), проверяющий конкретное поведение на выбранном наборе состояний.

**Типы кейсов:**
- **Happy path case** — основной поток: ожидаемый успех без исключений.
- **Corner case** — отклонение от основного потока: крайние значения, ошибки, исключительные ситуации.
- **Положительный тест** — пример подтверждает поведение (чаще совпадает с happy path).
- **Отрицательный тест** — пример показывает отказ или защиту от некорректного поведения (часто совпадает с corner case).

*Важно:* happy/corner описывают тип кейса, а положительный/отрицательный — результат проверки. При множественных состояниях возможно несколько happy path кейсов без отрицательных тестов на этой характеристике.

| Тип кейса       | Тип контекстов внутри                  | Результат теста             |
| --------------- | -------------------------------------- | --------------------------- |
| Happy path case | Положительные контексты                | Положительный тест          |
| Corner case     | Отрицательные или уточняющие контексты | Отрицательный тест / защита |

Таблица отражает типичную связь, но возможны исключения — например, enum-характеристика может включать несколько happy path кейсов без отрицательных тестов, или corner case может завершаться положительным результатом (например, graceful degradation).

#### Задание состояния

Объявление (`let`/`before`), которое делает формулировку контекста истинной. Его размещают сразу под соответствующим `context`, чтобы связь между описанием и подготовкой контекста читалась без поиска по файлу (см. пункт 11).

#### Flaky test

Тест, который ведёт себя непредсказуемо: иногда зелёный, иногда красный при неизменном коде. Чаще всего связан с нестабильным временем, глобальным состоянием, случайным порядком или зависимостями от внешних сервисов.

# RSpec style guide

## Почему мы пишем тесты именно так: когнитивная нагрузка

Все правила в этом руководстве объединяет одна цель: **снизить когнитивную нагрузку при чтении, понимании и изменении тестов**.

**Когнитивная нагрузка** — это объем умственных усилий, необходимых для выполнения задачи. В контексте тестов это означает:
- Сколько информации нужно удерживать в памяти, чтобы понять, что проверяет тест?
- Сколько времени требуется, чтобы найти нужный тест при падении?
- Насколько легко изменить тест при изменении требований?

### Три типа когнитивной нагрузки в тестах

1. **Внутренняя нагрузка** — сложность самого домена. Это неизбежно: если бизнес-правило сложное, тест будет отражать эту сложность.

2. **Посторонняя нагрузка** — искусственная сложность из-за плохой организации кода. Примеры:
   - Тест проверяет реализацию вместо поведения → читателю нужно "выполнить код в голове"
   - Состояния характеристик скрыты в приватных методах → нужно искать определения
   - Несколько поведений в одном `it` → непонятно, какое правило нарушено при падении

3. **Релевантная нагрузка** — усилия на построение ментальной модели. Хорошие тесты помогают строить эту модель быстро:
   - Явная структура `context` показывает зависимости характеристик
   - Описание `it` формулирует бизнес-правило на естественном языке
   - Трёхэтапная структура (Given-When-Then) упрощает чтение

### Как правила снижают когнитивную нагрузку

Каждое правило в этом руководстве атакует постороннюю нагрузку и усиливает релевантную:

- **Правило 1** (поведение, не реализация) — устраняет необходимость понимать внутреннее устройство кода
- **Правило 5** (иерархия контекстов) — делает зависимости характеристик видимыми сразу
- **Правило 10** (subject) — явно показывает, что тестируется, не нужно искать объект в ожиданиях
- **Правило 11** (трёхэтапная структура) — создаёт предсказуемый паттерн чтения
- **Правила 12-13** (фабрики) — скрывают технические детали, оставляют только бизнес-характеристики
- **Правило 16** (явность важнее DRY) — тесты остаются документацией, а не головоломкой из абстракций
- **Правила 17-21** ([Язык описания спецификаций](#язык-описания-спецификаций)) — понятные формулировки на естественном языке превращают тесты в читаемую документацию
- **Правило 23** (aggregate_failures) — показывает все нарушения сразу, экономя циклы отладки

Когда вы следуете этим правилам, ваши тесты становятся **исполняемой документацией**: коллеги могут быстро понять бизнес-правила, новые разработчики легко вникают в [домен](#домен), а изменения требований не превращаются в переписывание половины test suite.

**Золотое правило:** Если при чтении теста возникает вопрос "а что это значит?" или "откуда это берётся?", значит посторонняя когнитивная нагрузка слишком высока. Упростите.

## Тесты как индикатор качества кода

Вторая ключевая идея этого руководства: **сложность и проблемы тестов отражают проблемы тестируемого кода**. Тесты — это не просто проверка корректности, а **детектор качества дизайна**.

### Как тесты выявляют проблемы дизайна

Хорошо спроектированный код легко тестировать. Если тесты становятся сложными, хрупкими или запутанными — это сигнал о проблемах в архитектуре и дизайне самого кода.

**Типичные сигналы плохого дизайна через тесты:**

1. **Сложная подготовка данных (Given)** → код зависит от слишком многих деталей, нарушен принцип инкапсуляции
2. **Глубокая вложенность контекстов (5+ уровней)** → метод нарушает [Do One Thing](#принципы-проектирования), делает слишком много
3. **Тесты на реализацию (`receive`, `allow` для внутренних методов)** → хрупкие абстракции, нечёткие границы ответственности
4. **Частые изменения тестов при рефакторинге** → код зависит от деталей реализации, а не от контрактов
5. **Невозможно протестировать поведение без моков** → слишком тесное связывание (tight coupling)
6. **Сложные фабрики с десятками обязательных полей** → God Object, нарушение Single Responsibility

### Тесты как инструмент улучшения дизайна

BDD и TDD — это не только про корректность, но и про **дизайн через тесты**:

- **Test-First заставляет думать об интерфейсе** — вы пишете тест до кода, значит сначала определяете удобный публичный API
- **Сложный тест = сигнал упростить код** — если тест трудно писать, код слишком сложен или неправильно структурирован
- **Рефакторинг становится безопасным** — хорошие тесты (на поведение) позволяют менять реализацию без страха

**Правило обратной связи:** Когда вы сталкиваетесь со сложностью в тестах, первый вопрос должен быть не "как обойти это в тестах?", а **"что не так с дизайном кода?"**.

### Примеры сигналов и решений

| Сигнал в тестах | Проблема в коде | Решение |
|-----------------|-----------------|---------|
| Нужно мокать 5+ зависимостей | Слишком много ответственностей в одном классе | Разбить на несколько классов с чёткими границами |
| Глубокая вложенность `context` | Метод делает слишком много (нарушение Do One Thing) | Выделить подзадачи в отдельные методы/сервисы |
| Тесты ломаются при рефакторинге | Тесты привязаны к реализации, а не к поведению | Переписать тесты на проверку наблюдаемого поведения |
| Сложно создать объект для теста | God Object или сложные зависимости | Применить Dependency Injection, упростить конструктор |
| Нужны приватные методы в setup | Скрытая сложность или утечка абстракций | Вынести логику в публичный интерфейс или отдельный класс |

**Золотое правило:** Если тест сложен, не усложняйте тесты — упрощайте код. Тесты должны оставаться простыми и декларативными. Их сложность — это честная обратная связь о качестве дизайна.

---

## Краткая справка

Эта секция содержит компактную сводку всех правил, decision trees и частые антипаттерны для быстрого поиска.

### Все правила одним списком

**Поведение и структура тестов:**

1. **[Тестируйте поведение, а не реализацию](#1-тестируйте-поведение-а-не-реализацию)** — Проверяйте наблюдаемые результаты, а не внутренние детали (методы, переменные экземпляра).
2. **[Проверяйте, что тест тестирует](#2-проверяйте-что-тест-тестирует)** — Убедитесь, что тест падает при нарушении правила (практика test-first).
3. **[Один `it` — одно поведение](#3-каждый-example-it-описывает-одно-наблюдаемое-поведение)** — Каждый example описывает одно наблюдаемое правило; используйте `:aggregate_failures` только для проверки интерфейса.
4. **[Выделяйте характеристики](#4-выделяйте-характеристики-поведения-и-их-состояния)** — Характеристика = условие, влияющее на поведение; каждая характеристика = отдельный `context`.
5. **[Иерархия по зависимостям](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases)** — Happy path первым, corner cases вложены; одна характеристика = один уровень `context`.
6. **[Финальный аудит контекстов](#6-финальный-аудит-контекстов-два-типа-дубликатов)** — Проверьте дубликаты описаний (объединяйте) и дубликаты состояния (разделяйте).
7. **[Happy path перед corner cases](#7-располагайте-happy-path-перед-corner-cases)** — Читатель сначала видит основной сценарий, затем исключения.
8. **[Положительный и отрицательный тесты](#8-пишите-положительный-и-отрицательный-тест)** — Проверяйте как успешный результат, так и отказ (когда применимо).
9. **[Различие контекстов](#9-каждый-контекст-должен-отражать-различие-вложенной-части-от-внешней)** — Каждый вложенный `context` должен добавлять новую характеристику или уточнение.

**Синтаксис и читаемость:**

10. **[Указывайте `subject`](#10-указывайте-subject-чтобы-явно-обозначить-предмет-тестирования)** — Явно обозначайте предмет тестирования для ясности.
11. **[Три этапа теста](#11-каждый-тест-должен-быть-разделен-на-3-этапа-в-строгой-последовательности)** — Подготовка (`let`/`before`) → Действие (явный вызов) → Проверка (`expect`).
12. **[Используйте FactoryBot](#12-используйте-возможности-factorybot-для-скрытия-деталей-исходных-данных)** — Скрывайте детали данных, важные только для валидности, не для поведения.
13. **[`attributes_for` для параметров](#13-используйте-attributes_for-для-генерации-параметров-которые-не-являются-важной-деталью-в-тестировании-поведения)** — Генерируйте хеши параметров вместо полных объектов, когда объект не нужен.
14. **[`build_stubbed` в юнитах](#14-в-юнит-тестах-кроме-моделей-используйте-build_stubbed)** — Быстрее `build`/`create`; stubbed объекты не касаются БД.
15. **[Не программируйте в тестах](#15-не-программируйте-в-тестах)** — Избегайте циклов, условий, сложной логики; тесты должны быть декларативными.
16. **[Явность важнее DRY](#16-явность-важнее-dry)** — Дублируйте код, если это делает тест понятнее.

**Язык описания спецификаций:**

17. **[Валидное предложение](#17-описание-контекстов-context-и-тестовых-кейсов-it-вместе-включая-it-должны-составлять-валидное-предложение-на-английском-языке)** — `describe` + `context` + `it` складываются в грамматически правильное английское предложение.
18. **[Понятно любому](#18-описание-контекстов-context-и-тестовых-кейсов-it-вместе-включая-it-должны-быть-написаны-так-чтобы-их-понимал-любой-человек)** — Описания должны быть понятны без знания программирования (бизнес-язык).
19. **[Грамматика](#19-грамматика-формулировок-в-describecontextit)** — `describe` (существительное/метод), `context` (when/with/and), `it` (глагол в 3-м лице).
20. **[Язык контекстов](#20-язык-контекстов-when--with--and--without--but--not)** — Используйте when/with/and/without/but/NOT для связывания характеристик.
21. **[Rubocop naming](#21-изучите-подробно-правила-из-rubocop-по-части-наименования-httpsrspecrubystyleguide-naming)** — Изучите [RSpec Style Guide](https://rspec.rubystyle.guide/#naming) для деталей.

**Инструменты и поддержка:**

22. **[Не используйте `any_instance`](#22-не-используйте-any_instance-allow_any_instance_of-expect_any_instance_of)** — Используйте dependency injection вместо глобальных моков.
23. **[`:aggregate_failures` только для интерфейсов](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило)** — Одно правило = один `it`; интерфейс объекта = можно объединить с aggregate_failures.
24. **[Verifying doubles](#24-предпочитайте-verifying-doubles-instance_double-class_double-object_double)** — Предпочитайте `instance_double`/`class_double` вместо `double` для проверки контрактов.
25. **[Shared examples для контрактов](#25-используйте-shared-examples-для-декларации-контрактов)** — Декларируйте повторяющиеся контракты через shared examples.
26. **[Request specs вместо controller specs](#26-предпочитайте-request-specs-вместо-controller-specs)** — Request specs проверяют HTTP-контракт, controller specs устарели.

### Быстрая диагностика: "Почему мой тест плохо пахнет?"

**Если тест сложно прочитать:**
- ✅ Проверьте: используются ли циклы/условия? → См. [Правило 15](#15-не-программируйте-в-тестах)
- ✅ Проверьте: складываются ли describe/context/it в предложение? → См. [Правило 17](#17-описание-контекстов-context-и-тестовых-кейсов-it-вместе-включая-it-должны-составлять-валидное-предложение-на-английском-языке)
- ✅ Проверьте: скрыты ли детали данных в factories? → См. [Правило 12](#12-используйте-возможности-factorybot-для-скрытия-деталей-исходных-данных)

**Если тест долго выполняется:**
- ✅ Проверьте: используете ли `create` в юнит-тестах? → Замените на `build_stubbed` ([Правило 14](#14-в-юнит-тестах-кроме-моделей-используйте-build_stubbed))
- ✅ Проверьте: есть ли лишние HTTP-запросы? → См. раздел [Внешние сервисы](#внешние-сервисы)
- ✅ Проверьте: не создаются ли лишние ассоциации? → Используйте traits выборочно ([Правило 12](#12-используйте-возможности-factorybot-для-скрытия-деталей-исходных-данных))

**Если тест флейкает (нестабильно падает):**
- ✅ Проверьте: фиксируется ли время? → См. раздел [Нюансы времени](#нюансы-времени-между-ruby-и-postgresql)
- ✅ Проверьте: зависит ли от порядка записей? → См. [Правило 1](#1-тестируйте-поведение-а-не-реализацию) (используйте `match_array`)
- ✅ Проверьте: есть ли race conditions? → Изолируйте тесты

**Если тест падает при рефакторинге:**
- ✅ Проверьте: тестируете ли реализацию? → См. [Правило 1](#1-тестируйте-поведение-а-не-реализацию)
- ✅ Проверьте: есть ли привязка к деталям? → Скройте детали в factories ([Правило 12](#12-используйте-возможности-factorybot-для-скрытия-деталей-исходных-данных))

**Если тест не падает, когда должен:**
- ✅ Проверьте: работает ли test-first подход? → См. [Правило 2](#2-проверяйте-что-тест-тестирует)
- ✅ Проверьте: выполняются ли все ожидания? → Добавьте явные `expect`

---

## Поведение и структура тестов

### 1. Тестируйте поведение, а не реализацию

Если в вашем тесте нет описания [поведения](#поведение), то это не тест. Почему? При отсутствии описания поведения возникает привязка
к реализации, когда после вас кто-то будет смотреть тесты - он ничего не поймет и тесты окажутся бесполезными.

###### далее `some_action` в примерах - это псевдокод, который мы тестируем и поведение которого мы описываем

```ruby
# отвратительно
describe "#some_action" do
  # ... создаем пользователя, но не связываем подготовку контекста с описанием
  it "true" do          # из этого описания не понятно, что означает факт того, что мы ожидаем `true`
    expect(some_action).to be(true)
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... создаем пользователя и явно задаём характеристику, о которой говорим в `it`
  it "allows unlocking the user" do         # это описание рассказывает нам о том, что означает наше ожидание от кода
    expect(some_action).to be(true)
  end
end
```

Что не так в плохом примере:

- Описание `it` не рассказывает о поведении; непонятно, что означает ожидаемый `true`.
- Контекст в комментарии не связывается с формулировкой примера, поэтому спецификация не читается как правило поведения.

Или, например, используйте `match_array` или `contain_exactly`, когда пишите ожидание для массива, порядок значений в котором вам не важен.

```ruby
# плохо
expect(some_action).to eq [1, 2, 3] # pass
```

```ruby
# хорошо
expect(some_action).to match_array [2, 3, 1] # pass
expect(some_action).to contain_exactly(1, 2, 3) # pass
```

Что не так в плохом примере:

- Сравнение `eq` привязывает тест к порядку элементов и ведёт к ложным падениям.
- Спецификация описывает реализацию, а не правило.

Представим что `some_action` возвращал всегда `[1, 2, 3]` и ваши тесты проходили,
потом вы внесли какие-то изменения в код, обновили базу данных и т.д. То есть по какой-то причине порядок в массиве изменился,
например, он стал `[2, 1, 3]`,
и у вас начала падать дюжина тестов. И все это произошло из-за вашей привязки к реализации!
Не делайте так, тестируйте конкретное поведение.
Если это выборка данных, то проверяйте факт правильной выборки данных.

В целом, каждый раз как вы работаете с любой коллекцией (массивы, хеши, ActiveRecord::Relation ...)
и используете `eq`, то это звоночек, что вы делаете что-то не так. Возможно существует хелпер из библиотеки `RSpec Expectations`, подходящий
для определения вашего ожидания, а возможно вы в принципе не то тестируете (не поведение вашего кода) или даже не то реализуете.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Описание поведения на естественном языке (`"allows unlocking the user"`) создаёт ментальную модель без необходимости читать код
- Правильный матчер (`match_array` вместо `eq`) сразу показывает намерение: "проверяем состав, а не порядок"
- При падении теста с ясным описанием сразу понятно, какое бизнес-правило нарушено — не нужно анализировать реализацию

**Что это говорит о дизайне кода:**

Если вам сложно написать тест на **поведение** и приходится тестировать **реализацию** — это сигнал о нарушении [инкапсуляции](#принципы-проектирования):

- Публичный API не выражает бизнес-операции, а только технические детали → [утечка абстракции](#принципы-проектирования)
- Нужно проверять внутренние вызовы методов (`receive`) → внутренняя логика не скрыта за публичным интерфейсом
- Тесты ломаются при рефакторинге, даже когда поведение не меняется → код зависит от деталей реализации, а не от контрактов

**Решение:** Публичный API должен выражать бизнес-операции. Если API хороший, тест на поведение пишется естественно, без моков внутренних вызовов.

**См. также:**
- [Правило 2: Проверяйте, что тест тестирует](#2-проверяйте-что-тест-тестирует) — убедитесь, что тест действительно проверяет поведение
- [Правило 3: Один `it` — одно поведение](#3-каждый-example-it-описывает-одно-наблюдаемое-поведение) — как правильно разделять поведения
- [Правило 22: Не используйте `any_instance`](#22-не-используйте-any_instance) — избегайте моков реализации

### 2. Проверяйте, что тест тестирует

После написания теста убедитесь, что он действительно ловит баги — сломайте код и проверьте, что тест падает. Это второе по важности правило после "тестируй поведение": без проверки работоспособности теста вы рискуете получить ложно-зелёный тест, который всегда проходит независимо от корректности кода.

#### Проблема: code-first вместо test-first

В идеальном мире TDD (test-driven development) цикл "Red → Green → Refactor" гарантирует, что тест сначала падает (Red), а затем проходит после реализации (Green). Но в реальной коммерческой разработке большинство команд не следует строгому TDD — сначала пишется код, потом тесты. Это приводит к риску "подгонки теста под реализацию": тест написан так, что он проверяет текущую реализацию, но не ловит ошибки.

**Типичный сценарий:**

1. Вы написали код
2. Написали тест, который проходит
3. Закоммитили
4. Через неделю кто-то ломает код
5. Тест всё равно зелёный — потому что он никогда не проверял правильное поведение

#### Надуманный пример

**Примечание:** Опытному читателю будет очевидна проблема в этом примере, но автору гайда сложно придумать по-настоящему практичный пример. Такие ситуации очень коварны и легко возникают повсеместно в реальном коде, часто в более сложном контексте, где ошибка не так заметна.

```ruby
# код
class NotificationService
  def notify_user(user, message)
    UserMailer.notification(user.email, message).deliver_later
  end
end
```

```ruby
# плохо
describe NotificationService do
  let(:user) { double(email: 'user@example.com') }
  let(:mailer) { double(deliver_later: true) }

  before do
    allow(UserMailer).to receive(:notification).and_return(mailer)
  end

  it 'sends notification to user' do
    service.notify_user(user, 'Hello')
    expect(UserMailer).to have_received(:notification)
  end
end
```

**Что не так:**

- Тест проверяет только факт вызова `notification`, но не проверяет аргументы
- Если код сломается и начнёт передавать `nil` вместо email или неправильное сообщение — тест останется зелёным
- Кажется, что всё покрыто, но по факту критичная часть (передача правильных данных) не проверяется

#### Практический чек-лист

После написания каждого теста выполните "ручной Red":

1. ✅ Тест проходит (Green)
2. 🔨 Сломайте код одним из способов:
   - Верните неправильное значение (`return 0`, `return nil`, `return "wrong"`)
   - Закомментируйте ключевую строку логики
   - Измените условие (`if` → `unless`, `>` → `<`)
   - Передайте неправильные аргументы в вызовы методов
3. ❌ Тест должен упасть (Red)
4. 🔄 Верните код в исходное состояние
5. ✅ Тест снова проходит (Green)

Если на шаге 3 тест остался зелёным — переписывайте тест, он не проверяет реальное поведение.

**Золотое правило:** Тест, который никогда не падал, не доказывает ничего. Сломайте код и убедитесь, что тест ловит поломку — только тогда у вас есть гарантия, что он работает.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Ложно-зелёные тесты создают иллюзию покрытия и заставляют команду постоянно сомневаться: "а точно этот тест что-то проверяет?"
- Проверка теста через "ручной Red" даёт уверенность — не нужно держать в голове вопрос "а работает ли этот тест вообще?"
- Команда может доверять test suite и не тратить ментальные усилия на недоверие к тестам

**См. также:** [Правило 23: aggregate_failures](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило) — позволяет увидеть все нарушения сразу при проверке теста на Red

### 3. Каждый example (`it`) описывает одно наблюдаемое поведение

**Навигация по правилу:**
- [3.1. Исключение для интерфейсного тестирования](#31-исключение-для-интерфейсного-тестирования)
- [3.2. Работа с большими интерфейсами](#32-работа-с-большими-интерфейсами)

Описание в `it` должно быть уникальным и рассказывать об одной бизнес-истине. Если два примера называют одно и то же, значит мы проверяем реализацию разными путями. Это запах: либо нужно выделить отдельное [поведение](#поведение), либо перераспределить проверки по [пирамиде тестирования](#пирамида-тестирования-и-выбор-уровня).

- Один `it` = одна ситуация из спецификации = одно ключевое наблюдение.
- Наблюдение выбираем на уровне контракта (HTTP-статус, тело ответа, возвращаемое значение), а не внутренних побочных эффектов, если только команда не договорилась иначе.
- Когда нужно проверить несколько следствий одного правила, разделяйте их на разные `it`. `:aggregate_failures` используйте лишь когда действительно говорите об одном поведении (см. пункт 23).

Тест — это короткое утверждение о поведении, а не мини-программа. Чем точнее формулировка `it`, тем легче читать спецификацию как документацию.

```ruby
# плохо
it "creates a user" do
  expect { post_signup }.to change(User, :count)
  expect(response).to redirect_to dashboard_path
end
```

```ruby
# хорошо
it "redirects user to dashboard after signup" do
  post_signup
  expect(response).to redirect_to dashboard_path
end

it "persists the user after signup" do
  expect { post_signup }.to change(User, :count)
end
```

Что не так в плохом примере:

- Два разных поведения спрятаны в одном `it`, поэтому при падении непонятно, какое правило нарушено.
- Информация в отчёте RSpec теряет связь с описанием поведения, и тест перестаёт быть спецификацией.
- Информацию в отчёте RSpec приходится анализировать, а так же обращаться к тесту, чтобы разобраться, какое поведение было ожидаемым, из-за отсутствия описания в отчете.

Request spec пример. Мы хотим убедиться, что авторизация успешна, и выбираем наблюдение на уровне API, а не БД:

```ruby
# плохо
it "creates a session" do
  post "/sessions", params: creds
  expect(Session.count).to eq 1
end
```

```ruby
# хорошо
it "returns an access token" do
  post "/sessions", params: creds
  expect(response).to have_http_status(:created)
  expect(response.parsed_body.fetch("token")).to be_present
end
```

Что не так в плохом примере:

- Проверка обращается к базе напрямую и фиксирует реализацию контроллера вместо публичного API-контракта.
- Падение такого теста подсказывает только «запись не создана», а не то, что клиенту пришёл неверный ответ.

> Не сравнивайте JSON целиком строкой: смотрите раздел 22 («Делайте вывод падения теста читаемым») — там показано, как структурный дифф помогает увидеть расхождение сразу.

Если в `it` появляется много `expect`, это обычно сигнал: мы пытаемся зафиксировать побочные эффекты вместо поведения. Типичный пример — регистрация пользователя и отправка welcome-письма. В request-spec мы проверяем статус/ответ API, а факт отправки письма опускаем на уровень юнит/сервисного теста (или возвращаемся к [пирамиде](#пирамида-тестирования-и-выбор-уровня) и пишем отдельный сценарий, если письмо — самостоятельное правило). Не превращайте спецификацию поведения в маленькую программу: циклы, условные операторы и вычисления в тестах — прямой признак, что мы перестали описывать правила и начали переписывать реализацию.

**Почему не стоит совмещать много ожиданий в один `it`:**

Хотя это ускоряет тесты (данные создаются один раз, при первом падении остальные пропускаются), это приводит к проблемам:

1. Менее читаемые результаты и сам тест
2. Непонятно, какое ожидание соответствует описанию в `it`
3. Отсутствие изоляции между ожиданиями
4. **Главное:** это запах плохого дизайна кода — если тест проверяет несколько разных вещей, значит код делает несколько разных вещей, нарушая принцип "Do One Thing" (Clean Code, Robert Martin)

Если тесты стали "слишком умными", вероятно таков и тестируемый код. Разделите код на простые части, напишите юнит-тесты для каждой, затем простой интеграционный тест для их композиции.

#### 3.1. Исключение для интерфейсного тестирования

При тестировании объектов, предоставляющих набор связанных атрибутов (см. [Интерфейсное тестирование](#интерфейсное-тестирование) в глоссарии), несколько ожиданий в одном `it` с `:aggregate_failures` допустимы и предпочтительны, так как они представляют единое поведение: "объект предоставляет корректный интерфейс в заданном состоянии".

**Когда применимо интерфейсное тестирование:**

- Value objects с множественными атрибутами (Money, Address, Coordinate)
- Конфигурационные объекты (Settings, Config, Preferences)
- Read-only интерфейсы, построенные из единого источника данных
- Presenter/Decorator объекты, предоставляющие производные атрибуты

**Эмпирическое правило:** Если вы проверяете несколько атрибутов, которые все выводятся из одного источника/состояния и не включают независимые бизнес-эффекты, объедините их в один `it` с `:aggregate_failures`.

Подробнее о том, когда `:aggregate_failures` допустим и какие есть альтернативы, см. [правило 23](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило).

**Примеры хороших названий для интерфейсных тестов:**

- ✅ `'exposes product catalog interface'` — явно указывает на проверку интерфейса
- ✅ `'returns complete order summary'` — показывает, что проверяется полный набор данных
- ✅ `'builds user profile from session data'` — описывает источник и что строится
- ✅ `'provides shipping address details'` — чёткое описание предоставляемого интерфейса

**Избегайте:**

- ❌ `'works correctly'` — слишком общее, не описывает что проверяется
- ❌ `'returns correct values'` — не ясно, какие именно значения
- ❌ `'has valid attributes'` — расплывчато, не указывает на интерфейс

```ruby
# плохо: over-splitting интерфейса на отдельные тесты
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }
  
  it('returns product name') { expect(presenter.display_name).to eq('Laptop') }
  it('returns formatted price') { expect(presenter.formatted_price).to eq('$999.99') }
  # ... еще 2 проверки для availability и SKU
end
```

```ruby
# хорошо: интерфейсное тестирование с aggregate_failures
describe ProductPresenter do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, stock: 5, sku: 'LPT-001') }
  subject(:presenter) { described_class.new(product) }

  it 'exposes product display interface', :aggregate_failures do
    expect(presenter.display_name).to eq('Laptop')
    expect(presenter.formatted_price).to eq('$999.99')
    # ... еще 2 проверки для availability и SKU
  end

  # Отдельные тесты для независимого поведения
  context 'when product is out of stock' do
    let(:product) { create(:product, stock: 0) }
    it('indicates unavailability') { expect(presenter.availability).to eq('Out of Stock') }
  end
end
```

Что не так в плохом примере:

- Четыре отдельных теста проверяют части одного интерфейса, который presenter предоставляет на основе одного объекта `product`.
- При изменении источника данных (product) придётся обновлять все четыре теста, хотя они описывают единое поведение.
- Название каждого теста не передаёт, что все атрибуты связаны и формируют целостный интерфейс презентера.

Что даёт хороший пример:

- Один тест с `:aggregate_failures` явно показывает: "presenter предоставляет полный интерфейс отображения".
- Все атрибуты проверяются вместе, потому что они выводятся из одного источника и представляют единое поведение.
- Отдельный контекст для `out of stock` проверяет независимое поведение (изменение логики availability), а не просто другой атрибут.

**Важно:** Не путайте [интерфейсное тестирование](#интерфейсное-тестирование) с проверкой независимых побочных эффектов. Если каждое ожидание описывает самостоятельное бизнес-правило (создание записи + отправка email), разделяйте их на отдельные `it` по основному правилу 2.

#### 3.2. Работа с большими интерфейсами

Когда объект предоставляет 10+ атрибутов, тест с множественными `expect` становится громоздким и сложным для поддержки. Используйте подходящие инструменты в зависимости от типа объекта.

**Для [доменных](#домен) объектов (value objects, presenters, config):**

Используйте `have_attributes` — это компактнее и читаемее, чем список отдельных `expect`.

```ruby
# плохо: длинный список expect
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile', :aggregate_failures do
    expect(profile.first_name).to eq('John')
    expect(profile.last_name).to eq('Doe')
    expect(profile.full_name).to eq('John Doe')
    # ... еще 7 похожих проверок для email, phone, city, country, account_type, verified, created_at
  end
end

# хорошо: компактно через have_attributes
describe UserProfile do
  let(:user) { create(:user, first_name: 'John', last_name: 'Doe', email: 'john@example.com') }
  subject(:profile) { described_class.new(user) }

  it 'exposes user profile' do
    expect(profile).to have_attributes(
      first_name: 'John',
      last_name: 'Doe',
      full_name: 'John Doe'
      # ... остальные атрибуты: email, phone, city, country, account_type, verified
    )
  end
end
```

**Преимущества `have_attributes`:**

- Компактная запись — вся проверка в одном месте
- Автоматический `:aggregate_failures` — показывает все несоответствия сразу
- Читаемый вывод при падении теста

**Для JSON API с большими вложенными структурами:**

Когда ответ API содержит десятки полей и вложенных объектов, проверка всей структуры inline становится нечитаемой. Используйте **декомпозицию через `let`** для управления сложностью.

```ruby
# плохо: вся структура в одном месте — сложно читать и поддерживать
describe 'GET /api/orders/:id' do
  let(:order) { create(:order) }
  
  it 'returns order with items and customer' do
    get "/api/orders/#{order.id}"
    
    expect(response.parsed_body).to eq({
      'id' => order.id,
      'status' => 'pending',
      'total' => 1049.99,
      'customer' => {
        'id' => order.customer.id,
        'name' => 'John Doe',
        'email' => 'john@example.com',
        'shipping_address' => {
          'street' => '123 Main St',
          'city' => 'Springfield',
          'postal_code' => '12345',
          'country' => 'USA'
        },
        'billing_address' => {
          'street' => '456 Oak Ave',
          'city' => 'Springfield',
          'postal_code' => '12345',
          'country' => 'USA'
        }
      },
      'items' => [
        { 
          'id' => order.items[0].id,
          'product_name' => 'Laptop',
          'quantity' => 1,
          'price' => 999.99,
          'subtotal' => 999.99
        },
        { 
          'id' => order.items[1].id,
          'product_name' => 'Mouse',
          'quantity' => 2,
          'price' => 25.0,
          'subtotal' => 50.0
        }
        # ... еще 5 items
      ],
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601,
      'metadata' => {
        'source' => 'web',
        'ip' => '192.168.1.1'
        # ... еще 10 полей метаданных
      }
    })
  end
end
```

```ruby
# хорошо: декомпозиция через let — разделение данных и ожиданий
describe 'GET /api/orders/:id' do
  let(:order) { create(:order, customer: customer, items: [laptop_item, mouse_item]) }
  let(:customer) { create(:customer) }
  let(:laptop_item) { create(:order_item, product_name: 'Laptop', price: 999.99, quantity: 1) }
  let(:mouse_item) { create(:order_item, product_name: 'Mouse', price: 25.0, quantity: 2) }
  
  # Ожидания отделены от данных и структурированы
  let(:expected_address) do
    {
      'street' => '123 Main St',
      'city' => 'Springfield',
      'postal_code' => '12345',
      'country' => 'USA'
    }
  end

  let(:expected_customer) do
    {
      'id' => customer.id,
      'name' => 'John Doe',
      'email' => 'john@example.com',
      'shipping_address' => expected_address,
      'billing_address' => expected_address
    }
  end
  
  let(:expected_items) do
    [
      {
        'id' => laptop_item.id,
        'product_name' => 'Laptop',
        'quantity' => 1,
        'price' => 999.99,
        'subtotal' => 999.99
      },
      {
        'id' => mouse_item.id,
        'product_name' => 'Mouse',
        'quantity' => 2,
        'price' => 25.0,
        'subtotal' => 50.0
      }
      # ... остальные items можно добавить аналогично
    ]
  end

  let(:expected_response) do
    {
      'id' => order.id,
      'status' => 'pending',
      'total' => 1049.99,
      'customer' => expected_customer,
      'items' => expected_items,
      'created_at' => order.created_at.iso8601,
      'updated_at' => order.updated_at.iso8601
      # metadata тоже можно вынести в отдельный let при необходимости
    }
  end

  it 'returns complete order details' do
    get "/api/orders/#{order.id}"
    expect(response.parsed_body).to match(expected_response)
  end
end
```

**Преимущества декомпозиции:**

- Вложенная структура становится плоской и читаемой
- Разделение данных (fixtures) и ожиданий (expectations) — легче понять что тестируем
- Легко переиспользовать части (например, `expected_address` для shipping и billing)
- При изменении структуры ясно, какой блок обновлять
- Сохраняется иерархия: `expected_response` → `expected_customer` → `expected_address`

**Когда использовать декомпозицию через `let`:**

- Проверяете **поведение** — ключевые поля, которые важны для бизнес-логики
- Структура средней сложности (5-20 полей с 2-3 уровнями вложенности)
- Нужна гибкость для динамических значений (`order.id`, `customer.email`)

**Когда НЕ использовать:**

- Проверяете **контракт API** — все поля, типы, обязательность, вложенность
- Структура огромная (50+ полей, глубокая вложенность)
- Важна полная фиксация схемы для внешних потребителей

**Для фиксации полной структуры API используйте специализированные инструменты:**

- **JSON Schema validation** (thoughtbot/json_matchers) — валидация структуры и типов
- **rspec-openapi** — автоматическая генерация OpenAPI из Request specs
- **Snapshot testing** — фиксация эталонного ответа

Подробнее см. раздел ["Тестирование API-контрактов: границы применимости RSpec"](#тестирование-api-контрактов-границы-применимости-rspec).

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Один `it` = одно поведение → при падении теста сразу ясно, какое правило нарушено
- Уникальные описания → можно найти нужный тест по названию, не читая код
- Разделение поведений на разные `it` → легко изменить или удалить одно правило, не трогая другие

**См. также:**
- [Правило 1: Тестируйте поведение](#1-тестируйте-поведение-а-не-реализацию) — что считается поведением
- [Правило 23: `:aggregate_failures`](#23-используйте-aggregate_failures-только-когда-описываете-одно-правило) — когда можно объединять проверки
- [Раздел 3.1: Интерфейсное тестирование](#31-исключение-для-интерфейсного-тестирования) — исключения для интерфейсов

### 4. Выделяйте характеристики поведения и их состояния

**[Характеристика](#характеристики-и-состояния)** — доменный аспект, который влияет на исход проверяемого поведения (роль пользователя, способ оплаты, статус заказа).

**[Состояние характеристики](#характеристики-и-состояния)** — конкретный вариант этой характеристики, который важен для правила (подписка активна, баланс меньше лимита, статус = shipped).

Как понять, что вы нашли характеристику:

- задайте вопрос: «если изменить эту характеристику, ожидание примера изменится?»;
- характеристика описывает бизнес-факт, а не реализацию (`user has subscription`, а не `premium_flag`);
- характеристика формулируется как сущность с уточнением (`user role`, `card balance`).

Как подобрать состояния:

- перечислите все варианты, которые различает бизнес (роль = admin / customer; статус = draft / paid / cancelled);
- числовые величины группируйте в диапазоны, которые влияют на решение (баланс ≥ стоимость, баланс < стоимость);
- каждое состояние выражайте отдельным `context` с ясной формулировкой.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Явное выделение характеристик → тесты читаются как бизнес-правила, а не технические проверки
- Каждое состояние в своём `context` → не нужно держать в голове "а при каких условиях это работает?"
- Характеристики формулируются [доменным](#домен) языком → разработчик и бизнес говорят на одном языке

**См. также:**
- [Правило 5: Иерархия контекстов](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases) — как строить иерархию из характеристик
- [Правило 9: Различие контекстов](#9-каждый-контекст-должен-отражать-различие-вложенной-части-от-внешней) — каждый контекст добавляет характеристику
- [Глоссарий: Характеристики и состояния](#характеристики-и-состояния) — определения терминов

### 5. Стройте иерархию `context` по зависимостям характеристик (happy path → corner cases)

**Навигация по правилу:**
- [Базовые иерархии: зависимые характеристики](#базовые-иерархии-зависимые-характеристики)
- [Сложные иерархии: независимые характеристики](#сложные-иерархии-независимые-характеристики)

Характеристики могут быть:

- **базовыми** — без них остальные не имеют смысла (нет карты → нет баланса);
- **уточняющими** — уточняют базовую характеристику (баланс карты при наличии карты);
- **независимыми** — не влияют друг на друга (роль пользователя и флаг beta-теста).

Алгоритм:

1. Выпишите характеристики и состояния.
2. Отметьте зависимости: характеристика B зависит от A, если её состояние осмысленно только при конкретном состоянии A.
3. Постройте таблицу иерархии.
4. Для каждой ветки создайте вложенные `context` от базовой к уточняющей, упорядочив состояния: сначала happy path (нормальный сценарий), затем corner cases (отклонения).

#### Базовые иерархии: зависимые характеристики

**Зависимые характеристики (бинарная характеристика)**

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Привязка карты | has card / has NO card | — |
| Баланс карты | balance ≥ price / balance < price | Привязка карты (has card) |

```ruby
describe '#purchase' do
  context 'when user has a payment card' do               # happy path: карта привязана
    context 'and card balance covers the price' do        # happy path: баланс достаточен
      it 'charges the card'
    end

    context 'but card balance does NOT cover the price' do # corner case: денег не хватило
      it 'rejects the purchase'
    end
  end

  context 'when user has NO payment card' do              # corner case: карты нет
    it 'rejects the purchase'
  end
end
```

> ```ruby
> # плохо
> describe '#purchase' do
>   context 'but card balance does NOT cover the price' do
>     it 'rejects the purchase'
>   end
>
>   context 'when user has a payment card' do
>     context 'and card balance covers the price' do
>       it 'charges the card'
>     end
>   end
> end
> ```
>
> Что не так:
>
> - Ветка `but ...` оторвана от базового `when user has a payment card`, поэтому happy path и corner case меняются местами.
> - Читателю приходится держать в голове зависимость, которую раньше показывала вложенность: спецификацию становится трудно читать.

#### Сложные иерархии: независимые характеристики

**Независимые характеристики (enum + бинарная характеристика)**

| Характеристика | Состояния, которые тестируем | Зависит от |
| --- | --- | --- |
| Роль пользователя | admin / customer | — |
| Флаг beta-доступа | enabled / disabled | — |

```ruby
describe '#feature_access' do
  context 'when user role is admin' do        # happy path: полный доступ
    it('grants access to admin tools') { ... }

    context 'and beta feature is enabled' do  # happy path: бонусный доступ
      it('grants access to beta tools') { ... }
    end

    context 'but beta feature is disabled' do # corner case для admin
      it('falls back to standard tools') { ... }
    end
  end

  context 'when user role is customer' do     # corner case: ограниченные права
    it('denies access to admin tools') { ... }

    context 'and beta feature is enabled' do  # corner case: частичное смягчение
      it('grants access to beta tools') { ... }
    end

    context 'but beta feature is disabled' do # самый строгий corner case
      it('denies access to beta tools') { ... }
    end
  end
end
```

Порядок независимых характеристик можно менять (сначала флаг, потом роль), но happy path должен оставаться выше, а отклонения — группироваться ниже на соответствующем уровне вложенности.

**Объединение независимых характеристик на интеграционном уровне:**

Согласно [пирамиде тестирования](#пирамида-тестирования-и-выбор-уровня), разные уровни тестов имеют разную ответственность:

- **Юнит-тесты** (модели, сервисы) — проверяют **все комбинации** характеристик детально
- **Integration/Request specs** — проверяют **happy path + критичные corner cases**, объединяя множество независимых предусловий в единый контекст

**В Request specs применяйте те же принципы иерархии:**

```ruby
# плохо: дублируем детальное тестирование всех комбинаций (это задача юнит-тестов)
describe 'POST /api/payments' do
  context 'when user is authenticated' do
    context 'when card is verified' do
      context 'when balance is sufficient' do
        it 'processes payment successfully'
      end

      context 'when balance is insufficient' do
        it 'rejects payment with insufficient funds error'
      end
    end

    context 'when card is not verified' do
      it 'rejects payment with verification error'
    end
  end

  context 'when user is not authenticated' do
    it 'returns 401 Unauthorized'
  end
end

# хорошо: объединяем независимые условия внутри домена, сохраняя иерархию слоёв
describe 'POST /api/payments' do
  context 'when user is authenticated' do
    context 'with valid payment prerequisites' do
      let(:user) { create(:user, :authenticated, :with_verified_card, :with_sufficient_balance) }

      it 'processes payment successfully' do
        post "/api/payments", params: { amount: 100 }
        expect(response).to have_http_status(:created)
      end
    end

    context 'when card is not verified' do
      let(:user) { create(:user, :authenticated, :with_unverified_card) }

      it 'returns 422 Unprocessable Entity' do
        post "/api/payments", params: { amount: 100 }
        expect(response).to have_http_status(:unprocessable_entity)
      end
    end
  end

  context 'when user is not authenticated' do
    let(:user) { create(:user) }

    it 'returns 401 Unauthorized' do
      post "/api/payments", params: { amount: 100 }
      expect(response).to have_http_status(:unauthorized)
    end
  end
end
```

**Философия объединения:**

**Объединяйте детали внутри одного бизнес-[домена](#домен).** На интеграционном уровне множество условий, относящихся к одной области ответственности (verified card + sufficient balance = payment prerequisites), объединяются в единое состояние. Мы проверяем что API работает в нормальном случае, а не комбинаторику всех возможных нарушений внутри [домена](#домен).

**Маркер объединения:** если для [домена](#домен) существует отдельный юнит-тест (например, `PaymentService`), значит в request spec детали этого [домена](#домен) можно объединить в единый контекст.

**Типичная структура слоёв для приложения:**

```ruby
context 'when user is authenticated' do          # Authentication layer
  context 'when user is authorized' do           # Authorization layer (роль, тарифный план)
    context 'with valid domain prerequisites' do # Конкретный бизнес-домен
      # happy path
    end

    context 'when domain prerequisite violated' do
      # corner case внутри домена
    end
  end

  context 'when user is not authorized' do
    # corner case authorization layer
  end
end

context 'when user is not authenticated' do
  # corner case authentication layer
end
```

Каждый уровень вложенности = переход к следующему [домену](#домен)/слою ответственности.

**Тестирование обратных случаев:**

Для corner cases обычно достаточно проверить **один** критичный сценарий на каждом уровне иерархии — не все возможные нарушения. Причины:

- Все corner cases внутри [домена](#домен) обрабатываются **аналогичным образом** (например, возвращают ошибку валидации в HTTP-ответе одинаково)
- Меняется только **содержимое** (текст ошибки), а не поведение системы
- Проверка всех комбинаций = **дублирование юнит-тестов** на интеграционном уровне
- Это не добавляет надёжности, только замедляет тесты, создаёт дублирование и усложняет поддержку и изменение тестов с развитием системы

Детальное тестирование всех граничных условий и их комбинаций остаётся на более низких уровнях [пирамиды](#пирамида-тестирования-и-выбор-уровня) в юнит-тестах.

**В остальном применяйте те же принципы:** иерархия зависимостей характеристик, happy path перед corner cases.

**См. также:**
- [Пирамида тестирования](#пирамида-тестирования-и-выбор-уровня) — разделение ответственности по уровням
- [Правило 26: Request specs](#26-предпочитайте-request-specs-вместо-controller-specs) — что проверять на уровне HTTP-контракта

**Когда вложенность становится слишком глубокой:**

Если иерархия контекстов уходит глубже 3-4 уровней, это **почти всегда сигнал о нарушении принципа [Do One Thing](#принципы-проектирования)** в тестируемом коде. Проблема не в тестах — проблема в дизайне кода.

**Типичные причины глубокой вложенности:**

1. **Смешивание уровней абстракции** — метод одновременно работает с бизнес-логикой и низкоуровневыми деталями
   - *Решение:* Выделите низкоуровневую логику в отдельные методы/сервисы
   - *Пример:* Парсинг данных → отдельный метод, валидация → отдельный метод, сохранение → отдельный метод

2. **Множественная ответственность** — метод решает несколько независимых задач
   - *Решение:* Разбейте на несколько методов, каждый из которых делает одно дело
   - *Пример:* `process_payment` + `update_order_status` + `update_inventory` вместо одного гигантского метода

3. **Нечёткие границы слоёв** — высокоуровневая логика совмещена с низкоуровневой реализацией
   - *Решение:* Чётко разделите слои (контроллер → сервис → репозиторий)
   - *Пример:* Контроллер не должен знать о деталях SQL-запросов

**Практическое правило:** Если для тестирования метода требуется 5+ уровней `context`, это сигнал к рефакторингу **кода**, а не к усложнению тестов. Тесты честно показывают, что метод пытается делать слишком много.

**В тестах можно временно:**
- Использовать `shared_examples` для повторяющихся проверок (уменьшает видимость дублирования)
- Разбить на несколько `describe` блоков для независимых аспектов

**Но правильное решение:** Рефакторинг кода в соответствии с Do One Thing.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Иерархия контекстов визуализирует зависимости характеристик — не нужно держать условия в голове
- Happy path сверху → читатель сразу понимает основной сценарий, не копаясь в отклонениях
- Симметричная структура (все состояния характеристики на одном уровне) упрощает навигацию: "где тест для случая X?" → "на том же уровне, что Y и Z"
- При добавлении нового состояния сразу видно, куда его поместить — структура самодокументируется

**См. также:** 
- [Правило 4: Выделяйте характеристики](#4-выделяйте-характеристики-поведения-и-их-состояния) — как определять характеристики
- [Правило 6: Финальный аудит контекстов](#6-финальный-аудит-контекстов-два-типа-дубликатов) — проверка дубликатов  
- [Правило 7: Happy path перед corner cases](#7-располагайте-happy-path-перед-corner-cases) — порядок размещения
- [Правило 10: Указывайте subject](#10-указывайте-subject-чтобы-явно-обозначить-предмет-тестирования) — явный `subject` в сочетании с чёткой иерархией контекстов делает тест максимально читаемым

### 6. Финальный аудит контекстов: два типа дубликатов

Каждый раз, как вы закончили работу над тестами, убедитесь, что структура `describe/context` реально соответствует [характеристикам](#характеристика) и их [состояниям](#состояние) из глоссария (см. пункт 5). Финальный аудит включает два типа проверок: дубликаты `let`/`before` выдают пропущенные состояния характеристик, а дубликаты `it` с одинаковыми ожиданиями выдают инвариантные контракты интерфейса.

#### 6.1. Дубликаты `let`/`before` выдают пропущенные состояния

Повторяющиеся `let` или `before` на одном уровне — тревожный сигнал: какое-то состояние не вынесено в явный контекст, и тест для него легко потерять.

Чек-лист после написания:

- Пройдитесь по каждому уровню вложенности и выпишите все `let`/`before`. Если в соседних ветках повторяются одинаковые значения, характеристику нужно поднять выше или вынести в отдельный контекст.
- Попробуйте поднять общий `let` на уровень выше. Если тесты после этого рушатся, значит, вы обнаружили скрытое состояние — добавьте для него контекст и пример.
- Сверьте структуру с первоначальным списком характеристик и их состояний. Если какое-то состояние нигде не проявилось, сценарий для него пропущен.
- Посмотрите на `before`-блоки. Повторяющаяся подготовка данных — частый признак того, что вы оставили только happy path и забыли про ветку с альтернативным контекстом.

```ruby
# плохо: дублирование let в каждом контексте
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :usd }

      it 'returns 0.15' do
        expect(discount).to eq(0.15)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :usd }

      it 'returns 0.10' do
        expect(discount).to eq(0.10)
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with gold loyalty' do
      let(:loyalty_status) { :gold }
      let(:currency) { :eur }

      it 'returns 0.12' do
        expect(discount).to eq(0.12)
      end
    end

    context 'with silver loyalty' do
      let(:loyalty_status) { :silver }
      let(:currency) { :eur }

      it 'returns 0.05' do
        expect(discount).to eq(0.05)
      end
    end
  end
end
```

```ruby
# хорошо
describe Billing::DiscountEvaluator do
  subject(:discount) { described_class.call(order) }

  let(:order) { build(:order, segment: segment, currency: currency, loyalty_status: loyalty_status) }

  context 'when segment is b2c' do
    let(:segment) { :b2c }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.15') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.10') { ... }
      end
    end
  end

  context 'when segment is b2b' do
    let(:segment) { :b2b }

    context 'with USD currency' do
      let(:currency) { :usd }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.11') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.06') { ... }
      end
    end

    context 'with EUR currency' do
      let(:currency) { :eur }

      context 'and loyalty is gold' do
        let(:loyalty_status) { :gold }
        it('returns 0.12') { ... }
      end

      context 'and loyalty is silver' do
        let(:loyalty_status) { :silver }
        it('returns 0.05') { ... }
      end
    end
  end
end
```

`Что` не так в плохом примере:

- По описанию всё похоже на правильную иерархию из пункта 4, но `currency` в каждой ветке задаётся вручную, значит, характеристика фактически «живёт» не там, где описана.
- Для состояния `currency: :usd` в сегменте `:b2b` пример отсутствует — дефект пройдёт мимо, потому что тесты читаются как полная спецификация.

Теперь:

- Валюта занимает своё место в иерархии, дубликаты `let` исчезли, и структура повторяет реальные зависимости характеристик (см. пункт 5).
- Каждая комбинация `segment → currency → loyalty_status` из предметной модели имеет пример, а отдельный corner case фиксирует негативное поведение.
- Формулировки контекстов складываются в читаемые предложения, и happy path стоит выше corner case (см. пункт 7), поэтому сценарии считываются быстро.
- При появлении нового состояния чек-лист сработает автоматически: вы либо добавите контекст, либо заметите, что возврат к общему `let` ломает тест.

#### 6.2. Дубликаты `it` с одинаковыми ожиданиями выдают инвариантные контракты

После построения симметричного дерева контекстов (пункт 5) и устранения дубликатов `let`/`before` (пункт 6.1), просмотрите все листовые контексты. Если несколько `it` повторяются с одинаковыми ожиданиями во всех или большинстве листовых контекстов — это инварианты интерфейса: правила, которые не зависят от состояний характеристик и должны выполняться всегда.

Чек-лист после написания:

1. Просмотрите все листовые контексты и выпишите все `it`.
2. Найдите ожидания, которые повторяются дословно или с минимальными вариациями.
3. Если ожидание присутствует во всех листовых контекстах, независимо от характеристик — это инвариант интерфейса.
4. Вынесите инвариантные ожидания в `shared_examples` и подключите их через `it_behaves_like` (см. пункт 25.2).

Пример см. в пункте 22.2 — класс `BookingSearchValidator`, где проверки `respond_to(:valid?)`, `respond_to(:errors)`, `respond_to(:normalized_params)` повторялись во всех четырёх листовых контекстах независимо от `client_type` и `region`. Это инварианты интерфейса, которые были вынесены в `shared_examples 'a booking search validator'`.

Такой финальный проход заставляет держать тесты на уровне поведенческого контракта, а не набора случайных happy path.

### 7. Располагайте happy path перед corner cases

Внутри каждого `describe` читающий ожидает увидеть нормальное поведение первым, а уже затем — исключения.

```ruby
# плохо
describe '#enroll' do
  context 'when enrollment is rejected because email is invalid' do
    it('shows a validation error') { ... }
  end

  context 'when enrollment is rejected because plan is sold out' do
    it('puts the user on the waitlist') { ... }
  end

  context 'when enrollment is accepted' do # happy path затерян внизу
    it('activates the membership') { ... }
  end
end
```

```ruby
# хорошо
describe '#enroll' do
  context 'when enrollment is accepted' do
    it('activates the membership') { ... }
  end

  context 'when enrollment is rejected because email is invalid' do
    it('shows a validation error') { ... }
  end

  context 'when enrollment is rejected because plan is sold out' do
    it('puts the user on the waitlist') { ... }
  end
end
```

Что не так в плохом примере:

- Happy path спрятан внизу ветки, из-за чего читатель тратит больше времени, чтобы понять нормальное поведение.
- При появлении новых corner cases порядок ещё сильнее смешается, и отчет RSpec перестанет читаться сверху вниз.

Инструкция: добавляя новые примеры, проверьте, что блоки happy path остаются первыми на своем уровне вложенности. Corner cases должны находиться ниже и либо начинаться с `but`/`without`, либо явно описывать отклонение.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Happy path сверху → читатель сразу понимает основной сценарий работы системы
- Предсказуемый порядок (успех → отклонения) → не нужно прыгать по файлу в поисках "как оно должно работать в норме?"
- Отчёт RSpec читается сверху вниз как история: сначала норма, потом исключения

**См. также:**
- [Правило 5: Иерархия контекстов](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases) — зависимые характеристики  
- [Правило 8: Положительный и отрицательный тест](#8-пишите-положительный-и-отрицательный-тест) — проверяйте оба случая

### 8. Пишите положительный и отрицательный тест

Каждая ветка контекстов описывает конкретное сочетание состояний характеристик. Для этих сочетаний нужен минимум один пример, подтверждающий поведение, и один пример, показывающий отказ — так мы защищаемся от регрессий в обе стороны.

```ruby
# плохо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }

  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния `blocked = true`
    let(:blocked) { true }

    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... настройка уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }

      it "allows unlocking the user" do
        expect(some_action).to be(true) # положительный тест для сочетания состояний характеристик `blocked`, `blocked_at`
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  # ... базовая настройка характеристик: пользователь, роль, дата блокировки
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  
  context "when user is blocked by admin" do # положительный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { true }

    # Контекст 2 уровня для состояния характеристики `blocked_at`
    context "and blocking duration is over a month" do # положительный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 2.month.ago }
      it("allows unlocking the user") { ... }
    end

    context "but blocking duration is under a month" do # отрицательный контекст для состояния характеристики `blocked_at`
      # ... состояние уточняющей характеристики `blocked_at`
      let(:blocked_at) { 1.month.ago }
      it("does NOT allow unlocking the user") { ... }
    end
  end

  context "when user is NOT blocked by admin" do # отрицательный контекст для состояния характеристики `blocked`
    # ... настройка состояния характеристики `blocked`
    let(:blocked) { false }
    it("does NOT allow unlocking the user") { ... }
  end
end
```

Что не так в плохом примере:

- Характеристика `blocked` проверяется только на положительном состоянии — защита от обратного сценария отсутствует.
- Уточняющий контекст не показывает альтернативное состояние `blocked_at`, поэтому пропущен отрицательный тест для сочетания состояний.
Если присутствуют только положительные тесты, то в дальнейшем на такие тесты нельзя полагаться,
ввиду того, что они не отразят факта регрессии поведения при дальнейших изменениях в коде,
так как они не будут проверять обратный случай.

### 9. Каждый контекст должен отражать различие вложенной части от внешней

Можно ещё сказать так: если у вас есть контекст, внутри которого между `context "..." do` и `it` пусто, это чисто
синтаксический контекст. Он либо не нужен вовсе, либо не содержит настройки, соответствующей описанию контекста.

Правило можно сформулировать иначе: настройка, которая делает контекст истинным, должна находиться сразу после строки `context "..." do`.
Не заставляйте читателя искать по всему тесту, где именно готовится контекст под описанное состояние.

```ruby
# Есть пользователи и метод some_action, позволяющий определить, можно ли пользователя разблокировать.
# У пользователей есть состояния `blocked`, `blocked_at`.
```

```ruby
# очень плохо
describe "#some_action" do
  let(:user) { build :user }
  let(:blocked_user) { build :user, blocked: true }
  let(:old_blocked_user) { build :user, blocked: true, blocked_at: 2.month.ago }

  it "does NOT allow unlocking the user" do
    expect(user.some_action).to be(false)
  end
  
  context "when user is blocked by admin" do # есть контекст
    # нет никакой настройки, которая делает его отличным от внешнего блока
    it "allows unlocking the user" do
      expect(blocked_user.some_action).to be(true)
    end
    
    context "and blocking duration is over a month" do 
      # Что отличает этот контекст от внешнего? В большом тесте искать настройку будет невозможно.
      # Экономьте свой и чужой труд — размещайте блок, который готовит контекст, сразу под объявлением: там его и ожидают увидеть.
      it "allows unlocking the user" do
        expect(old_blocked_user.some_action).to be(true)
      end
    end
  end
end
```

```ruby
# хорошо
describe "#some_action" do
  let(:blocked) { false } # базовое состояние характеристики `blocked`
  let(:blocked_at) { nil } # базовое состояние характеристики `blocked_at`
  let(:user) { build :user, blocked: blocked, blocked_at: blocked_at }
  subject(:result) { user.some_action }

  it "does NOT allow unlocking the user" do
    expect(result).to be(false)
  end

  context "when user is blocked by admin" do
    let(:blocked) { true } # настройка этого контекста — на своём месте, сразу заметна

    context "and blocking duration is over a month" do
      let(:blocked_at) { 2.month.ago } # настройка вложенного контекста — здесь же, под объявлением

      it "allows unlocking the user" do
        expect(result).to be(true)
      end
    end

    context "but blocking duration is under a month" do
      let(:blocked_at) { 1.month.ago } # отрицательное состояние характеристики `blocked_at`

      it "does NOT allow unlocking the user" do
        expect(result).to be(false)
      end
    end
  end
end
```

Что не так в плохом примере:

- Контекст `when user is blocked by admin` не задаёт отличающих условий — настройка `let` находится далеко и не читается вместе с описанием.
- Внутренний `context` не подготавливает `blocked_at`, поэтому сложно понять, какое состояние характеристики проверяется.

Кроме того, требуемое состояние может задаваться вычислением — например, располагаться внутри `before`.

## Синтаксис и читаемость

Хороший стиль тестов — это не только поведение, но и очевидность того, что читаешь: явный `subject`, предсказуемые конструкции и минимум поиска глазами.

### 10. Указывайте `subject`, чтобы явно обозначить предмет тестирования

Когда `subject` явно объявлен, читатель сразу видит, что именно проверяется, и не тратит время на поиск объекта тестирования в ожиданиях.

`subject` особенно полезен:

- Когда один и тот же результат проверяется в нескольких `it` внутри разных контекстов
- Когда действие требует подготовки или вызова метода с параметрами
- Когда нужно дать имя проверяемому результату через именованный `subject(:result)`

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Явный `subject` → сразу видно, что тестируется, не нужно искать объект в каждом `expect`
- Именованный `subject(:result)` → описательное имя заменяет повторяющиеся вызовы метода
- Структура теста становится предсказуемой → меньше времени на понимание

**См. также:** [Правило 5: Иерархия контекстов](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases) — явный `subject` особенно полезен в сочетании с чёткой иерархией контекстов по характеристикам

## Подготовка контекста и данных

Гладкие тесты строятся на повторяемом сетапе: чётких фазах Given/When/Then, фабриках, которые прячут рутину, и явных зависимостях. Этот раздел собирает практики подготовки окружения перед проверками.

### 11. Каждый тест должен быть разделен на 3 этапа в строгой последовательности

`let` и `let!` подготавливают данные, которые делают контекст истинным (Given), `before` доводит систему до нужного состояния или вызывает действие (When), а ожидания внутри `it` фиксируют результат (Then). Не смешивайте эти роли.

1. Подготовка данных для контекста (обычно через `let` или фабрики)
2. Перевод данных в нужное состояние/вызов действия (чаще `before`, иногда прямо в `it`)
3. Ожидание результата (Then)

```ruby
# очень плохо
describe "#block" do
  before do
    user = create :user
    admin = create :admin
    admin.block(user)
  end

  it "true" do
    expect(User.find(1).bloсked).to be(true)
  end
end
```

```ruby
# хорошо
describe "#block" do
  # 1 этап: подготовка данных
  let(:user) { create :user }
  let(:admin) { create :admin }

  # 2 этап: действие
  before { admin.block(user) }

  # 3 этап: проверка результата
  it "marks the user as blocked" do
    expect(user.blocked).to be(true)
  end
end
```

Вариант с действием внутри примера:

```ruby
# нормально
describe "#block" do
  # 1 этап
  let(:user) { create :user }
  let(:admin) { create :admin }

  it "marks the user as blocked" do
    # 2 этап
    admin.block(user)

    # 3 этап
    expect(user.blocked).to be(true)
  end
end
```

Что не так в плохом примере:

- Этапы Given/When/Then смешаны внутри `before`, из-за чего непонятно, где заканчивается подготовка и начинается проверка.
- Тест обращается к `User.find(1)` вместо подготовки контекста через `let`, поэтому пример зависит от глобального состояния.

Даже если действие выполняется прямо в `it`, держите структуру явной и возвращайте вычисления в `before`, когда это возможно.

- `let` ленивый: значение вычисляется при первом обращении. Если состояние контекста должно появиться до выполнения `it`, используйте `before` или `let!`, чтобы явно зафиксировать порядок и не нарушать этапы правила 8.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Предсказуемая структура (Given → When → Then) → читатель знает, где искать подготовку, действие, проверку
- Не нужно "выполнять код в голове", чтобы понять порядок выполнения
- При изменении теста сразу ясно, в какую секцию добавлять код

## FactoryBot и подготовка данных

FactoryBot помогает описывать [характеристики](#характеристика) [доменных](#домен) объектов через трейты и параметризованные хэши, поэтому используем его, чтобы тесты говорили о [поведении](#поведение), а не о технических атрибутах.

### 12. Используйте возможности FactoryBot для скрытия деталей исходных данных

Если в проекте есть FactoryBot, используйте его, чтобы тесты оставались читабельными и фиксировали только [характеристики](#характеристика) и их [состояния](#состояние).

- Дефолтная фабрика должна создавать «средний» объект, который подходит для happy path. Всё, что не участвует в описании контекста, прячьте внутрь фабрики.
- В повторяющихся сценариях оформляйте состояния через трейты: `:blocked`, `:with_verified_email`, `:expired`. Трейты можно свободно комбинировать (`create(:user, :blocked, :verified)`), получая нужные состояния без копипаста. Контексту не нужно перечислять вспомогательные поля, достаточно упомянуть характеристику.
- Избегайте ручной передачи десятков атрибутов в `create`. Если требуется много явных значений, возможно, фабрику стоит уточнить или выделить новую характеристику.

```ruby
# плохо
describe '#unlock' do
  let(:user) do
    create(:user,
           blocked: true,
           blocked_at: 2.months.ago,
           email_confirmed: true
           # ... еще 2 атрибута: last_sign_in_at, otp_required
    )
  end

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

```ruby
# хорошо
FactoryBot.define do
  factory :user do
    email { Faker::Internet.email }
    password { 'secret123' }

    trait :blocked do
      blocked { true }
      blocked_at { 2.months.ago }
    end

    trait :verified do
      email_confirmed { true }
    end
  end
end

describe '#unlock' do
  let(:user) { create(:user, :blocked, :verified) }

  it 'allows unlocking the user' do
    expect(UserUnlocker.call(user)).to be_allowed
  end
end
```

- Трейты документируют состояния характеристик и избавляют от громоздких setup-блоков.
- Читатель видит только важные характеристики (`:blocked`, `:verified`) и быстро соотносит их с описанием контекста.
- Изменения дефолтных атрибутов происходят в фабрике, поэтому тесты не «захламляются» техническими деталями данных.
- Что не так в плохом примере: фабрика используется как `create` со всеми атрибутами, поэтому тест не показывает, какие состояния важны; любое изменение вспомогательных полей требует менять тест, а не фабрику.

Такая дисциплина делает тесты чище, легче для поддержки и лучше подчёркивает бизнес-поведение.

Дополнительно: хороший обзор приёмов работы с трейтами есть у Thoughtbot — [Remove duplication with FactoryBot’s traits](https://thoughtbot.com/blog/remove-duplication-with-factorybots-traits).

### 13. Используйте `attributes_for` для генерации параметров, которые не являются важной деталью в тестировании поведения

При тестировании поведения часто важен сам факт выполнения действия (создание заказа, обновление профиля), а не конкретные значения большинства атрибутов. `attributes_for` позволяет сгенерировать валидный хэш параметров из фабрики, избегая дублирования между фабрикой и тестом.

**Ключевой принцип:** Используйте `attributes_for`, когда конкретные значения атрибутов не важны для понимания проверяемого поведения. Если атрибут критичен для теста — переопределите его явно.

**Использование attributes_for:**

**Основной use case: Request specs**

Request specs — наиболее частое место применения `attributes_for`, так как API-эндпоинты принимают хэши параметров.

```ruby
# плохо
describe 'POST /api/orders' do
  let(:order_params) do
    {
      customer_email: 'user@example.com',
      total: 150.0
      # ... еще 2 поля: currency, status
    }
  end

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('returns order id') { expect(response.parsed_body['id']).to be_present }
end
```

```ruby
# хорошо
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order) }
  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('returns order id') { expect(response.parsed_body['id']).to be_present }
end
```

**Что не так в плохом примере:**

- Значения `customer_email`, `total`, `currency`, `status` не важны для понимания теста "API создаёт заказ"
- Дублирование: те же атрибуты уже определены в `factory :order`
- Читатель вынужден анализировать каждый атрибут, хотя они не влияют на проверяемое поведение
- При изменении дефолтных значений в фабрике нужно менять и тест

**Теперь:**

- Читатель сразу видит: "используются стандартные параметры заказа"
- Не нужно анализировать несущественные детали
- Нет дублирования между фабрикой и тестом
- Изменения дефолтных значений в фабрике автоматически применяются к тесту

**Переопределение критичных атрибутов**

Если конкретное значение атрибута **важно для проверяемого поведения**, переопределите его явно:

```ruby
# хорошо: явно показываем, что тестируем b2b-сегмент
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order, segment: 'b2b', discount: 0.15) }
  before { post '/api/orders', params: order_params }

  it('applies b2b pricing') { expect(Order.last.pricing_tier).to eq('corporate') }
  it('applies 15% discount') { expect(Order.last.final_total).to eq(order_params[:total] * 0.85) }
end
```

Здесь `segment: 'b2b'` и `discount: 0.15` — критичные детали поведения, поэтому они явно переопределены.

**Комбинирование с трейтами**

```ruby
# хорошо: трейт документирует состояние
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order, :international, :with_insurance) }

  before { post '/api/orders', params: order_params }

  it('includes customs declaration') { expect(Order.last.customs_required?).to be true }
end
```

Трейты `:international` и `:with_insurance` ясно показывают характеристики заказа без необходимости перечислять десятки атрибутов.

**Другие use cases**

`attributes_for` полезен везде, где код работает с хэшами параметров:

**Form Objects:**

```ruby
describe OrderForm do
  let(:form_params) { attributes_for(:order) }
  let(:form) { described_class.new(form_params) }

  it('validates successfully') { expect(form).to be_valid }
end
```

**Service Objects:**

```ruby
describe OrderCreationService do
  let(:order_params) { attributes_for(:order) }

  it('creates order record') { expect { described_class.call(order_params) }.to change(Order, :count).by(1) }
end
```

**Когда НЕ использовать `attributes_for`**

❌ **НЕ ИСПОЛЬЗУЙТЕ когда:**

**Интерфейс API отличается от интерфейса модели** — параметры запроса имеют другие названия или структуру:

```ruby
# плохо: attributes_for возвращает атрибуты модели, а API ожидает другие названия
describe 'POST /api/orders' do
  let(:order_params) { attributes_for(:order) }  
  # factory возвращает: { customer_email: '...', total_cents: 15000 }
  # но API ожидает:     { email: '...', amount: 150.0 }

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) } # упадёт: неправильные параметры
end
```

```ruby
# хорошо: явно формируем параметры согласно API-контракту
describe 'POST /api/orders' do
  let(:order_params) do
    {
      email: 'user@example.com',      # API использует 'email', а модель 'customer_email'
      amount: 150.0                    # API использует 'amount' в рублях, а модель 'total_cents'
    }
  end

  before { post '/api/orders', params: order_params }

  it('creates new order') { expect(response).to have_http_status(:created) }
  it('maps API params to model attributes') { expect(Order.last).to have_attributes(...) }
end
```

**Золотое правило:** Если для понимания теста читатель должен открыть фабрику — значит, критичные параметры лучше прописать явно в тесте. Используйте `attributes_for` для снижения дублирования, но не в ущерб читаемости.

**См. также:** [Правило 14: build_stubbed в юнит-тестах](#14-в-юнит-тестах-кроме-моделей-используйте-build_stubbed) — для тестов, где нужны объекты (а не хэши параметров), используйте `build_stubbed`

### 14. В юнит-тестах (кроме моделей) используйте `build_stubbed`

Юнит-спеки сервисов, политик, presenter'ов и form-объектов не должны зависеть от базы данных. `build_stubbed` создаёт объект ActiveRecord без `INSERT`/`UPDATE`, но с заполненными `id`, `created_at`, `updated_at` и запретом на `save`. Это делает тесты быстрее и подчёркивает, что код работает с готовым контекстом, а не строит интеграцию с БД.

- `build_stubbed` избавляет от лишних раунд-трипов к БД и ускоряет пакет юнит-тестов.
- Объект невозможно случайно сохранить: если код пытается вызвать `save`/`reload`, тест упадёт и покажет, что вы пересекаете границу уровня (значит, нужен интеграционный тест).
- Stubbed-экземпляры удобнее подменять в doubles: у них есть `id`, предзаполненные атрибуты и отключены callbacks, поэтому тест остаётся предсказуемым.

Когда `build_stubbed` использовать не стоит:

- тест модели или скоупа, где нужно проверить реальное взаимодействие с БД;
- код, который опирается на callbacks/триггеры или читает изменения после `save`;
- фича, где валидация/уникальность/foreign key проверяются именно БД (тогда используйте `create`).

```ruby
# плохо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { create(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  it 'schedules confirmation email' do
    allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer)

    expect { call }.not_to change(Order, :count)
    expect(mailer).to have_received(:deliver_later)
  end
end
```

```ruby
# хорошо
describe Orders::Notifier do
  subject(:call) { described_class.call(order) }

  let(:order) { build_stubbed(:order, total_cents: 25_00, state: :paid) }
  let(:mailer) { instance_double(OrderMailer, deliver_later: true) }

  before { allow(OrderMailer).to receive(:confirmation).with(order).and_return(mailer) }

  it 'schedules confirmation email' do
    call
    expect(mailer).to have_received(:deliver_later)
  end
end
```

Что не так в плохом примере:

- `create` выполняет запись в базу ради данных, которыми сервис только пользуется; тесты замедляются без необходимости.
- Если реализация вызовет `save`/`reload`, тест этого не увидит, потому что объект уже живёт в БД — мы незаметно проверяем интеграционный сценарий.

Что даёт хороший пример:

- `build_stubbed` создаёт полноценный объект без обращения к БД, поэтому юнит-спеки бегут быстрее и остаются изолированными.
- Попытка сохранить объект из тестируемого кода завершится ошибкой, сигнализируя, что сценарий перешёл границу уровня и нужен интеграционный тест.

Если тест неожиданно требует `save` или чтения из базы, значит, вы тестируете поведение более высокого уровня — перенесите пример в интеграционный слой или поменяйте стратегию подготовки данных.

**См. также:** [Правило 13: attributes_for для параметров](#13-используйте-attributes_for-для-генерации-параметров-которые-не-являются-важной-деталью-в-тестировании-поведения) — когда нужны хэши параметров (а не объекты), используйте `attributes_for`

**Как FactoryBot снижает когнитивную нагрузку:**
- **Трейты** — имя трейта описывает [состояние](#состояние) модели (`:blocked`, `:verified`) → читатель видит [характеристику](#характеристика), не погружаясь в детали реализации
- **Технические детали** спрятаны в фабрике → не нужно держать в голове "а зачем здесь все эти поля?"
- **attributes_for** фокусирует на проверяемом [поведении](#поведение) → не нужно анализировать несущественные параметры
- **build_stubbed** явно сигнализирует "это юнит-тест" → сразу понятен уровень изоляции
- **Централизация [характеристик](#характеристика)** → все технические детали реализации характеристики находятся в фабрике, изменения требуют правок в одном месте, а не в десятках тестов
- **Изменения атрибутов по умолчанию** не ломают тесты → меньше ментальной нагрузки при рефакторинге

**Что это говорит о дизайне кода:**

Если фабрики становятся сложными — это сигнал о нарушении [Single Responsibility](#принципы-проектирования) и [Tight Coupling](#принципы-проектирования):

- Десятки обязательных атрибутов в фабрике → [God Object](#принципы-проектирования) (модель делает слишком много)
- Сложные callbacks и зависимости между полями → бизнес-логика утекла в ActiveRecord модель, должна быть в сервисах
- Постоянно требуется `create`, нельзя использовать `build_stubbed` → код слишком зависит от персистентности
- Нужно создавать множество связанных объектов → [тесное связывание](#принципы-проектирования), модель зависит от слишком многих деталей

**Решение:** Модель должна быть простой структурой данных. Бизнес-логику выносите в сервисы, уменьшайте связывание через Dependency Injection.

### Выбор метода FactoryBot: Decision Tree

После изучения правил 12-14, вот итоговая схема выбора метода FactoryBot:

```
┌─────────────────────────────────────────────────────────────┐
│ Нужен ли вам объект для проверки поведения?                 │
└─────────────┬───────────────────────────────────────────────┘
              │
              ├─── НЕТ (только параметры для API/контроллера)
              │    └─→ attributes_for(:user)
              │       # Возвращает { name: "...", email: "..." }
              │
              └─── ДА (нужен объект)
                   │
                   ├─── Объект должен быть сохранён в БД?
                   │    │
                   │    ├─── ДА (нужна персистентность, ассоциации, колбэки)
                   │    │    │
                   │    │    ├─── Нужны связанные объекты?
                   │    │    │    ├─── ДА → create(:order, :with_items)
                   │    │    │    │         # Используйте traits
                   │    │    │    │
                   │    │    │    └─── НЕТ → create(:user)
                   │    │    │              # Простое создание
                   │    │    │
                   │    │    └─→ Всегда create() когда нужна БД
                   │    │
                   │    └─── НЕТ (только в памяти, БД не нужна)
                   │         │
                   │         ├─── Тестируете ПОВЕДЕНИЕ этого объекта?
                   │         │    (валидации, методы модели, бизнес-логика)
                   │         │    │
                   │         │    └─→ build(:user)
                   │         │        # new_record? = true
                   │         │        # Валидации работают корректно
                   │         │
                   │         └─── Объект нужен только как ДАННЫЕ?
                   │              (передаёте в другой сервис/метод)
                   │              │
                   │              └─→ build_stubbed(:user)
                   │                  # Быстрее, id stubbed
                   │                  # persisted? = true
```

### 15. Не программируйте в тестах

Тест — это спецификация поведения, а не место для написания мини-фреймворков. Когда вместо декларативных `let`, фабрик и helper-методов появляются приватные утилиты с прямой работой с БД, тест перестаёт быть читаемым и надёжным.

```ruby
# ужасно
describe SomeService do
  it 'stores report' do
    result = described_class.call(raw_payload)

    expect(result).to be_success
    expect(find_report(result.id)).to have_attributes(status: 'done', rows: 3)
  end

  private

  def raw_payload
    DB[:reports].insert(name: 'daily', data: '{"rows":[1,2,3]}')
    DB[:reports].where(name: 'daily').first
  end

  def find_report(id)
    DB[:reports].where(id: id).first
  end
end
```

```ruby
# хорошо
describe SomeService do
  let(:report) { create(:report, :daily, :with_rows) }
  subject(:result) { described_class.call(report.payload) }

  it 'stores report' do
    expect(result).to be_success
    expect(report.reload).to have_attributes(status: 'done', rows_count: 3)
  end
end
```

Что не так в плохом примере:

- Приватные методы скрывают, как задаются состояния: читателю нужно «выполнить» код в голове, чтобы понять характеристики.
- Прямая работа с БД минует фабрики/фикстуры и создаёт жёсткую привязку к схеме.
- При изменении структуры таблиц тесты ломаются молча или дают нечитаемые ошибки.
- Если подобный стиль кажется удобным, это тревожный сигнал: такая запись тяготеет к assert-style-DSL вроде minitest. В RSpec же мы описываем поведение, а не переписываем код тестового фреймворка.

Что даёт хороший пример:

- `let` с фабрикой явно описывает характеристику (`report` со статусом и данными), а не SQL-обходные пути.
- При смене схемы адаптируем фабрику — тесты остаются декларативными и следуют глоссарию характеристик.

Это правило тесно связано с пунктами 1, 7 и 8: мы описываем поведение, проверяем обе стороны правила и держим подготовку контекста рядом с его описанием.

**Что это говорит о дизайне кода:**

Если тесты требуют сложной подготовки (прямая работа с БД, приватные хелперы, обходные пути) — это сигнал о нарушении [инкапсуляции](#принципы-проектирования) и [утечке абстракций](#принципы-проектирования):

- Невозможно создать объект через публичный API → логика создания слишком сложна или скрыта
- Нужно знать детали схемы БД для тестовых данных → [доменный](#домен) слой не изолирован от персистентности
- Приватные хелперы для обхода публичного API → возможно [God Object](#принципы-проектирования) (слишком много ответственностей)
- Прямая работа с БД в тестах сервисного слоя → нарушены границы слоёв

**Решение:** Объект должно быть легко создать через публичный API (фабрики, конструкторы). Если нужны обходные пути — рефакторите код, разделите ответственности.

### 16. Явность важнее DRY

В BDD-тестах важно, чтобы было сразу видно ЧТО проверяется. Читаемость и понятность спецификации важнее устранения дублирования кода. Если extraction метода или переменной делает тест менее очевидным — оставьте дублирование.

Тесты — это документация поведения системы. Когда читатель открывает spec-файл, он должен сразу понимать контекст и проверяемое поведение, не прыгая по определениям вспомогательных методов.

Конечно, это не значит отказ от `let`, фабрик или shared contexts — они как раз помогают декларативно описать характеристики. Но если абстракция скрывает важную деталь проверки, лучше написать явно.

**Важно:** Этот пункт требует выбора золотой середины. Всегда можно дискутировать, где проходит граница между полезной абстракцией и избыточной явностью. Нет универсального правила — решение зависит от контекста, сложности [домена](#домен) и договорённостей команды.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- **Единый DSL RSpec** — все знают этот язык тестирования, не нужно изучать каждый раз новый "диалект"
- **Программирование в тестах** создаёт собственный мини-язык → команде приходится изучать custom API каждого spec-файла
- **Интеграция с экосистемой** — RSpec DSL даёт понятный вывод при падении, custom код выдаёт невнятные ошибки
- **Согласованность синтаксиса** — `let`, фабрики, матчеры работают предсказуемо, приватные методы с БД-логикой нарушают ожидания

## Язык описания спецификаций

Правила из этого раздела напрямую снижают [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка) при чтении и поддержке тестов. Когда описания спецификаций составляют понятные предложения на естественном языке, тесты превращаются в читаемую документацию: разработчик сразу понимает, какое поведение проверяется, не погружаясь в детали реализации.

**Как это работает:**
- Понятный язык снижает extraneous load (постороннюю нагрузку) — не нужно тратить умственные усилия на расшифровку сокращений, технических терминов или неясных формулировок
- Читабельные описания высвобождают ресурсы для понимания бизнес-правил (germane load)
- Единый стиль формулировок создаёт предсказуемость — знакомая структура позволяет быстрее находить нужные тесты
- Когда упавший тест читается как предложение, сразу понятно, какое правило нарушено

**См. также:** [Когнитивная нагрузка](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка)

### 17. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны составлять валидное предложение на английском языке

Описание спецификаций (`describe`/`context`/`it`) пишите по-английски: так отчёты RSpec остаются читаемыми в CI, а команда использует единый язык описания поведения.
Для примера оставим только описание тестов, без примера создания тестовых данных и изменений в контекстах.

```ruby
# отвратительно
describe "#some_action" do
  context "blocked" do # что заблокировано, когда, кем? что это вообще значит?
    context "month ago" do # месяц назад что? заблокирован? точно?
      it("true") { test } # что значит true? как оно оценивается?
    end
  end
end
# когда вы запустите тест он вернет вот такое непонятное описание
# #some_action user blocked month ago /it/ true
```

```ruby
# идеально
describe "#some_action" do
  context "when user is blocked by admin" do # здесь понятно, кто, что и с кем сделал
    context "and blocking duration is over a month" do # а здесь уже понятно что это продолжение предложения, начатого в прошлом контексте
      it("allows unlocking the user") { test } # ага, теперь вообще понятно, зачем этот метод нужен, в чем его ценность
      # он определяет "можно ли разблокировать пользователя?"
    end
  end
end
# #some_action when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user
```

Что не так в плохом примере:

- Контексты не складываются в цельное предложение: непонятно, кто заблокирован и что означает `month ago`.
- Описание `it("true")` не рассказывает о поведении, поэтому отчёт RSpec не несёт смысла.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Предложение читается естественно → не нужно мысленно восстанавливать смысл из отрывочных слов
- Отчёт RSpec сразу показывает, какое бизнес-правило нарушено — не нужно открывать код
- При большом количестве тестов понятные названия работают как содержание книги — быстро находишь нужное

### 18. Описание контекстов `context` и тестовых кейсов `it` вместе (включая `it`) должны быть написаны так, чтобы их понимал любой человек

Здесь имеется ввиду, что описание поведения должно быть абсолютно однозначно понятным и не требующим познания чего-то специфичного из программирования.
Вы должны быть в состоянии просто дать все описания тестов любому человеку, для того чтобы он в свою очередь прочитав их мог понять бизнес.

```ruby
when user is blocked by admin and blocking duration is over a month /it/ allows unlocking the user
when user is blocked by admin but blocking duration is under a month /it/ does NOT allow unlocking the user
```

вполне понятное описание, по которому однозначно понятно, что разблокировать пользователя заблокированного менее месяца назад нельзя.

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Описания без технического жаргона понятны всем участникам команды — не только разработчикам, но и бизнес-аналитикам
- Менеджеры и product owner могут читать отчёты тестов как спецификацию → команда говорит на одном языке
- Новые разработчики быстрее вникают в [домен](#домен), читая тесты как документацию бизнес-правил
- Когда упал тест, его описание сразу объясняет, что сломалось в терминах бизнеса, без необходимости знать код

### 19. Грамматика формулировок в describe/context/it

Мы описываем устойчивое поведение системы, поэтому формулировки должны звучать как правила домена, а не как инструкции тестировщику.

1. **Present Simple.** Поведение считается верным всегда, поэтому говорим о нем в настоящем времени: `it 'returns the summary'`. Настоящее простое время делает фразу универсальной и убирает ощущение временности.
2. **Активный залог в `it`, третье лицо.** Субъектом предложения выступает объект системы: `order generates invoice`, `service authenticates user`. Так читающий понимает, кто выполняет действие, и предложение остается коротким.
3. **Пассивный залог и глаголы-состояния для контекстов.** Контекст задает состояние характеристики, поэтому используем форму `is/are + V3` или короткие конструкции со статичным глаголом: `when user is blocked`, `when account has balance`. Так мы фиксируем факт состояния, а не действие, которое к нему привело.
4. **Zero conditional для связки контекста и результата.** В паре `context/it` обе части остаются в Present Simple: `when payment is confirmed, it issues receipt`. Такая структура читается как бизнес-правило «если … то …» без временных сдвигов.
5. **Без модальных глаголов и лишних слов.** Избегаем `should`, `can`, `must` и вводных конструкций (`it should`, `it is expected that`). Остается декларация поведения — она короче и лучше ложится в отчеты.
6. **Явное отрицание `NOT`.** Негативные сценарии выделяем капсом: в контекстах — `when user is NOT verified`, в примерах — `it 'does NOT unlock user'`. Так в отчете сразу видно, что падает отрицательный кейс.

Минимальный шаблон: объект и характеристику описываем в `describe`, контекст — через `context` в пассивном залоге, ожидаемую реакцию — через `it` в активном Present Simple.

```ruby
describe OrderMailer do
  context 'when invoice is generated' do
    it 'sends the invoice email'
  end
end
```

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Единая грамматика создаёт предсказуемость — знакомая структура позволяет читать тесты как формулы
- Present Simple превращает тест в декларацию правила [домена](#домен), а не в описание последовательности шагов
- Активный залог в `it` делает субъект действия очевидным — не нужно мысленно переворачивать предложение
- Отсутствие модальных глаголов (`should`, `can`) делает формулировку короче и убирает неопределённость
- `NOT` капсом сразу выделяет негативные сценарии — в длинном отчёте видно, что именно упало

### 20. Язык контекстов: when / with / and / without / but / NOT

Следуем логике Gherkin, чтобы ветка читалась как последовательность уточнений контекста. Каждая связка отвечает типу состояния и уровню вложенности.

- **`when …`** — открывает ветку и описывает состояние базовой характеристики. На этом уровне часто нет `it`, потому что дальше ветка уточняется. Пример: `context 'when user has a payment card' do … end`.
- **`with …`** — вводит первое уточняющее положительное состояние и продолжает happy path: `context 'with verified email'`.
- **`and …`** — добавляет ещё одно положительное состояние в том же направлении. Можно использовать несколько подряд, пока ветка остаётся частью happy path: `context 'and balance covers the price'`.
- **`without …`** — используем для бинарных характеристик, когда явно показываем обе полярности. Happy path описан положительным состоянием, поэтому ветка `without …` сразу содержит тест, демонстрирующий альтернативный исход: `context 'without verified email' do … end`.
- **`but …`** — подчёркивает противопоставление happy path. Часто применяется, когда happy path основан на состоянии по умолчанию (отдельный `with`-контекст не нужен). Контекст `but …` обязан содержать тест, показывающий, как меняется поведение, когда базовый контекст перестаёт выполняться: `context 'but balance does NOT cover the price'`.
- **`NOT`** — используем капсом внутри названия контекста или `it`, чтобы подчеркнуть отрицательное состояние бинарной характеристики либо выделить отрицательный тест: `context 'when user does NOT have a payment card'`, `it 'does NOT charge the card'`.
- Если в описании `it` появляется `when`/`with`/`and`/`without`/`but`, значит, вы потеряли соответствующий контекст. Вынесите это состояние в `context`, иначе пример будет смешивать Given и Then и нарушит правила 1–7. Исключение — отрицательные формулировки с `does NOT`, где `NOT` подчёркивает результат, а не контекст.

Рекомендуемая последовательность внутри ветки: `when` → `with` → `and` (по необходимости) → `but`/`without` → `it`. Как только контекст полностью подготовлен, добавляем пример: happy path или corner case.

```ruby
describe '#charge' do
  context 'when user has a payment card' do                      # базовая характеристика
    context 'with verified email' do                            # happy path уточнение
      context 'and balance covers the price' do                 # ещё одно happy path состояние
        it 'charges the card'                                   # happy path case
      end

      context 'but balance does NOT cover the price' do         # corner case: противопоставление
        it 'does NOT charge the card'                           # отрицательный тест
      end
    end

    context 'without verified email' do                         # corner case: отсутствие обязательного состояния
      it 'does NOT charge the card'
    end
  end

  context 'when user does NOT have a payment card' do           # другая ветка для бинарной характеристики
    it 'does NOT charge the card'
  end
end
```

Следите, чтобы happy path ветка шла первой на своём уровне, а контексты с `without`/`but` логически ссылались на неё: «когда всё хорошо → что происходит; но если базовый контекст ломается → как меняется результат».

Иногда happy path строится на значении по умолчанию, и дополнительный `with`-контекст не нужен — пример можно разместить сразу под `when`. Corner case всё так же раскрывается через `but` или `without` на том же уровне.

```ruby
describe '#authenticate' do
  context 'when account exists' do                        # базовая ветка
    it 'signs the user in'                                # happy path сразу под when

    context 'but account is blocked' do                   # corner case на том же уровне
      it 'denies the sign-in'
    end
  end

  context 'when account does NOT exist' do                # противопоставление на уровне контекста
    it 'denies the sign-in'
  end
end
```

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Единая система связок (`when`/`with`/`and`/`but`/`without`) создаёт грамматику тестов — читающий предсказывает структуру
- Последовательность "базовая характеристика → уточнение → противопоставление" соответствует логике размышления о [домене](#домен)
- Happy path идёт первым → сначала понимаем норму, потом corner cases становятся очевидными отклонениями
- Запрет `when`/`with` в `it` означает, что контекст всегда выделен явно — не нужно держать условия в голове
- Логика Gherkin (Given → When → Then) распределяется по уровням иерархии, а не смешивается в одном месте

### 21. Изучите подробно правила из rubocop по части наименования <https://rspec.rubystyle.guide/#naming>

## Инструменты и поддержка тестов

### 22. Не используйте [any_instance](https://rspec.info/features/3-13/rspec-mocks/old-syntax/any-instance/), allow_any_instance_of, expect_any_instance_of

В большинстве случаев это "запах" к тому, что вы не следуете `dependency inversion principle`,
или, что ваш класс не следует `single responsibility` и объединяет в себе код для двух акторов,
которые в свою очередь зависят друг от друга в одностороннем порядке.
Таким образом, ваш класс можно разбить на два класса поменьше, для которых в свою очередь можно покрыть тестами их поведение в отдельных тестах.
Справедливости ради, следовать этому правилу не очень просто тогда, когда у вас накопился гигантский технический долг, поэтому это правило может иметь исключения.

Подробнее о том, почему его не стоит использовать, читайте здесь <https://rspec.info/features/3-13/rspec-mocks/working-with-legacy-code/any-instance/>.

```ruby
# плохо: allow_any_instance_of глобально мокает все экземпляры
describe HighLevelClass do
   before do
      allow_any_instance_of(LowLevelClass).to receive(:foo).and_return({some_key: :some_value})
   end

   it "returns the processed value" do
      expect(HighLevelClass.new.some_method).to eq(:some_expected_value)
   end
end

# хорошо: инъекция зависимости через конструктор
describe HighLevelClass do
   let(:low_level_dependency) { instance_double(LowLevelClass) }
   subject(:instance) { described_class.new(low_level_dependency) }

   before do
      allow(low_level_dependency).to receive(:foo).and_return({some_key: :some_value})
      # теперь мы просто разрешаем вернуть нужное нам значение одному instance double
      # причем будет проверка что такой метод действительно есть у данного класса
   end

   it "returns the processed value" do
      expect(instance.some_method).to eq(:some_expected_value)
   end
end
```

Что не так в плохом примере:

- `allow_any_instance_of` глобально подменяет метод `foo` и затрагивает все экземпляры класса, из-за чего тест перестает быть изолированным.
- Класс не принимает зависимость явно, поэтому приходится пробивать мок через глобальную настройку, вместо того чтобы внедрить ее через конструктор.

**Что это говорит о дизайне кода:**

Если вам нужен `any_instance_of` — это **всегда** сигнал о нарушении [Dependency Injection](#принципы-проектирования) и [Tight Coupling](#принципы-проектирования):

- Класс создаёт зависимости внутри себя (`SomeClass.new` в методе) вместо того, чтобы принимать их через конструктор
- Класс зависит от конкретных реализаций, а не от абстракций → нарушение Dependency Inversion (SOLID)
- Невозможно протестировать класс в изоляции — нельзя передать mock через конструктор
- Класс жёстко связан с деталями реализации зависимостей

**Решение:** Используйте [Dependency Injection](#принципы-проектирования) — передавайте зависимости через конструктор. Если нужен `any_instance_of`, проблема в коде — рефакторите.

### 23. Используйте `:aggregate_failures` только когда описываете одно правило

**Навигация по правилу:**
- [Практическая проблема: неполный контекст при отладке](#практическая-проблема-неполный-контекст-при-отладке)
- [Руководство по использованию](#руководство-по-использованию)
- [Руководство по принятию решения: один `it` или несколько?](#руководство-по-принятию-решения-один-it-или-несколько)
- [Паттерны тестирования: до/после](#паттерны-тестирования-допосле)

По умолчанию один `it` содержит одну проверку. `:aggregate_failures` полезен, когда мы говорим об одном поведении и хотим увидеть все нарушения сразу, вместо того чтобы фиксировать только первое упавшее ожидание.

**Ключевой принцип:** Используйте `:aggregate_failures` только если все ожидания описывают один и тот же бизнес-исход и зависят от одного набора подготовленных состояний контекста. Не применяйте флаг, чтобы спрятать разные поведения в одном `it` — так вы нарушаете правило 3.

#### Практическая проблема: неполный контекст при отладке

**Зачем нужен `:aggregate_failures`**

Без `:aggregate_failures` RSpec останавливается на первом упавшем ожидании. Это создаёт дорогостоящий цикл отладки, особенно в следующих сценариях:

**Сценарий 1: [Flaky-тесты](#характеристики-и-состояния), которые падают только в CI**

Представьте: у вас есть тест API-эндпоинта, который иногда падает только в CI-окружении (проблемы с таймингами, race conditions, особенности базы данных). Локально воспроизвести не получается, и каждая итерация отладки через CI занимает 10-15 минут.

```ruby
# без aggregate_failures
it 'returns order details' do
  get "/api/orders/#{order.id}"
  
  expect(response).to have_http_status(:ok)           # ✅ прошло
  expect(response.content_type).to match(/json/)      # ✅ прошло
  expect(response.parsed_body['id']).to eq(order.id)  # ❌ ПАДЕНИЕ: nil вместо order.id
  # Тест останавливается здесь. Вы не знаете про остальные поля
  expect(response.parsed_body['status']).to eq('pending')
  expect(response.parsed_body['total']).to eq(150.0)
  expect(response.parsed_body['customer_email']).to be_present
end
```

**Что происходит:**

1. CI падает: "expected order.id, got nil"
2. Видя только одну ошибку, вы предполагаете: "наверное, проблема с ID в маршруте". Исправляете логику получения `order.id`, пушите, ждёте 15 минут
3. CI падает снова: "expected 'pending', got nil" — оказывается, `status` тоже `nil`. Теперь думаете: "может, проблема в scope для статуса?"
4. Исправляете scope, пушите, ждёте ещё 15 минут
5. CI падает: "expected 150.0, got nil" — и `total` тоже сломан. Наконец понимаете: весь сериализатор не работает!
6. **Итого: 45+ минут потрачено + 2 неправильных исправления из-за неполного контекста**

**Проблема неполного контекста:** Видя только первое падение, вы не понимаете масштаб проблемы. Вместо того чтобы сразу увидеть "весь `parsed_body` пустой → сериализатор сломан", вы решаете локальные проблемы (`id`, потом `status`, потом `total`), которые на самом деле симптомы одной глобальной причины. Неполный контекст ведёт к неправильной диагностике и неэффективным исправлениям. Как говорится, знание — сила.

```ruby
# с aggregate_failures
it 'returns order details', :aggregate_failures do
  get "/api/orders/#{order.id}"
  
  expect(response).to have_http_status(:ok)
  expect(response.content_type).to match(/json/)
  expect(response.parsed_body['id']).to eq(order.id)
  expect(response.parsed_body['status']).to eq('pending')
  expect(response.parsed_body['total']).to eq(150.0)
  expect(response.parsed_body['customer_email']).to be_present
end
```

**Вывод с aggregate_failures показывает ВСЁ сразу:**

```ruby
Failures:

  1) GET /api/orders/:id returns order details
     Got 4 failures:

     1.1) Failure/Error: expect(response.parsed_body['id']).to eq(order.id)
            expected: 123
                 got: nil

     1.2) Failure/Error: expect(response.parsed_body['status']).to eq('pending')
            expected: "pending"
                 got: nil

     1.3) Failure/Error: expect(response.parsed_body['total']).to eq(150.0)
            expected: 150.0
                 got: nil

     1.4) Failure/Error: expect(response.parsed_body['customer_email']).to be_present
            expected present value
                 got: nil
```

Вы **сразу видите**, что проблема глобальная — сериализатор вообще не работает, `parsed_body` пустой. Исправляете за один раз, пушите, ждёте 15 минут — готово. **Экономия: 30+ минут.**

**Сценарий 2: Тесты, которые нельзя запустить локально**

Иногда тесты зависят от окружения, которое сложно поднять локально:

- Интеграция с внешним сервисом (staging-окружение)
- Специфичная инфраструктура (Kubernetes, особые сетевые настройки)
- Доступ к определённым данным или credentials, которые есть только в CI

В таких случаях каждый запуск теста — это коммит + push + ожидание CI. Если тест проверяет 6 атрибутов объекта и все сломаны, без `:aggregate_failures` вам придётся сделать 6 итераций вместо одной.

Аналогичная проблема возникает с длительными интеграционными тестами, хотя такие встречаются редко.

**Правило:** Если тест проверяет атрибуты одного результата (объект, HTTP-ответ, результат вычислений) и вы не можете быстро переитерировать (CI-only, [flaky](#характеристики-и-состояния)), используйте `:aggregate_failures`. Это экономит время и нервы команды.

#### Руководство по использованию

**Когда использовать `:aggregate_failures`**

✅ **ИСПОЛЬЗУЙТЕ когда:**

1. **Проверяете атрибуты одного созданного/полученного объекта** — атрибуты выводятся из одного источника и формируют целостный интерфейс (см. правило 2.1 [Интерфейсное тестирование](#интерфейсное-тестирование)):

   ```ruby
   # нормально: aggregate_failures покажет все несоответствия сразу
   it 'exposes user profile attributes', :aggregate_failures do
     expect(profile.full_name).to eq('John Doe')
     expect(profile.email).to eq('john@example.com')
     expect(profile.account_type).to eq('premium')
   end
   
   # идеально: have_attributes даёт тот же эффект + компактнее
   it 'exposes user profile attributes' do
     expect(profile).to have_attributes(
       full_name: 'John Doe',
       email: 'john@example.com',
       account_type: 'premium'
     )
   end
   ```

   **Предпочитайте `have_attributes`** когда проверяете атрибуты объекта — он автоматически показывает все несоответствия и делает код читаемее (см. правило 3.1).

2. **Тестируете интерфейс/контракт объекта в заданном состоянии** — все проверки относятся к единому представлению:

   ```ruby
   # нормально
   it 'provides shipping address details', :aggregate_failures do
     expect(address.street).to eq('123 Main St')
     expect(address.city).to eq('Springfield')
     expect(address.postal_code).to eq('12345')
     expect(address.country).to eq('USA')
   end
   
   # идеально
   it 'provides shipping address details' do
     expect(address).to have_attributes(
       street: '123 Main St',
       city: 'Springfield',
       postal_code: '12345',
       country: 'USA'
     )
   end
   ```

3. **Проверяете структуру HTTP-ответа** — статус, заголовки и основные поля тела ответа как единый контракт:

   ```ruby
   it 'returns successful response with order data', :aggregate_failures do
     post '/orders', params: order_params
     expect(response).to have_http_status(:created)
     expect(response.content_type).to match(/json/)
     expect(response.parsed_body).to include('id', 'status', 'total')
   end
   ```

4. **Проверяете связанные значения, выведенные из одного источника** — вычисляемые или производные атрибуты:

   ```ruby
   it 'calculates order totals correctly', :aggregate_failures do
     expect(order.subtotal).to eq(100.0)
     expect(order.tax).to eq(8.0)
     expect(order.total).to eq(108.0)
   end
   ```

❌ **НЕ ИСПОЛЬЗУЙТЕ когда:**

1. **Тестируете разные поведения** — каждое действие вызывает независимый бизнес-эффект:

   ```ruby
   # плохо: два независимых поведения
   it 'creates order and sends confirmation', :aggregate_failures do
     expect { place_order }.to change(Order, :count).by(1)
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   
   # хорошо: разделены на отдельные тесты
   it 'creates an order' do
     expect { place_order }.to change(Order, :count).by(1)
   end
   
   it 'enqueues confirmation email' do
     expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
   end
   ```

2. **Тестируете разных акторов** — каждый актор представляет отдельное правило:

   ```ruby
   # плохо: два актора с разной логикой
   it 'hides notifications', :aggregate_failures do
     expect(admin_notifications).to be_hidden
     expect(user_notifications).not_to be_hidden
   end
   
   # хорошо: отдельные контексты для каждого актора
   context 'for admin' do
     it 'hides admin notifications' do
       expect(admin_notifications).to be_hidden
     end
   end
   
   context 'for regular user' do
     it 'does NOT hide user notifications' do
       expect(user_notifications).not_to be_hidden
     end
   end
   ```

#### Дополнительные рекомендации

- **Держите описание конкретным:** Даже с флагом название `it` должно чётко указывать, что проверяется. Избегайте общих формулировок (`'works correctly'`, `'returns data'`).
- **Ограничивайте количество ожиданий:** Если в тесте больше 10-15 ожиданий, возможно вы проверяете слишком много — подумайте о разбиении на несколько тестов или вынесении части логики.
- **Подготовка контекста не оправдывает смешивание поведений:** Даже если setup дорогой, правильнее оптимизировать фабрики или вынести общий контекст в `before`, чем прятать независимые правила в одном `it`.

#### Руководство по принятию решения: один `it` или несколько?

Когда непонятно, объединять проверки в один тест или разделять на несколько, используйте эти контрольные вопросы:

#### 1. "Можно ли описать эти проверки одним предложением для нетехнического человека?"

**Если НЕТ** (требуются разные предложения) → Разделяйте на отдельные `it`.

Пример: "Система создаёт заказ" и "система отправляет подтверждение" — нужны два предложения, это два разных действия с точки зрения бизнеса.

**Если ДА** (одно предложение описывает всё) → Рассмотрите один `it` с `:aggregate_failures`.

Пример: "Профиль пользователя содержит имя, email и тип аккаунта" — одно предложение описывает единое представление данных профиля.

#### 2. "Тестирует ли каждое ожидание независимый путь выполнения кода?"

**Если ДА** → Разделяйте на отдельные `it`.

Пример: Проверка создания записи (`expect { ... }.to change(Order, :count)`) и проверка отправки email (`expect { ... }.to have_enqueued_job`) выполняют разные ветки логики.

**Если НЕТ** → Один `it` с `:aggregate_failures`.

Пример: Все атрибуты презентера вычисляются из одного объекта `product` — нет ветвления, только трансформация данных.

#### 3. "Проверяю ли я разные части публичного интерфейса?"

**Если ДА, разные части** → Разделяйте на отдельные `it`.

Пример: `#create_order` и `#send_confirmation` — это разные методы, каждый из которых представляет отдельное поведение.

**Если НЕТ, один интерфейс** → Один `it` с `:aggregate_failures`.

Пример: Все проверки относятся к атрибутам одного метода `#summary` — это единый интерфейс объекта в заданном состоянии.

#### Примеры применения

**Вопрос 1: Можно ли описать это одним предложением?**

"Создаёт заказ" + "Отправляет email" → НЕТ, нужны два разных предложения → Разделяем

```ruby
# плохо
it 'processes order', :aggregate_failures do
  expect { place_order }.to change(Order, :count).by(1)
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end
```

```ruby
# хорошо
it 'creates an order' do
  expect { place_order }.to change(Order, :count).by(1)
end

it 'enqueues confirmation email' do
  expect { place_order }.to have_enqueued_job(OrderConfirmationJob)
end
```

**Но если это интерфейс:**

"Продукт предоставляет свой каталожный интерфейс (имя + цена + наличие)" → ДА, одно предложение описывает всё → Объединяем

```ruby
# нормально
it 'exposes catalog interface', :aggregate_failures do
  expect(product.name).to eq('Laptop')
  expect(product.price).to eq(999.99)
  expect(product.availability).to eq('In Stock')
end
```

```ruby
# идеально
it 'exposes catalog interface' do
  expect(product).to have_attributes(
    name: 'Laptop',
    price: 999.99,
    availability: 'In Stock'
  )
end
```

```ruby
# Вопрос 2: Независимые пути выполнения?
# Создание Order и отправка Email — разные пути
# → ДА → Разделяем

it 'creates an order' do
  expect { checkout }.to change(Order, :count).by(1)
end

it 'sends confirmation email' do
  expect { checkout }.to have_enqueued_job(OrderConfirmationJob)
end
```

**Вопрос 3: Один интерфейс или разные?**

AddressPresenter#formatted_address предоставляет несколько строк адреса → Один интерфейс → Объединяем

```ruby
# нормально
it 'formats address with all components', :aggregate_failures do
  expect(presenter.street_line).to eq('123 Main St')
  expect(presenter.city_line).to eq('Springfield, IL')
  expect(presenter.country_line).to eq('USA 12345')
end
```

```ruby
# идеально
it 'formats address with all components' do
  expect(presenter).to have_attributes(
    street_line: '123 Main St',
    city_line: 'Springfield, IL',
    country_line: 'USA 12345'
  )
end
```

#### Быстрый чек-лист

| Критерий | Разделять | Объединять |
|----------|-----------|------------|
| Можно описать каждую проверку отдельным предложением для бизнеса | ✅ | ❌ |
| Проверки затрагивают независимые пути кода | ✅ | ❌ |
| Тестируются разные методы/поведения | ✅ | ❌ |
| Все атрибуты из одного источника/состояния | ❌ | ✅ |
| Проверяется интерфейс объекта (value object, presenter, config) | ❌ | ✅ |
| Проверки описывают единое представление данных | ❌ | ✅ |

**Золотое правило:** Если сомневаетесь — разделяйте. Лучше иметь больше точных тестов, чем один неопределённый.

#### Паттерны тестирования: до/после

Этот раздел показывает типичные антипаттерны и их правильные версии.

#### Пример 1: Тестирование конфигурационного объекта

❌ **Over-splitting (излишнее разделение):**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  let(:env_vars) do
    {
      'APP_NAME' => 'MyStore',
      'APP_URL' => 'https://mystore.com',
      'SUPPORT_EMAIL' => 'support@mystore.com'
      # ... еще 3 переменные: NOREPLY_EMAIL, MAX_UPLOAD_SIZE, SESSION_TIMEOUT
    }
  end

  it('returns application name from ENV') { expect(config.app_name).to eq('MyStore') }
  it('returns application URL from ENV') { expect(config.app_url).to eq('https://mystore.com') }
  it('returns support email from ENV') { expect(config.support_email).to eq('support@mystore.com') }
  # ... еще 3 проверки для noreply_email, max_upload_size, session_timeout
end
```

**Проблемы:**

- 6 отдельных тестов проверяют одно поведение: "конфигурация корректно инициализируется из ENV"
- При добавлении нового параметра придётся создавать ещё один тест
- Все тесты зависят от одного источника (`env_vars`), но это не отражено в структуре
- Если источник изменится, все 6 тестов упадут, хотя проблема одна

✅ **Правильное интерфейсное тестирование:**

```ruby
describe AppConfig do
  subject(:config) { described_class.new(env_vars) }

  context 'when initialized from environment variables' do
    let(:env_vars) do
      {
        'APP_NAME' => 'MyStore',
        'APP_URL' => 'https://mystore.com',
        'SUPPORT_EMAIL' => 'support@mystore.com'
        # ... еще 3 переменные: NOREPLY_EMAIL, MAX_UPLOAD_SIZE, SESSION_TIMEOUT
      }
    end

    it 'exposes configuration interface from ENV', :aggregate_failures do
      # Application identity
      expect(config.app_name).to eq('MyStore')
      expect(config.app_url).to eq('https://mystore.com')
      
      # ... еще 4 проверки для email адресов и лимитов
    end
  end

  context 'when required ENV variables are missing' do
    let(:env_vars) { {} }

    it 'raises configuration error' do
      expect { config.app_name }.to raise_error(AppConfig::MissingConfigError)
    end
  end
end
```

**Преимущества:**

- Один тест ясно выражает поведение: "объект предоставляет полный интерфейс из ENV"
- Группировка комментариями показывает структуру конфигурации
- Отдельный контекст для error case проверяет другое поведение (валидацию)
- Быстрее выполняется (один setup вместо шести)
- Легче читается и поддерживается

#### Пример 2: Тестирование API-ответа

❌ **Излишняя детализация (проверка всего хэша):**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001', stock: 5) }

  it 'returns product details' do
    get "/api/products/#{product.id}"
    
    expect(response.parsed_body).to eq({
      'id' => product.id,
      'name' => 'Laptop',
      'price' => 999.99,
      'sku' => 'LPT-001',
      'stock' => 5
      # ... еще 6 полей: category, created_at, updated_at, description, weight, dimensions
    })
  end
end
```

**Проблемы:**

- Тест сломается при добавлении любого нового поля в сериализатор
- Проверяются технические детали (`created_at`, `updated_at`), не важные для бизнеса
- Не понятно, какие поля критичны для клиента API
- Тест фиксирует реализацию, а не контракт

✅ **Правильный подход: проверка ключевых полей + специализированные инструменты:**

```ruby
describe 'GET /api/products/:id' do
  let(:product) { create(:product, name: 'Laptop', price: 999.99, sku: 'LPT-001') }

  it 'returns product with essential attributes', :aggregate_failures do
    get "/api/products/#{product.id}"
    
    expect(response).to have_http_status(:ok)
    expect(response.parsed_body).to include(
      'id' => product.id,
      'name' => 'Laptop',
      'price' => a_value_within(0.01).of(999.99),
      'sku' => 'LPT-001'
    )
  end

  # Полная структура ответа фиксируется через rspec-openapi или RSwag
  # (см. раздел "Тестирование API-контрактов")
end
```

**Преимущества:**

- Тест проверяет только критичные для бизнеса поля
- Использование `include` позволяет добавлять новые поля без поломки теста
- `a_value_within` учитывает особенности Float-арифметики
- Полная структура API фиксируется отдельными инструментами (OpenAPI, JSON Schema)

#### Пример 3: Принудительный вызов ленивого let

❌ **Вызов let внутри before (антипаттерн eager инициализации):**

```ruby
describe OrderProcessor do
  subject(:processor) { described_class.new }

  context 'when products are available in stock' do
    let(:product) { create(:product, stock: 10) }
    let(:order) { create(:order, product: product) }

    before do
      product  # <- принудительный вызов для eager инициализации
      order
    end

    it 'processes the order successfully' do
      result = processor.call(order)
      expect(result).to be_success
    end

    it 'decreases product stock' do
      processor.call(order)
      expect(product.reload.stock).to eq(9)
    end
  end
end
```

**Проблемы:**

- `let` создан для ленивой инициализации (lazy evaluation), а `before` вызывает их принудительно
- Неочевидно, зачем нужен отдельный `before` блок — это создаёт путаницу при чтении
- Смешивается роль Given (подготовка данных через `let`) с явной инициализацией (роль `before`)
- Нарушает принцип явности — если нужна eager инициализация, для этого есть `let!`

✅ **Используйте let! для eager инициализации:**

```ruby
describe OrderProcessor do
  subject(:processor) { described_class.new }

  context 'when products are available in stock' do
    let!(:product) { create(:product, stock: 10) }
    let!(:order) { create(:order, product: product) }

    it 'processes the order successfully' do
      result = processor.call(order)
      expect(result).to be_success
    end

    it 'decreases product stock' do
      processor.call(order)
      expect(product.reload.stock).to eq(9)
    end
  end
end
```

**Преимущества:**

- `let!` явно показывает, что объекты создаются перед каждым тестом (eager evaluation)
- Меньше кода, нет лишнего `before` блока
- Идиоматичный RSpec — `let!` существует именно для этой цели
- Соблюдается разделение ролей из пункта 11: `let!` = Given (подготовка данных), `before` остаётся для When (действие/операция)

**Как это снижает [когнитивную нагрузку](#почему-мы-пишем-тесты-именно-так-когнитивная-нагрузка):**
- Видим все нарушения сразу → полный контекст проблемы, правильная диагностика с первого раза
- Экономия циклов отладки (особенно в CI) → меньше фрустрации и переключений контекста
- Флаг `:aggregate_failures` явно сигнализирует "это проверка одного правила с множеством аспектов"

**См. также:** [Правило 2: Проверяйте, что тест тестирует](#2-проверяйте-что-тест-тестирует) — используйте `:aggregate_failures` при проверке теста на Red, чтобы сразу увидеть все нарушения

### 24. Предпочитайте verifying doubles (`instance_double`, `class_double`, `object_double`)

`double` создаёт «анонимный» двойник без проверки интерфейса. Он позволяет замокать несуществующие методы и пропустить регрессию, когда контракт меняется. `instance_double`, `class_double` и `object_double` проверяют интерфейс реальных объектов и защищают от ложных зелёных тестов.

```ruby
# плохо
let(:gateway) { double('PaymentGateway', charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end
```

```ruby
# хорошо
let(:gateway) { instance_double(PaymentGateway, charge: true) }

it 'charges the card' do
  service = Checkout.new(gateway: gateway)
  service.call(order)
  expect(gateway).to have_received(:charge).with(order.total_cents)
end
```

Что не так в плохом примере:

- `double` принимает любые методы, поэтому опечатка или изменение интерфейса пройдут незамеченными.
- Тест остаётся зелёным даже при несовпадении контракта с реальным `PaymentGateway`, и регрессия попадёт в продакшен.

- `instance_double(SomeClass)` проверяет методы экземпляра `SomeClass`.
- `class_double(SomeClass)` — методы самого класса (например, `.find`, `.call`).
- `object_double(existing_object)` — фиксирует интерфейс конкретного объекта (удобно для зависимостей, построенных в тесте).

**Когда verifying double использовать нельзя:**

- Класс или модуль создаётся динамически и ещё не загружен в момент выполнения теста (`require` отсутствует).
- Интерфейс формируется через `method_missing`/`respond_to_missing?`, и в спецификации нет сигнатур, которые можно проверить (например, `OpenStruct`, `Hashie::Mash`).
- Вы мокаете внешний сервис, у которого нет Ruby-класса (SOAP/XML API), и эмуляция происходит через `Struct.new` или обёртку на лету.

В этих редких ситуациях:

- Документируйте причину (`let(:gateway) { double('LegacyGateway') } # нет реального класса, метод задаётся в runtime`).
- Ограничьте контракт явными `allow(...).to receive(:method)` и добавьте интеграционный тест, который проверит реальное взаимодействие.

Во всех остальных случаях выбирайте verifying doubles — это дешёвый способ поймать опечатку ещё до запуска приложения.

### 25. Используйте shared examples для декларации контрактов

`shared_examples` служат для декларации контрактов — ожиданий, которые повторяются в разных местах. Они не про DRY ради снижения строк кода — тесты мы не «программируем» (см. пункт 15), они описывают правила. Если ожидание повторяется, выносите именно его описание и наблюдаемые последствия.

Существует два сценария использования shared examples:

#### 25.1. Для общего поведения разных объектов

Когда несколько классов реализуют один контракт (например, включают общий модуль), используйте shared examples для проверки общего поведения.

- Название `shared_examples` формулируйте через поведение по формуле: **`'a/an + [прилагательное] + существительное [+ уточнение]'`**. Примеры: `'an enumerable resource'`, `'a pageable API'`, `'a collection of orders'`. Так в выводе RSpec видно, какое правило описывается.
  - Проверка правильности: подставьте в предложение **"it behaves like [ваше_название]"**. Если звучит как естественное английское предложение — название подходит.
  - Исключение: абстрактные существительные могут использоваться без артикля (`'sortability'`, `'enumerability'`).
- Применяйте `it_behaves_like`/`it_should_behave_like` там, где объект реально реализует контракт: например, класс включает модуль с общими методами (`Enumerable`, ваш `Paginatable` mixin).
- Внутри shared examples работайте только с публичным интерфейсом, ожидая то же поведение, которое проверял бы отдельный тест.

```ruby
# shared_examples: spec/support/shared_examples/paginatable.rb
RSpec.shared_examples 'a pageable API' do
  it('returns the second page') { expect(resource.paginate(page: 2).current_page).to eq 2 }
  it('limits page size') { expect(resource.paginate(page: 1, per_page: 5).items.count).to eq 5 }
end

# использование
describe OrdersQuery do
  subject(:resource) { described_class.new(scope: Order.all) }

  it_behaves_like 'a pageable API'
end

describe UsersQuery do
  subject(:resource) { described_class.new(scope: User.active) }

  it_behaves_like 'a pageable API'
end
```

- Shared example формулирует «что значит быть pageable», без нелепых «general behaviour».
- Каждый класс, включающий модуль `Paginatable`, подключает shared example и доказывает, что контракт выполняется.
- Если нужно добавить новую характеристику (например, сортировку), расширяете shared example — все клиенты автоматически проверяют обновлённый контракт.

#### 25.2. Для инвариантных ожиданий внутри одного теста

Когда вы проверяете объект с множеством характеристик и обнаруживаете ожидания, которые повторяются во всех листовых контекстах (независимо от состояний характеристик), — это инварианты интерфейса. Они должны выполняться всегда, вне зависимости от входных данных.

- Инвариантные ожидания выявляются на этапе финального аудита (см. пункт 6.2).
- Вынесите повторяющиеся `it` в `shared_examples` и подключите их в корневом `describe` или в каждом листовом контексте через `it_behaves_like`.
- Название формулируйте через контракт: `'valid booking search params'`, `'serializable to JSON'`, `'responds to required methods'`.

Пример: класс `BookingSearchValidator` проверяет параметры поиска отелей. Независимо от типа клиента (b2c/b2b) и региона поиска (domestic/international), он всегда должен возвращать структуру с полями `valid?`, `errors`, `normalized_params`.

```ruby
# плохо: повторяющиеся it во всех листовых контекстах
describe BookingSearchValidator do
  subject(:validator) { described_class.new(params, client_type: client_type, region: region) }

  context 'when client is b2c' do
    let(:client_type) { :b2c }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { ... } # параметры внутреннего поиска

      it('validates check_in date') { expect(validator.valid?).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { ... } # параметры международного поиска

      it('validates international booking rules') { expect(validator.valid?).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end
  end

  context 'when client is b2b' do
    let(:client_type) { :b2b }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { ... } # параметры внутреннего поиска

      it('applies b2b pricing rules') { expect(validator.normalized_params[:pricing_tier]).to eq('corporate') }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { ... } # параметры международного поиска

      it('applies international b2b rules') { expect(validator.normalized_params[:requires_passport]).to be true }
      # ... те же три it 'responds to' для valid?, errors, normalized_params
    end
  end
end
```

```ruby
# хорошо: инвариант вынесен в shared_examples
RSpec.shared_examples 'a booking search validator' do
  it('responds to valid?') { expect(validator).to respond_to(:valid?) }
  it('responds to errors') { expect(validator).to respond_to(:errors) }
  it('responds to normalized_params') { expect(validator).to respond_to(:normalized_params) }
end

describe BookingSearchValidator do
  subject(:validator) { described_class.new(params, client_type: client_type, region: region) }

  context 'when client is b2c' do
    let(:client_type) { :b2c }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { { check_in: '2025-11-01', check_out: '2025-11-03', guests: 2 } }

      it_behaves_like 'a booking search validator'

      it 'validates check_in date' do
        expect(validator.valid?).to be true
      end
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { { check_in: '2025-12-01', check_out: '2025-12-05', guests: 1 } }

      it_behaves_like 'a booking search validator'

      it 'validates international booking rules' do
        expect(validator.valid?).to be true
      end
    end
  end

  context 'when client is b2b' do
    let(:client_type) { :b2b }

    context 'and region is domestic' do
      let(:region) { :domestic }
      let(:params) { { check_in: '2025-11-10', check_out: '2025-11-15', guests: 5 } }

      it_behaves_like 'a booking search validator'

      it 'applies b2b pricing rules' do
        expect(validator.normalized_params[:pricing_tier]).to eq('corporate')
      end
    end

    context 'and region is international' do
      let(:region) { :international }
      let(:params) { { check_in: '2026-01-01', check_out: '2026-01-10', guests: 3 } }

      it_behaves_like 'a booking search validator'

      it 'applies international b2b rules' do
        expect(validator.normalized_params[:requires_passport]).to be true
      end
    end
  end
end
```

- Три проверки `respond_to` повторялись во всех четырёх листовых контекстах — это инвариант интерфейса.
- Shared example `'a booking search validator'` декларирует обязательный контракт результата валидации.
- Каждый листовой контекст теперь содержит только проверки, специфичные для его характеристик (b2c/b2b, domestic/international).
- При добавлении нового метода в интерфейс валидатора (например, `warnings`), достаточно расширить shared example, и все контексты автоматически проверят новый контракт.

Использование shared examples не отменяет требования писать осмысленные контексты и `it`. Они помогают избежать дублирования контрактов, но не подменяют понятные спецификации.

### 26. Предпочитайте Request specs вместо controller specs

Controller specs считаются устаревшими: Rails core и RSpec core команды официально рекомендуют писать Request specs, начиная с релиза RSpec 3.5 и Rails 5.0 ([подробнее](https://rspec.info/blog/2016/07/rspec-3-5-has-been-released/#rails-support-for-rails-5)). Request specs проверяют HTTP-контракт, а значит остаются ближе к наблюдаемому поведению и не зависят от внутренних контроллерных фильтров.

- Для новых тестов выбирайте Request specs; только они покрывают стек Rack → контроллер → middleware целиком и показывают, что увидит клиент.
- Если приходится поддерживать legacy controller specs, помечайте их как наследие (например, `describe SomeController, :legacy`) и планируйте миграцию. При доработках расширяйте по [пирамиде](#пирамида-тестирования-и-выбор-уровня): поведение — в Request spec, мелкую логику выносите в сервис/модель и покрывайте юнитами.
- Не дублируйте проверки: если действие уже описано на уровне Request spec, controller spec лишь повторит реализацию и будет ломаться при рефакторинге маршрутов или фильтров.

## Тестирование API-контрактов: границы применимости RSpec

Детальный разбор переехал в отдельный документ `guide.api.ru.md`, чтобы основной гайд оставался компактным.

- Используйте RSpec Request specs для поведения: HTTP-статусы, ключевые поля и побочные эффекты.
- Для структуры JSON-ответов подключайте специализированные инструменты (JSON Schema, rswag, Pact) — они публикуют контракты и не ломаются при изменении реализации.
- Не пытайтесь хранить контракт в десятках `expect`: держите его в одном месте, а в RSpec проверяйте только наблюдаемые правила.

[Полный гайд с анти-паттернами, инструментами и практическим пайплайном →](./guide.api.ru.md)

## Миграция legacy-тестов

Если у вас есть существующий test suite, который не следует правилам этого руководства, вот стратегии постепенного улучшения без полной переписывания.

### Миграция от implementation-focused к behavior-focused тестам

**Проблема:** Тесты проверяют внутреннюю реализацию (вызовы методов, внутренние состояния) вместо наблюдаемого поведения.

**Стратегия постепенной миграции:**

1. **Не переписывайте всё сразу** — начните с тех файлов, которые чаще всего меняются или чаще ломаются
2. **При каждом изменении кода:**
   - Найдите тесты, проверяющие `receive`, `allow`, внутренние приватные методы
   - Спросите: "Какое наблюдаемое поведение проверяет этот тест?"
   - Перепишите проверку через публичный интерфейс и ожидаемый результат
3. **Маркируйте legacy-тесты:** Используйте возможности RSpec metadata — добавьте кастомный тег (например `:legacy`) к старым тестам, чтобы отслеживать прогресс миграции
4. **Измеряйте прогресс:** Периодически проверяйте количество тестов с тегом `:legacy`

**Пример рефакторинга:**

```ruby
# до: проверяем реализацию
it 'calls notification service' do
  expect(NotificationService).to receive(:send_email).with(user.email)
  subject.process_order(order)
end

# после: проверяем поведение
it 'sends confirmation email to user' do
  expect { subject.process_order(order) }
    .to change { ActionMailer::Base.deliveries.count }.by(1)
  
  email = ActionMailer::Base.deliveries.last
  expect(email.to).to include(user.email)
  expect(email.subject).to include('Order Confirmation')
end
```

### Рефакторинг глубоких иерархий контекстов

**Проблема:** Контексты вложены на 5+ уровней, трудно читать и понимать зависимости.

**Стратегия:**

1. **Идентифицируйте характеристики:**
   - Выпишите все условия из вложенных `context`
   - Определите, какие из них — реальные [характеристики](#характеристика), а какие — технические детали
2. **Упростите условия через объединение:**
   - Объедините независимые условия в одно состояние (см. [валидные способы объединения](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases))
   - Разделите зависимые характеристики по принципу happy path vs corner cases
3. **Используйте shared_examples для повторяющихся проверок:**
   - Если одно и то же поведение проверяется в разных ветках контекстов, вынесите в `shared_examples`
4. **Рефакторите код, если тесты показывают проблему:**
   - Глубокая вложенность часто сигнализирует о том, что метод делает слишком много ([Do One Thing](#принципы-проектирования))
   - Рассмотрите выделение логики в отдельные методы/сервисы (см. [Правило 5](#5-стройте-иерархию-context-по-зависимостям-характеристик-happy-path--corner-cases))

**Пример:**

```ruby
# до: 6 уровней вложенности
describe '#process_payment' do
  context 'when user is authenticated' do
    context 'when user has payment card' do
      context 'when card is verified' do
        context 'when balance is sufficient' do
          context 'when transaction is not duplicate' do
            context 'when fraud check passes' do
              it 'processes payment' # теряемся в условиях
            end
          end
        end
      end
    end
  end
end

# после: разбиваем на логические группы
describe '#process_payment' do
  context 'when all payment prerequisites are met' do
    let(:user) { create(:user, :authenticated, :with_verified_card) }
    let(:card) { user.payment_card }
    before { card.update(balance: 1000) }

    it 'processes payment successfully' do
      # фокус на happy path
    end
  end

  context 'when payment is blocked' do
    # отдельный describe для fraud/duplicate checks
  end

  context 'when payment fails' do
    # отдельный describe для failure cases
  end
end
```

### Внедрение структуры по характеристикам в существующие тесты

**Проблема:** Тесты организованы хаотично, без явного выделения характеристик и их состояний.

**Стратегия:**

1. **Начните с одного файла-примера:**
   - Выберите spec-файл средней сложности (не слишком простой, не слишком сложный)
   - Примените правила 4-5 из этого руководства
   - Покажите команде разницу в читаемости
2. **Используйте как шаблон:**
   - При написании новых тестов следуйте структуре из примера
   - Постепенно рефакторите существующие файлы при изменениях
3. **Фокусируйтесь на проблемных областях:**
   - Файлы с частыми flaky tests
   - Файлы, которые сложно понять новым разработчикам
   - Файлы, которые ломаются при каждом изменении требований
4. **Документируйте паттерны команды:**
   - Создайте внутренний wiki с примерами хороших тестов из вашего кодбейса
   - Добавляйте комментарии-шаблоны для типичных сценариев

**Ключевое правило:** Не требуйте немедленной миграции всех тестов — это приведёт к сопротивлению команды. Вместо этого делайте постепенные улучшения при каждом касании кода, и через несколько месяцев тест-сьют естественным образом станет лучше.

## Внешние сервисы

- **HTTP-запросы.** Реальные вызовы в тестах запрещены: включайте WebMock (или аналог) и явно разрешайте только те хосты, которые эмулируете. Любая попытка обратиться во внешний интернет должна завершаться понятной ошибкой.
- **Фиксация контрактов.** Если протокол стабилен, используйте VCR — он фиксирует ответы и предотвращает флейки. Когда важнее документировать формат и семантику, подключайте контрактные тесты: Pact для сценариев потребитель ↔ поставщик, `rspec-openapi` или RSwag для актуальной OpenAPI-спецификации. В контракте фиксируйте только публичные поля, иначе получится тест реализации.
- **Очереди и фоновые джобы.** В спецификациях проверяйте факт постановки (`expect { ... }.to have_enqueued_job`) и корректность аргументов. Бизнес-логику самой джобы выносите в отдельный юнит-тест: там запускаем `perform`/`perform_now` и убеждаемся, что поведение соответствует правилам [домена](#домен).

## Нюансы времени между Ruby и PostgreSQL

- `Date#wday` возвращает 0 для воскресенья, в то время как `EXTRACT(DOW FROM ...)` в PostgreSQL даёт 0 по воскресеньям и 1 по понедельникам. Совмещая Ruby- и SQL-проверки в тестах, явно фиксируйте ожидаемый день недели и не сравнивайте цифры «как есть».
- `Date.current.beginning_of_week` подчиняется `Rails.application.config.beginning_of_week`, а `date_trunc('week', ...)` в PostgreSQL по ISO всегда стартует с понедельника. Если приложение работает с календарём, добавляйте тесты, которые проверяют корректный «первый день недели» через публичный интерфейс, иначе легко получить [flaky тест](#характеристики-и-состояния) при смене настройки.
- `Date.parse` и `Time.parse` игнорируют `Time.zone`, тогда как ActiveRecord сохраняет `timestamp` в UTC. В тестах, где важна зона, используйте `Time.zone.parse`, `Time.zone.local` и `in_time_zone`, а ожидания выносите в `Time.zone.at`/`change`.
- Переходы через полночь и DST: PostgreSQL вычисляет интервалы UTC-значениями, а Ruby при `travel_to` может попасть в «не существующий» час. Чтобы не ловить плавающие падения, фиксируйте время в середине дня (`travel_to(Time.zone.parse('2024-03-25 12:00'))`) и пишите отдельные примеры на переходы, если бизнес-процесс затрагивает крайние точки.
